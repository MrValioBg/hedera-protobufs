<!DOCTYPE html>

<html>
  <head>
    <title>Protocol Documentation</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>
    <style>
      body {
        width: 60em;
        margin: 1em auto;
        color: #222;
        font-family: "Ubuntu", sans-serif;
        padding-bottom: 4em;
      }

      h1 {
        font-weight: normal;
        border-bottom: 1px solid #aaa;
        padding-bottom: 0.5ex;
      }

      h2 {
        border-bottom: 1px solid #aaa;
        padding-bottom: 0.5ex;
        margin: 1.5em 0;
      }

      h3 {
        font-weight: normal;
        border-bottom: 1px solid #aaa;
        padding-bottom: 0.5ex;
      }

      a {
        text-decoration: none;
        color: #567e25;
      }

      table {
        width: 100%;
        font-size: 80%;
        border-collapse: collapse;
      }

      thead {
        font-weight: 700;
        background-color: #dcdcdc;
      }

      tbody tr:nth-child(even) {
        background-color: #fbfbfb;
      }

      td {
        border: 1px solid #ccc;
        padding: 0.5ex 2ex;
      }

      td p {
        text-indent: 1em;
        margin: 0;
      }

      td p:nth-child(1) {
        text-indent: 0;  
      }

       
      .field-table td:nth-child(1) {  
        width: 10em;
      }
      .field-table td:nth-child(2) {  
        width: 10em;
      }
      .field-table td:nth-child(3) {  
        width: 6em;
      }
      .field-table td:nth-child(4) {  
        width: auto;
      }

       
      .extension-table td:nth-child(1) {  
        width: 10em;
      }
      .extension-table td:nth-child(2) {  
        width: 10em;
      }
      .extension-table td:nth-child(3) {  
        width: 10em;
      }
      .extension-table td:nth-child(4) {  
        width: 5em;
      }
      .extension-table td:nth-child(5) {  
        width: auto;
      }

       
      .enum-table td:nth-child(1) {  
        width: 10em;
      }
      .enum-table td:nth-child(2) {  
        width: 10em;
      }
      .enum-table td:nth-child(3) {  
        width: auto;
      }

       
      .scalar-value-types-table tr {
        height: 3em;
      }

       
      #toc-container ul {
        list-style-type: none;
        padding-left: 1em;
        line-height: 180%;
        margin: 0;
      }
      #toc > li > a {
        font-weight: bold;
      }

       
      .file-heading {
        width: 100%;
        display: table;
        border-bottom: 1px solid #aaa;
        margin: 4em 0 1.5em 0;
      }
      .file-heading h2 {
        border: none;
        display: table-cell;
      }
      .file-heading a {
        text-align: right;
        display: table-cell;
      }

       
      .badge {
        width: 1.6em;
        height: 1.6em;
        display: inline-block;

        line-height: 1.6em;
        text-align: center;
        font-weight: bold;
        font-size: 60%;

        color: #89ba48;
        background-color: #dff0c8;

        margin: 0.5ex 1em 0.5ex -1em;
        border: 1px solid #fbfbfb;
        border-radius: 1ex;
      }
    </style>

    
    <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
  </head>

  <body>

    <h1 id="title">Protocol Documentation</h1>

    <h2>Table of Contents</h2>

    <div id="toc-container">
      <ul id="toc">
        
          
          <li>
            <a href="#basic_types.proto">basic_types.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.AccountAmount"><span class="badge">M</span>AccountAmount</a>
                </li>
              
                <li>
                  <a href="#proto.AccountID"><span class="badge">M</span>AccountID</a>
                </li>
              
                <li>
                  <a href="#proto.ContractID"><span class="badge">M</span>ContractID</a>
                </li>
              
                <li>
                  <a href="#proto.CurrentAndNextFeeSchedule"><span class="badge">M</span>CurrentAndNextFeeSchedule</a>
                </li>
              
                <li>
                  <a href="#proto.FeeComponents"><span class="badge">M</span>FeeComponents</a>
                </li>
              
                <li>
                  <a href="#proto.FeeData"><span class="badge">M</span>FeeData</a>
                </li>
              
                <li>
                  <a href="#proto.FeeSchedule"><span class="badge">M</span>FeeSchedule</a>
                </li>
              
                <li>
                  <a href="#proto.FileID"><span class="badge">M</span>FileID</a>
                </li>
              
                <li>
                  <a href="#proto.Fraction"><span class="badge">M</span>Fraction</a>
                </li>
              
                <li>
                  <a href="#proto.Key"><span class="badge">M</span>Key</a>
                </li>
              
                <li>
                  <a href="#proto.KeyList"><span class="badge">M</span>KeyList</a>
                </li>
              
                <li>
                  <a href="#proto.NftTransfer"><span class="badge">M</span>NftTransfer</a>
                </li>
              
                <li>
                  <a href="#proto.NodeAddress"><span class="badge">M</span>NodeAddress</a>
                </li>
              
                <li>
                  <a href="#proto.NodeAddressBook"><span class="badge">M</span>NodeAddressBook</a>
                </li>
              
                <li>
                  <a href="#proto.RealmID"><span class="badge">M</span>RealmID</a>
                </li>
              
                <li>
                  <a href="#proto.ScheduleID"><span class="badge">M</span>ScheduleID</a>
                </li>
              
                <li>
                  <a href="#proto.SemanticVersion"><span class="badge">M</span>SemanticVersion</a>
                </li>
              
                <li>
                  <a href="#proto.ServiceEndpoint"><span class="badge">M</span>ServiceEndpoint</a>
                </li>
              
                <li>
                  <a href="#proto.ServicesConfigurationList"><span class="badge">M</span>ServicesConfigurationList</a>
                </li>
              
                <li>
                  <a href="#proto.Setting"><span class="badge">M</span>Setting</a>
                </li>
              
                <li>
                  <a href="#proto.ShardID"><span class="badge">M</span>ShardID</a>
                </li>
              
                <li>
                  <a href="#proto.Signature"><span class="badge">M</span>Signature</a>
                </li>
              
                <li>
                  <a href="#proto.SignatureList"><span class="badge">M</span>SignatureList</a>
                </li>
              
                <li>
                  <a href="#proto.SignatureMap"><span class="badge">M</span>SignatureMap</a>
                </li>
              
                <li>
                  <a href="#proto.SignaturePair"><span class="badge">M</span>SignaturePair</a>
                </li>
              
                <li>
                  <a href="#proto.StakingInfo"><span class="badge">M</span>StakingInfo</a>
                </li>
              
                <li>
                  <a href="#proto.ThresholdKey"><span class="badge">M</span>ThresholdKey</a>
                </li>
              
                <li>
                  <a href="#proto.ThresholdSignature"><span class="badge">M</span>ThresholdSignature</a>
                </li>
              
                <li>
                  <a href="#proto.TokenAssociation"><span class="badge">M</span>TokenAssociation</a>
                </li>
              
                <li>
                  <a href="#proto.TokenBalance"><span class="badge">M</span>TokenBalance</a>
                </li>
              
                <li>
                  <a href="#proto.TokenBalances"><span class="badge">M</span>TokenBalances</a>
                </li>
              
                <li>
                  <a href="#proto.TokenID"><span class="badge">M</span>TokenID</a>
                </li>
              
                <li>
                  <a href="#proto.TokenRelationship"><span class="badge">M</span>TokenRelationship</a>
                </li>
              
                <li>
                  <a href="#proto.TokenTransferList"><span class="badge">M</span>TokenTransferList</a>
                </li>
              
                <li>
                  <a href="#proto.TopicID"><span class="badge">M</span>TopicID</a>
                </li>
              
                <li>
                  <a href="#proto.TransactionFeeSchedule"><span class="badge">M</span>TransactionFeeSchedule</a>
                </li>
              
                <li>
                  <a href="#proto.TransactionID"><span class="badge">M</span>TransactionID</a>
                </li>
              
                <li>
                  <a href="#proto.TransferList"><span class="badge">M</span>TransferList</a>
                </li>
              
              
                <li>
                  <a href="#proto.HederaFunctionality"><span class="badge">E</span>HederaFunctionality</a>
                </li>
              
                <li>
                  <a href="#proto.SubType"><span class="badge">E</span>SubType</a>
                </li>
              
                <li>
                  <a href="#proto.TokenFreezeStatus"><span class="badge">E</span>TokenFreezeStatus</a>
                </li>
              
                <li>
                  <a href="#proto.TokenKycStatus"><span class="badge">E</span>TokenKycStatus</a>
                </li>
              
                <li>
                  <a href="#proto.TokenPauseStatus"><span class="badge">E</span>TokenPauseStatus</a>
                </li>
              
                <li>
                  <a href="#proto.TokenSupplyType"><span class="badge">E</span>TokenSupplyType</a>
                </li>
              
                <li>
                  <a href="#proto.TokenType"><span class="badge">E</span>TokenType</a>
                </li>
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#consensus_create_topic.proto">consensus_create_topic.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.ConsensusCreateTopicTransactionBody"><span class="badge">M</span>ConsensusCreateTopicTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#consensus_delete_topic.proto">consensus_delete_topic.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.ConsensusDeleteTopicTransactionBody"><span class="badge">M</span>ConsensusDeleteTopicTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#consensus_get_topic_info.proto">consensus_get_topic_info.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.ConsensusGetTopicInfoQuery"><span class="badge">M</span>ConsensusGetTopicInfoQuery</a>
                </li>
              
                <li>
                  <a href="#proto.ConsensusGetTopicInfoResponse"><span class="badge">M</span>ConsensusGetTopicInfoResponse</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#consensus_service.proto">consensus_service.proto</a>
            <ul>
              
              
              
              
                <li>
                  <a href="#proto.ConsensusService"><span class="badge">S</span>ConsensusService</a>
                </li>
              
            </ul>
          </li>
        
          
          <li>
            <a href="#consensus_submit_message.proto">consensus_submit_message.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.ConsensusMessageChunkInfo"><span class="badge">M</span>ConsensusMessageChunkInfo</a>
                </li>
              
                <li>
                  <a href="#proto.ConsensusSubmitMessageTransactionBody"><span class="badge">M</span>ConsensusSubmitMessageTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#consensus_topic_info.proto">consensus_topic_info.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.ConsensusTopicInfo"><span class="badge">M</span>ConsensusTopicInfo</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#consensus_update_topic.proto">consensus_update_topic.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.ConsensusUpdateTopicTransactionBody"><span class="badge">M</span>ConsensusUpdateTopicTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#contract_call.proto">contract_call.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.ContractCallTransactionBody"><span class="badge">M</span>ContractCallTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#contract_call_local.proto">contract_call_local.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.ContractCallLocalQuery"><span class="badge">M</span>ContractCallLocalQuery</a>
                </li>
              
                <li>
                  <a href="#proto.ContractCallLocalResponse"><span class="badge">M</span>ContractCallLocalResponse</a>
                </li>
              
                <li>
                  <a href="#proto.ContractFunctionResult"><span class="badge">M</span>ContractFunctionResult</a>
                </li>
              
                <li>
                  <a href="#proto.ContractLoginfo"><span class="badge">M</span>ContractLoginfo</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#contract_create.proto">contract_create.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.ContractCreateTransactionBody"><span class="badge">M</span>ContractCreateTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#contract_delete.proto">contract_delete.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.ContractDeleteTransactionBody"><span class="badge">M</span>ContractDeleteTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#contract_get_bytecode.proto">contract_get_bytecode.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.ContractGetBytecodeQuery"><span class="badge">M</span>ContractGetBytecodeQuery</a>
                </li>
              
                <li>
                  <a href="#proto.ContractGetBytecodeResponse"><span class="badge">M</span>ContractGetBytecodeResponse</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#contract_get_info.proto">contract_get_info.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.ContractGetInfoQuery"><span class="badge">M</span>ContractGetInfoQuery</a>
                </li>
              
                <li>
                  <a href="#proto.ContractGetInfoResponse"><span class="badge">M</span>ContractGetInfoResponse</a>
                </li>
              
                <li>
                  <a href="#proto.ContractGetInfoResponse.ContractInfo"><span class="badge">M</span>ContractGetInfoResponse.ContractInfo</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#contract_get_records.proto">contract_get_records.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.ContractGetRecordsQuery"><span class="badge">M</span>ContractGetRecordsQuery</a>
                </li>
              
                <li>
                  <a href="#proto.ContractGetRecordsResponse"><span class="badge">M</span>ContractGetRecordsResponse</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#contract_update.proto">contract_update.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.ContractUpdateTransactionBody"><span class="badge">M</span>ContractUpdateTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#crypto_add_live_hash.proto">crypto_add_live_hash.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.CryptoAddLiveHashTransactionBody"><span class="badge">M</span>CryptoAddLiveHashTransactionBody</a>
                </li>
              
                <li>
                  <a href="#proto.LiveHash"><span class="badge">M</span>LiveHash</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#crypto_adjust_allowance.proto">crypto_adjust_allowance.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.CryptoAdjustAllowanceTransactionBody"><span class="badge">M</span>CryptoAdjustAllowanceTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#crypto_approve_allowance.proto">crypto_approve_allowance.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.CryptoAllowance"><span class="badge">M</span>CryptoAllowance</a>
                </li>
              
                <li>
                  <a href="#proto.CryptoApproveAllowanceTransactionBody"><span class="badge">M</span>CryptoApproveAllowanceTransactionBody</a>
                </li>
              
                <li>
                  <a href="#proto.NftAllowance"><span class="badge">M</span>NftAllowance</a>
                </li>
              
                <li>
                  <a href="#proto.TokenAllowance"><span class="badge">M</span>TokenAllowance</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#crypto_create.proto">crypto_create.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.CryptoCreateTransactionBody"><span class="badge">M</span>CryptoCreateTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#crypto_delete.proto">crypto_delete.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.CryptoDeleteTransactionBody"><span class="badge">M</span>CryptoDeleteTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#crypto_delete_allowance.proto">crypto_delete_allowance.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.CryptoDeleteAllowanceTransactionBody"><span class="badge">M</span>CryptoDeleteAllowanceTransactionBody</a>
                </li>
              
                <li>
                  <a href="#proto.NftRemoveAllowance"><span class="badge">M</span>NftRemoveAllowance</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#crypto_delete_live_hash.proto">crypto_delete_live_hash.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.CryptoDeleteLiveHashTransactionBody"><span class="badge">M</span>CryptoDeleteLiveHashTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#crypto_get_account_balance.proto">crypto_get_account_balance.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.CryptoGetAccountBalanceQuery"><span class="badge">M</span>CryptoGetAccountBalanceQuery</a>
                </li>
              
                <li>
                  <a href="#proto.CryptoGetAccountBalanceResponse"><span class="badge">M</span>CryptoGetAccountBalanceResponse</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#crypto_get_account_records.proto">crypto_get_account_records.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.CryptoGetAccountRecordsQuery"><span class="badge">M</span>CryptoGetAccountRecordsQuery</a>
                </li>
              
                <li>
                  <a href="#proto.CryptoGetAccountRecordsResponse"><span class="badge">M</span>CryptoGetAccountRecordsResponse</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#crypto_get_info.proto">crypto_get_info.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.CryptoGetInfoQuery"><span class="badge">M</span>CryptoGetInfoQuery</a>
                </li>
              
                <li>
                  <a href="#proto.CryptoGetInfoResponse"><span class="badge">M</span>CryptoGetInfoResponse</a>
                </li>
              
                <li>
                  <a href="#proto.CryptoGetInfoResponse.AccountInfo"><span class="badge">M</span>CryptoGetInfoResponse.AccountInfo</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#crypto_get_live_hash.proto">crypto_get_live_hash.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.CryptoGetLiveHashQuery"><span class="badge">M</span>CryptoGetLiveHashQuery</a>
                </li>
              
                <li>
                  <a href="#proto.CryptoGetLiveHashResponse"><span class="badge">M</span>CryptoGetLiveHashResponse</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#crypto_get_stakers.proto">crypto_get_stakers.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.AllProxyStakers"><span class="badge">M</span>AllProxyStakers</a>
                </li>
              
                <li>
                  <a href="#proto.CryptoGetStakersQuery"><span class="badge">M</span>CryptoGetStakersQuery</a>
                </li>
              
                <li>
                  <a href="#proto.CryptoGetStakersResponse"><span class="badge">M</span>CryptoGetStakersResponse</a>
                </li>
              
                <li>
                  <a href="#proto.ProxyStaker"><span class="badge">M</span>ProxyStaker</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#crypto_service.proto">crypto_service.proto</a>
            <ul>
              
              
              
              
                <li>
                  <a href="#proto.CryptoService"><span class="badge">S</span>CryptoService</a>
                </li>
              
            </ul>
          </li>
        
          
          <li>
            <a href="#crypto_transfer.proto">crypto_transfer.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.CryptoTransferTransactionBody"><span class="badge">M</span>CryptoTransferTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#crypto_update.proto">crypto_update.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.CryptoUpdateTransactionBody"><span class="badge">M</span>CryptoUpdateTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#custom_fees.proto">custom_fees.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.AssessedCustomFee"><span class="badge">M</span>AssessedCustomFee</a>
                </li>
              
                <li>
                  <a href="#proto.CustomFee"><span class="badge">M</span>CustomFee</a>
                </li>
              
                <li>
                  <a href="#proto.FixedFee"><span class="badge">M</span>FixedFee</a>
                </li>
              
                <li>
                  <a href="#proto.FractionalFee"><span class="badge">M</span>FractionalFee</a>
                </li>
              
                <li>
                  <a href="#proto.RoyaltyFee"><span class="badge">M</span>RoyaltyFee</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#duration.proto">duration.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.Duration"><span class="badge">M</span>Duration</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#ethereum_transaction.proto">ethereum_transaction.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.EthereumTransactionBody"><span class="badge">M</span>EthereumTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#exchange_rate.proto">exchange_rate.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.ExchangeRate"><span class="badge">M</span>ExchangeRate</a>
                </li>
              
                <li>
                  <a href="#proto.ExchangeRateSet"><span class="badge">M</span>ExchangeRateSet</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#file_append.proto">file_append.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.FileAppendTransactionBody"><span class="badge">M</span>FileAppendTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#file_create.proto">file_create.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.FileCreateTransactionBody"><span class="badge">M</span>FileCreateTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#file_delete.proto">file_delete.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.FileDeleteTransactionBody"><span class="badge">M</span>FileDeleteTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#file_get_contents.proto">file_get_contents.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.FileGetContentsQuery"><span class="badge">M</span>FileGetContentsQuery</a>
                </li>
              
                <li>
                  <a href="#proto.FileGetContentsResponse"><span class="badge">M</span>FileGetContentsResponse</a>
                </li>
              
                <li>
                  <a href="#proto.FileGetContentsResponse.FileContents"><span class="badge">M</span>FileGetContentsResponse.FileContents</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#file_get_info.proto">file_get_info.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.FileGetInfoQuery"><span class="badge">M</span>FileGetInfoQuery</a>
                </li>
              
                <li>
                  <a href="#proto.FileGetInfoResponse"><span class="badge">M</span>FileGetInfoResponse</a>
                </li>
              
                <li>
                  <a href="#proto.FileGetInfoResponse.FileInfo"><span class="badge">M</span>FileGetInfoResponse.FileInfo</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#file_service.proto">file_service.proto</a>
            <ul>
              
              
              
              
                <li>
                  <a href="#proto.FileService"><span class="badge">S</span>FileService</a>
                </li>
              
            </ul>
          </li>
        
          
          <li>
            <a href="#file_update.proto">file_update.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.FileUpdateTransactionBody"><span class="badge">M</span>FileUpdateTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#freeze.proto">freeze.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.FreezeTransactionBody"><span class="badge">M</span>FreezeTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#freeze_service.proto">freeze_service.proto</a>
            <ul>
              
              
              
              
                <li>
                  <a href="#proto.FreezeService"><span class="badge">S</span>FreezeService</a>
                </li>
              
            </ul>
          </li>
        
          
          <li>
            <a href="#freeze_type.proto">freeze_type.proto</a>
            <ul>
              
              
                <li>
                  <a href="#proto.FreezeType"><span class="badge">E</span>FreezeType</a>
                </li>
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#get_account_details.proto">get_account_details.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.GetAccountDetailsQuery"><span class="badge">M</span>GetAccountDetailsQuery</a>
                </li>
              
                <li>
                  <a href="#proto.GetAccountDetailsResponse"><span class="badge">M</span>GetAccountDetailsResponse</a>
                </li>
              
                <li>
                  <a href="#proto.GetAccountDetailsResponse.AccountDetails"><span class="badge">M</span>GetAccountDetailsResponse.AccountDetails</a>
                </li>
              
                <li>
                  <a href="#proto.GrantedCryptoAllowance"><span class="badge">M</span>GrantedCryptoAllowance</a>
                </li>
              
                <li>
                  <a href="#proto.GrantedNftAllowance"><span class="badge">M</span>GrantedNftAllowance</a>
                </li>
              
                <li>
                  <a href="#proto.GrantedTokenAllowance"><span class="badge">M</span>GrantedTokenAllowance</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#get_by_key.proto">get_by_key.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.EntityID"><span class="badge">M</span>EntityID</a>
                </li>
              
                <li>
                  <a href="#proto.GetByKeyQuery"><span class="badge">M</span>GetByKeyQuery</a>
                </li>
              
                <li>
                  <a href="#proto.GetByKeyResponse"><span class="badge">M</span>GetByKeyResponse</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#get_by_solidity_id.proto">get_by_solidity_id.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.GetBySolidityIDQuery"><span class="badge">M</span>GetBySolidityIDQuery</a>
                </li>
              
                <li>
                  <a href="#proto.GetBySolidityIDResponse"><span class="badge">M</span>GetBySolidityIDResponse</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#network_get_execution_time.proto">network_get_execution_time.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.NetworkGetExecutionTimeQuery"><span class="badge">M</span>NetworkGetExecutionTimeQuery</a>
                </li>
              
                <li>
                  <a href="#proto.NetworkGetExecutionTimeResponse"><span class="badge">M</span>NetworkGetExecutionTimeResponse</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#network_get_version_info.proto">network_get_version_info.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.NetworkGetVersionInfoQuery"><span class="badge">M</span>NetworkGetVersionInfoQuery</a>
                </li>
              
                <li>
                  <a href="#proto.NetworkGetVersionInfoResponse"><span class="badge">M</span>NetworkGetVersionInfoResponse</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#network_service.proto">network_service.proto</a>
            <ul>
              
              
              
              
                <li>
                  <a href="#proto.NetworkService"><span class="badge">S</span>NetworkService</a>
                </li>
              
            </ul>
          </li>
        
          
          <li>
            <a href="#node_stake_update.proto">node_stake_update.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.NodeStake"><span class="badge">M</span>NodeStake</a>
                </li>
              
                <li>
                  <a href="#proto.NodeStakeUpdateTransactionBody"><span class="badge">M</span>NodeStakeUpdateTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#prng.proto">prng.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.PrngTransactionBody"><span class="badge">M</span>PrngTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#query.proto">query.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.Query"><span class="badge">M</span>Query</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#query_header.proto">query_header.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.QueryHeader"><span class="badge">M</span>QueryHeader</a>
                </li>
              
              
                <li>
                  <a href="#proto.ResponseType"><span class="badge">E</span>ResponseType</a>
                </li>
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#response.proto">response.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.Response"><span class="badge">M</span>Response</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#response_code.proto">response_code.proto</a>
            <ul>
              
              
                <li>
                  <a href="#proto.ResponseCodeEnum"><span class="badge">E</span>ResponseCodeEnum</a>
                </li>
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#response_header.proto">response_header.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.ResponseHeader"><span class="badge">M</span>ResponseHeader</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#schedulable_transaction_body.proto">schedulable_transaction_body.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.SchedulableTransactionBody"><span class="badge">M</span>SchedulableTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#schedule_create.proto">schedule_create.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.ScheduleCreateTransactionBody"><span class="badge">M</span>ScheduleCreateTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#schedule_delete.proto">schedule_delete.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.ScheduleDeleteTransactionBody"><span class="badge">M</span>ScheduleDeleteTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#schedule_get_info.proto">schedule_get_info.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.ScheduleGetInfoQuery"><span class="badge">M</span>ScheduleGetInfoQuery</a>
                </li>
              
                <li>
                  <a href="#proto.ScheduleGetInfoResponse"><span class="badge">M</span>ScheduleGetInfoResponse</a>
                </li>
              
                <li>
                  <a href="#proto.ScheduleInfo"><span class="badge">M</span>ScheduleInfo</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#schedule_service.proto">schedule_service.proto</a>
            <ul>
              
              
              
              
                <li>
                  <a href="#proto.ScheduleService"><span class="badge">S</span>ScheduleService</a>
                </li>
              
            </ul>
          </li>
        
          
          <li>
            <a href="#schedule_sign.proto">schedule_sign.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.ScheduleSignTransactionBody"><span class="badge">M</span>ScheduleSignTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#smart_contract_service.proto">smart_contract_service.proto</a>
            <ul>
              
              
              
              
                <li>
                  <a href="#proto.SmartContractService"><span class="badge">S</span>SmartContractService</a>
                </li>
              
            </ul>
          </li>
        
          
          <li>
            <a href="#system_delete.proto">system_delete.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.SystemDeleteTransactionBody"><span class="badge">M</span>SystemDeleteTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#system_undelete.proto">system_undelete.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.SystemUndeleteTransactionBody"><span class="badge">M</span>SystemUndeleteTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#throttle_definitions.proto">throttle_definitions.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.ThrottleBucket"><span class="badge">M</span>ThrottleBucket</a>
                </li>
              
                <li>
                  <a href="#proto.ThrottleDefinitions"><span class="badge">M</span>ThrottleDefinitions</a>
                </li>
              
                <li>
                  <a href="#proto.ThrottleGroup"><span class="badge">M</span>ThrottleGroup</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#timestamp.proto">timestamp.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.Timestamp"><span class="badge">M</span>Timestamp</a>
                </li>
              
                <li>
                  <a href="#proto.TimestampSeconds"><span class="badge">M</span>TimestampSeconds</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#token_associate.proto">token_associate.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TokenAssociateTransactionBody"><span class="badge">M</span>TokenAssociateTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#token_burn.proto">token_burn.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TokenBurnTransactionBody"><span class="badge">M</span>TokenBurnTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#token_create.proto">token_create.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TokenCreateTransactionBody"><span class="badge">M</span>TokenCreateTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#token_delete.proto">token_delete.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TokenDeleteTransactionBody"><span class="badge">M</span>TokenDeleteTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#token_dissociate.proto">token_dissociate.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TokenDissociateTransactionBody"><span class="badge">M</span>TokenDissociateTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#token_fee_schedule_update.proto">token_fee_schedule_update.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TokenFeeScheduleUpdateTransactionBody"><span class="badge">M</span>TokenFeeScheduleUpdateTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#token_freeze_account.proto">token_freeze_account.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TokenFreezeAccountTransactionBody"><span class="badge">M</span>TokenFreezeAccountTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#token_get_account_nft_infos.proto">token_get_account_nft_infos.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TokenGetAccountNftInfosQuery"><span class="badge">M</span>TokenGetAccountNftInfosQuery</a>
                </li>
              
                <li>
                  <a href="#proto.TokenGetAccountNftInfosResponse"><span class="badge">M</span>TokenGetAccountNftInfosResponse</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#token_get_info.proto">token_get_info.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TokenGetInfoQuery"><span class="badge">M</span>TokenGetInfoQuery</a>
                </li>
              
                <li>
                  <a href="#proto.TokenGetInfoResponse"><span class="badge">M</span>TokenGetInfoResponse</a>
                </li>
              
                <li>
                  <a href="#proto.TokenInfo"><span class="badge">M</span>TokenInfo</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#token_get_nft_info.proto">token_get_nft_info.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.NftID"><span class="badge">M</span>NftID</a>
                </li>
              
                <li>
                  <a href="#proto.TokenGetNftInfoQuery"><span class="badge">M</span>TokenGetNftInfoQuery</a>
                </li>
              
                <li>
                  <a href="#proto.TokenGetNftInfoResponse"><span class="badge">M</span>TokenGetNftInfoResponse</a>
                </li>
              
                <li>
                  <a href="#proto.TokenNftInfo"><span class="badge">M</span>TokenNftInfo</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#token_get_nft_infos.proto">token_get_nft_infos.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TokenGetNftInfosQuery"><span class="badge">M</span>TokenGetNftInfosQuery</a>
                </li>
              
                <li>
                  <a href="#proto.TokenGetNftInfosResponse"><span class="badge">M</span>TokenGetNftInfosResponse</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#token_grant_kyc.proto">token_grant_kyc.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TokenGrantKycTransactionBody"><span class="badge">M</span>TokenGrantKycTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#token_mint.proto">token_mint.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TokenMintTransactionBody"><span class="badge">M</span>TokenMintTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#token_pause.proto">token_pause.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TokenPauseTransactionBody"><span class="badge">M</span>TokenPauseTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#token_revoke_kyc.proto">token_revoke_kyc.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TokenRevokeKycTransactionBody"><span class="badge">M</span>TokenRevokeKycTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#token_service.proto">token_service.proto</a>
            <ul>
              
              
              
              
                <li>
                  <a href="#proto.TokenService"><span class="badge">S</span>TokenService</a>
                </li>
              
            </ul>
          </li>
        
          
          <li>
            <a href="#token_unfreeze_account.proto">token_unfreeze_account.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TokenUnfreezeAccountTransactionBody"><span class="badge">M</span>TokenUnfreezeAccountTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#token_unpause.proto">token_unpause.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TokenUnpauseTransactionBody"><span class="badge">M</span>TokenUnpauseTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#token_update.proto">token_update.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TokenUpdateTransactionBody"><span class="badge">M</span>TokenUpdateTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#token_wipe_account.proto">token_wipe_account.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TokenWipeAccountTransactionBody"><span class="badge">M</span>TokenWipeAccountTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#transaction.proto">transaction.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.Transaction"><span class="badge">M</span>Transaction</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#transaction_body.proto">transaction_body.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TransactionBody"><span class="badge">M</span>TransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#transaction_contents.proto">transaction_contents.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.SignedTransaction"><span class="badge">M</span>SignedTransaction</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#transaction_get_fast_record.proto">transaction_get_fast_record.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TransactionGetFastRecordQuery"><span class="badge">M</span>TransactionGetFastRecordQuery</a>
                </li>
              
                <li>
                  <a href="#proto.TransactionGetFastRecordResponse"><span class="badge">M</span>TransactionGetFastRecordResponse</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#transaction_get_receipt.proto">transaction_get_receipt.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TransactionGetReceiptQuery"><span class="badge">M</span>TransactionGetReceiptQuery</a>
                </li>
              
                <li>
                  <a href="#proto.TransactionGetReceiptResponse"><span class="badge">M</span>TransactionGetReceiptResponse</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#transaction_get_record.proto">transaction_get_record.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TransactionGetRecordQuery"><span class="badge">M</span>TransactionGetRecordQuery</a>
                </li>
              
                <li>
                  <a href="#proto.TransactionGetRecordResponse"><span class="badge">M</span>TransactionGetRecordResponse</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#transaction_receipt.proto">transaction_receipt.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TransactionReceipt"><span class="badge">M</span>TransactionReceipt</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#transaction_record.proto">transaction_record.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TransactionRecord"><span class="badge">M</span>TransactionRecord</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#transaction_response.proto">transaction_response.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.TransactionResponse"><span class="badge">M</span>TransactionResponse</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#unchecked_submit.proto">unchecked_submit.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.UncheckedSubmitBody"><span class="badge">M</span>UncheckedSubmitBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#util_prng.proto">util_prng.proto</a>
            <ul>
              
                <li>
                  <a href="#proto.UtilPrngTransactionBody"><span class="badge">M</span>UtilPrngTransactionBody</a>
                </li>
              
              
              
              
            </ul>
          </li>
        
          
          <li>
            <a href="#util_service.proto">util_service.proto</a>
            <ul>
              
              
              
              
                <li>
                  <a href="#proto.UtilService"><span class="badge">S</span>UtilService</a>
                </li>
              
            </ul>
          </li>
        
        <li><a href="#scalar-value-types">Scalar Value Types</a></li>
      </ul>
    </div>

    
      
      <div class="file-heading">
        <h2 id="basic_types.proto">basic_types.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.AccountAmount">AccountAmount</h3>
        <p>An account, and the amount that it sends or receives during a cryptocurrency or token transfer.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>accountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The Account ID that sends/receives cryptocurrency or tokens </p></td>
                </tr>
              
                <tr>
                  <td>amount</td>
                  <td><a href="#sint64">sint64</a></td>
                  <td></td>
                  <td><p>The amount of tinybars (for Crypto transfers) or in the lowest
denomination (for Token transfers) that the account sends(negative) or
receives(positive) </p></td>
                </tr>
              
                <tr>
                  <td>is_approval</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>If true then the transfer is expected to be an approved allowance and the
accountID is expected to be the owner. The default is false (omitted). </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.AccountID">AccountID</h3>
        <p>The ID for an a cryptocurrency account</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>shardNum</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The shard number (nonnegative) </p></td>
                </tr>
              
                <tr>
                  <td>realmNum</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The realm number (nonnegative) </p></td>
                </tr>
              
                <tr>
                  <td>accountNum</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>A non-negative account number unique within its realm </p></td>
                </tr>
              
                <tr>
                  <td>alias</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The public key bytes to be used as the account&#39;s alias. The public key bytes are the result of serializing
a protobuf Key message for any primitive key type. Currently only primitive key bytes are supported as an alias
(ThresholdKey, KeyList, ContractID, and delegatable_contract_id are not supported)

At most one account can ever have a given alias and it is used for account creation if it
was automatically created using a crypto transfer. It will be null if an account is created normally.
It is immutable once it is set for an account.

If a transaction auto-creates the account, any further transfers to that alias will simply be deposited
in that account, without creating anything, and with no creation fee being charged. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.ContractID">ContractID</h3>
        <p>The ID for a smart contract instance</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>shardNum</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The shard number (nonnegative) </p></td>
                </tr>
              
                <tr>
                  <td>realmNum</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The realm number (nonnegative) </p></td>
                </tr>
              
                <tr>
                  <td>contractNum</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>A nonnegative number unique within a given shard and realm </p></td>
                </tr>
              
                <tr>
                  <td>evm_address</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The 20-byte EVM address of the contract to call. 

Every contract has an EVM address determined by its &lt;tt&gt;shard.realm.num&lt;/tt&gt; id.
This address is as follows:
  &lt;ol&gt;
    &lt;li&gt;The first 4 bytes are the big-endian representation of the shard.&lt;/li&gt;
    &lt;li&gt;The next 8 bytes are the big-endian representation of the realm.&lt;/li&gt;
    &lt;li&gt;The final 8 bytes are the big-endian representation of the number.&lt;/li&gt;
  &lt;/ol&gt;  

Contracts created via CREATE2 have an &lt;b&gt;additional, primary address&lt;/b&gt; that is 
derived from the &lt;a href=&#34;https://eips.ethereum.org/EIPS/eip-1014&#34;&gt;EIP-1014&lt;/a&gt; 
specification, and does not have a simple relation to a &lt;tt&gt;shard.realm.num&lt;/tt&gt; id. 

(Please do note that CREATE2 contracts can also be referenced by the three-part 
EVM address described above.) </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.CurrentAndNextFeeSchedule">CurrentAndNextFeeSchedule</h3>
        <p>This contains two Fee Schedules with expiry timestamp.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>currentFeeSchedule</td>
                  <td><a href="#proto.FeeSchedule">FeeSchedule</a></td>
                  <td></td>
                  <td><p>Contains current Fee Schedule </p></td>
                </tr>
              
                <tr>
                  <td>nextFeeSchedule</td>
                  <td><a href="#proto.FeeSchedule">FeeSchedule</a></td>
                  <td></td>
                  <td><p>Contains next Fee Schedule </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.FeeComponents">FeeComponents</h3>
        <p>A set of prices the nodes use in determining transaction and query fees, and constants involved</p><p>in fee calculations.  Nodes multiply the amount of resources consumed by a transaction or query</p><p>by the corresponding price to calculate the appropriate fee. Units are one-thousandth of a</p><p>tinyCent.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>min</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>A minimum, the calculated fee must be greater than this value </p></td>
                </tr>
              
                <tr>
                  <td>max</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>A maximum, the calculated fee must be less than this value </p></td>
                </tr>
              
                <tr>
                  <td>constant</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>A constant contribution to the fee </p></td>
                </tr>
              
                <tr>
                  <td>bpt</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The price of bandwidth consumed by a transaction, measured in bytes </p></td>
                </tr>
              
                <tr>
                  <td>vpt</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The price per signature verification for a transaction </p></td>
                </tr>
              
                <tr>
                  <td>rbh</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The price of RAM consumed by a transaction, measured in byte-hours </p></td>
                </tr>
              
                <tr>
                  <td>sbh</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The price of storage consumed by a transaction, measured in byte-hours </p></td>
                </tr>
              
                <tr>
                  <td>gas</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The price of computation for a smart contract transaction, measured in gas </p></td>
                </tr>
              
                <tr>
                  <td>tv</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The price per hbar transferred for a transfer </p></td>
                </tr>
              
                <tr>
                  <td>bpr</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The price of bandwidth for data retrieved from memory for a response, measured in bytes </p></td>
                </tr>
              
                <tr>
                  <td>sbpr</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The price of bandwidth for data retrieved from disk for a response, measured in bytes </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.FeeData">FeeData</h3>
        <p>The total fee charged for a transaction. It is composed of three components – a node fee that</p><p>compensates the specific node that submitted the transaction, a network fee that compensates the</p><p>network for assigning the transaction a consensus timestamp, and a service fee that compensates</p><p>the network for the ongoing maintenance of the consequences of the transaction.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>nodedata</td>
                  <td><a href="#proto.FeeComponents">FeeComponents</a></td>
                  <td></td>
                  <td><p>Fee paid to the submitting node </p></td>
                </tr>
              
                <tr>
                  <td>networkdata</td>
                  <td><a href="#proto.FeeComponents">FeeComponents</a></td>
                  <td></td>
                  <td><p>Fee paid to the network for processing a transaction into consensus </p></td>
                </tr>
              
                <tr>
                  <td>servicedata</td>
                  <td><a href="#proto.FeeComponents">FeeComponents</a></td>
                  <td></td>
                  <td><p>Fee paid to the network for providing the service associated with the
transaction; for instance, storing a file </p></td>
                </tr>
              
                <tr>
                  <td>subType</td>
                  <td><a href="#proto.SubType">SubType</a></td>
                  <td></td>
                  <td><p>SubType distinguishing between different types of FeeData, correlating
to the same HederaFunctionality </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.FeeSchedule">FeeSchedule</h3>
        <p>A list of resource prices fee for different transactions and queries and the time period at which</p><p>this fee schedule will expire. Nodes use the prices to determine the fees for all transactions</p><p>based on how much of those resources each transaction uses.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>transactionFeeSchedule</td>
                  <td><a href="#proto.TransactionFeeSchedule">TransactionFeeSchedule</a></td>
                  <td>repeated</td>
                  <td><p>List of price coefficients for network resources </p></td>
                </tr>
              
                <tr>
                  <td>expiryTime</td>
                  <td><a href="#proto.TimestampSeconds">TimestampSeconds</a></td>
                  <td></td>
                  <td><p>FeeSchedule expiry time </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.FileID">FileID</h3>
        <p>The ID for a file</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>shardNum</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The shard number (nonnegative) </p></td>
                </tr>
              
                <tr>
                  <td>realmNum</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The realm number (nonnegative) </p></td>
                </tr>
              
                <tr>
                  <td>fileNum</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>A nonnegative File number unique within its realm </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.Fraction">Fraction</h3>
        <p>A rational number, used to set the amount of a value transfer to collect as a custom fee</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>numerator</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The rational&#39;s numerator </p></td>
                </tr>
              
                <tr>
                  <td>denominator</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The rational&#39;s denominator; a zero value will result in FRACTION_DIVIDES_BY_ZERO </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.Key">Key</h3>
        <p>A Key can be a public key from either the Ed25519 or ECDSA(secp256k1) signature schemes, where</p><p>in the ECDSA(secp256k1) case we require the 33-byte compressed form of the public key. We call</p><p>these public keys <b>primitive keys</b>.</p><p>If an account has primitive key associated to it, then the corresponding private key must sign </p><p>any transaction to transfer cryptocurrency out of it. </p><p>A Key can also be the ID of a smart contract instance, which is then authorized to perform any </p><p>precompiled contract action that requires this key to sign. </p><p>Note that when a Key is a smart contract ID, it <i>doesn't</i> mean the contract with that ID </p><p>will actually create a cryptographic signature. It only means that when the contract calls a </p><p>precompiled contract, the resulting "child transaction" will be authorized to perform any action</p><p>controlled by the Key.</p><p>A Key can be a "threshold key", which means a list of M keys, any N of which must sign in order</p><p>for the threshold signature to be considered valid. The keys within a threshold signature may</p><p>themselves be threshold signatures, to allow complex signature requirements.</p><p>A Key can be a "key list" where all keys in the list must sign unless specified otherwise in the</p><p>documentation for a specific transaction type (e.g.  FileDeleteTransactionBody).  Their use is</p><p>dependent on context. For example, a Hedera file is created with a list of keys, where all of</p><p>them must sign a transaction to create or modify the file, but only one of them is needed to sign</p><p>a transaction to delete the file. So it's a single list that sometimes acts as a 1-of-M threshold</p><p>key, and sometimes acts as an M-of-M threshold key.  A key list is always an M-of-M, unless</p><p>specified otherwise in documentation. A key list can have nested key lists or threshold keys.</p><p>Nested key lists are always M-of-M. A key list can have repeated primitive public keys, but all</p><p>repeated keys are only required to sign once.</p><p>A Key can contain a ThresholdKey or KeyList, which in turn contain a Key, so this mutual</p><p>recursion would allow nesting arbitrarily deep. A ThresholdKey which contains a list of primitive</p><p>keys has 3 levels: ThresholdKey -> KeyList -> Key. A KeyList which contains several primitive</p><p>keys has 2 levels: KeyList -> Key. A Key with 2 levels of nested ThresholdKeys has 7 levels:</p><p>Key -> ThresholdKey -> KeyList -> Key -> ThresholdKey -> KeyList -> Key.</p><p>Each Key should not have more than 46 levels, which implies 15 levels of nested ThresholdKeys.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>contractID</td>
                  <td><a href="#proto.ContractID">ContractID</a></td>
                  <td></td>
                  <td><p>smart contract instance that is authorized as if it had signed with a key </p></td>
                </tr>
              
                <tr>
                  <td>ed25519</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>Ed25519 public key bytes </p></td>
                </tr>
              
                <tr>
                  <td>RSA_3072</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>(NOT SUPPORTED) RSA-3072 public key bytes </p></td>
                </tr>
              
                <tr>
                  <td>ECDSA_384</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>(NOT SUPPORTED) ECDSA with the p-384 curve public key bytes </p></td>
                </tr>
              
                <tr>
                  <td>thresholdKey</td>
                  <td><a href="#proto.ThresholdKey">ThresholdKey</a></td>
                  <td></td>
                  <td><p>a threshold N followed by a list of M keys, any N of which are required to form a valid
signature </p></td>
                </tr>
              
                <tr>
                  <td>keyList</td>
                  <td><a href="#proto.KeyList">KeyList</a></td>
                  <td></td>
                  <td><p>A list of Keys of the Key type. </p></td>
                </tr>
              
                <tr>
                  <td>ECDSA_secp256k1</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>Compressed ECDSA(secp256k1) public key bytes </p></td>
                </tr>
              
                <tr>
                  <td>delegatable_contract_id</td>
                  <td><a href="#proto.ContractID">ContractID</a></td>
                  <td></td>
                  <td><p>A smart contract that, if the recipient of the active message frame, should be treated
as having signed. (Note this does not mean the &lt;i&gt;code being executed in the frame&lt;/i&gt; 
will belong to the given contract, since it could be running another contract&#39;s code via 
&lt;tt&gt;delegatecall&lt;/tt&gt;. So setting this key is a more permissive version of setting the
contractID key, which also requires the code in the active message frame belong to the
the contract with the given id.) </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.KeyList">KeyList</h3>
        <p>A list of keys that requires all keys (M-of-M) to sign unless otherwise specified in</p><p>documentation. A KeyList may contain repeated keys, but all repeated keys are only required to</p><p>sign once.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>keys</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td>repeated</td>
                  <td><p>list of keys </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.NftTransfer">NftTransfer</h3>
        <p>A sender account, a receiver account, and the serial number of an NFT of a Token with</p><p>NON_FUNGIBLE_UNIQUE type. When minting NFTs the sender will be the default AccountID instance</p><p>(0.0.0) and when burning NFTs, the receiver will be the default AccountID instance.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>senderAccountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The accountID of the sender </p></td>
                </tr>
              
                <tr>
                  <td>receiverAccountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The accountID of the receiver </p></td>
                </tr>
              
                <tr>
                  <td>serialNumber</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The serial number of the NFT </p></td>
                </tr>
              
                <tr>
                  <td>is_approval</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>If true then the transfer is expected to be an approved allowance and the
senderAccountID is expected to be the owner. The default is false (omitted). </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.NodeAddress">NodeAddress</h3>
        <p>The data about a node, including its service endpoints and the Hedera account to be paid for</p><p>services provided by the node (that is, queries answered and transactions submitted.)</p><p>If the <tt>serviceEndpoint</tt> list is not set, or empty, then the endpoint given by the</p><p>(deprecated) <tt>ipAddress</tt> and <tt>portno</tt> fields should be used.</p><p>All fields are populated in the 0.0.102 address book file while only fields that start with # are</p><p>populated in the 0.0.101 address book file.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>ipAddress</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> The IP address of the Node with separator &amp; octets encoded in UTF-8.  Usage is deprecated,
ServiceEndpoint is preferred to retrieve a node&#39;s list of IP addresses and ports </p></td>
                </tr>
              
                <tr>
                  <td>portno</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> The port number of the grpc server for the node.  Usage is deprecated, ServiceEndpoint is
preferred to retrieve a node&#39;s list of IP addresses and ports </p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> Usage is deprecated, nodeAccountId is preferred to retrieve a node&#39;s account ID </p></td>
                </tr>
              
                <tr>
                  <td>RSA_PubKey</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The node&#39;s X509 RSA public key used to sign stream files (e.g., record stream 
files). Precisely, this field is a string of hexadecimal characters which, 
translated to binary, are the public key&#39;s DER encoding. </p></td>
                </tr>
              
                <tr>
                  <td>nodeId</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p># A non-sequential identifier for the node </p></td>
                </tr>
              
                <tr>
                  <td>nodeAccountId</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p># The account to be paid for queries and transactions sent to this node </p></td>
                </tr>
              
                <tr>
                  <td>nodeCertHash</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p># Hash of the node&#39;s TLS certificate. Precisely, this field is a string of 
hexadecimal characters which, translated to binary, are the SHA-384 hash of 
the UTF-8 NFKD encoding of the node&#39;s TLS cert in PEM format. Its value can be 
used to verify the node&#39;s certificate it presents during TLS negotiations. </p></td>
                </tr>
              
                <tr>
                  <td>serviceEndpoint</td>
                  <td><a href="#proto.ServiceEndpoint">ServiceEndpoint</a></td>
                  <td>repeated</td>
                  <td><p># A node&#39;s service IP addresses and ports </p></td>
                </tr>
              
                <tr>
                  <td>description</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>A description of the node, with UTF-8 encoding up to 100 bytes </p></td>
                </tr>
              
                <tr>
                  <td>stake</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> [Deprecated] The amount of tinybars staked to the node </p></td>
                </tr>
              
            </tbody>
          </table>

          
            
            
            <h4>Fields with deprecated option</h4>
            <table>
              <thead>
                <tr>
                  <td>Name</td>
                  <td>Option</td>
                </tr>
              </thead>
              <tbody>
              
                <tr>
                  <td>ipAddress</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>portno</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>stake</td>
                  <td><p>true</p></td>
                </tr>
              
              </tbody>
            </table>
            
          

        
      
        <h3 id="proto.NodeAddressBook">NodeAddressBook</h3>
        <p>A list of nodes and their metadata that contains all details of the nodes for the network.  Used</p><p>to parse the contents of system files <tt>0.0.101</tt> and <tt>0.0.102</tt>.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>nodeAddress</td>
                  <td><a href="#proto.NodeAddress">NodeAddress</a></td>
                  <td>repeated</td>
                  <td><p>Metadata of all nodes in the network </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.RealmID">RealmID</h3>
        <p>The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and</p><p>contract instance belongs to exactly one realm.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>shardNum</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The shard number (nonnegative) </p></td>
                </tr>
              
                <tr>
                  <td>realmNum</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The realm number (nonnegative) </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.ScheduleID">ScheduleID</h3>
        <p>Unique identifier for a Schedule</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>shardNum</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>A nonnegative shard number </p></td>
                </tr>
              
                <tr>
                  <td>realmNum</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>A nonnegative realm number </p></td>
                </tr>
              
                <tr>
                  <td>scheduleNum</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>A nonnegative schedule number </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.SemanticVersion">SemanticVersion</h3>
        <p>Hedera follows semantic versioning (https://semver.org/) for both the HAPI protobufs and the</p><p>Services software.  This type allows the <tt>getVersionInfo</tt> query in the</p><p><tt>NetworkService</tt> to return the deployed versions of both protobufs and software on the</p><p>node answering the query.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>major</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p>Increases with incompatible API changes </p></td>
                </tr>
              
                <tr>
                  <td>minor</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p>Increases with backwards-compatible new functionality </p></td>
                </tr>
              
                <tr>
                  <td>patch</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p>Increases with backwards-compatible bug fixes </p></td>
                </tr>
              
                <tr>
                  <td>pre</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>A pre-release version MAY be denoted by appending a hyphen and a series of dot separated
identifiers (https://semver.org/#spec-item-9); so given a semver 0.14.0-alpha.1&#43;21AF26D3,
this field would contain &#39;alpha.1&#39; </p></td>
                </tr>
              
                <tr>
                  <td>build</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>Build metadata MAY be denoted by appending a plus sign and a series of dot separated
identifiers immediately following the patch or pre-release version
(https://semver.org/#spec-item-10); so given a semver 0.14.0-alpha.1&#43;21AF26D3, this field
would contain &#39;21AF26D3&#39; </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.ServiceEndpoint">ServiceEndpoint</h3>
        <p>Contains the IP address and the port representing a service endpoint of a Node in a network. Used</p><p>to reach the Hedera API and submit transactions to the network.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>ipAddressV4</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The 32-bit IPv4 address of the node encoded in left to right order (e.g.  127.0.0.1 has 127
as its first byte) </p></td>
                </tr>
              
                <tr>
                  <td>port</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p>The port of the node </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.ServicesConfigurationList">ServicesConfigurationList</h3>
        <p>UNDOCUMENTED</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>nameValue</td>
                  <td><a href="#proto.Setting">Setting</a></td>
                  <td>repeated</td>
                  <td><p>list of name value pairs of the application properties </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.Setting">Setting</h3>
        <p>UNDOCUMENTED</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>name</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>name of the property </p></td>
                </tr>
              
                <tr>
                  <td>value</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>value of the property </p></td>
                </tr>
              
                <tr>
                  <td>data</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>any data associated with property </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.ShardID">ShardID</h3>
        <p>Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative</p><p>realm number (that number might be reused in other shards). And each account, file, and smart</p><p>contract instance within a given realm has a nonnegative number (which might be reused in other</p><p>realms).  Every account, file, and smart contract instance is within exactly one realm. So a</p><p>FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.</p><p>Each realm maintains a single counter for assigning numbers,  so if there is a file with ID</p><p>0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</p><p>Everything is partitioned into realms so that each Solidity smart contract can  access everything</p><p>in just a single realm, locking all those entities while it's  running, but other smart contracts</p><p>could potentially run in other realms in  parallel. So realms allow Solidity to be parallelized</p><p>somewhat, even though the  language itself assumes everything is serial.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>shardNum</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>the shard number (nonnegative) </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.Signature">Signature</h3>
        <p>This message is <b>DEPRECATED</b> and <b>UNUSABLE</b> with network nodes. It is retained </p><p>here only for historical reasons.</p><p>Please use the SignaturePair and SignatureMap messages.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>contract</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>smart contract virtual signature (always length zero) </p></td>
                </tr>
              
                <tr>
                  <td>ed25519</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>ed25519 signature bytes </p></td>
                </tr>
              
                <tr>
                  <td>RSA_3072</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>RSA-3072 signature bytes </p></td>
                </tr>
              
                <tr>
                  <td>ECDSA_384</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>ECDSA p-384 signature bytes </p></td>
                </tr>
              
                <tr>
                  <td>thresholdSignature</td>
                  <td><a href="#proto.ThresholdSignature">ThresholdSignature</a></td>
                  <td></td>
                  <td><p>A list of signatures for a single N-of-M threshold Key. This must be a list of exactly M
signatures, at least N of which are non-null. </p></td>
                </tr>
              
                <tr>
                  <td>signatureList</td>
                  <td><a href="#proto.SignatureList">SignatureList</a></td>
                  <td></td>
                  <td><p>A list of M signatures, each corresponding to a Key in a KeyList of the same length. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.SignatureList">SignatureList</h3>
        <p>This message is <b>DEPRECATED</b> and <b>UNUSABLE</b> with network nodes. It is retained </p><p>here only for historical reasons.</p><p>Please use the SignaturePair and SignatureMap messages.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>sigs</td>
                  <td><a href="#proto.Signature">Signature</a></td>
                  <td>repeated</td>
                  <td><p>each signature corresponds to a Key in the KeyList </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.SignatureMap">SignatureMap</h3>
        <p>A set of signatures corresponding to every unique public key used to sign a given transaction. If</p><p>one public key matches more than one prefixes on the signature map, the transaction containing</p><p>the map will fail immediately with the response code KEY_PREFIX_MISMATCH.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>sigPair</td>
                  <td><a href="#proto.SignaturePair">SignaturePair</a></td>
                  <td>repeated</td>
                  <td><p>Each signature pair corresponds to a unique Key required to sign the transaction. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.SignaturePair">SignaturePair</h3>
        <p>The client may use any number of bytes from zero to the whole length of the public key for</p><p>pubKeyPrefix. If zero bytes are used, then it must be that only one primitive key is required</p><p>to sign the linked transaction; it will surely resolve to <tt>INVALID_SIGNATURE</tt> otherwise. </p><p><b>IMPORTANT:</b> In the special case that a signature is being provided for a key used to </p><p>authorize a precompiled contract, the <tt>pubKeyPrefix</tt> must contain the <b>entire public </p><p>key</b>! That is, if the key is a Ed25519 key, the <tt>pubKeyPrefix</tt> should be 32 bytes </p><p>long. If the key is a ECDSA(secp256k1) key, the <tt>pubKeyPrefix</tt> should be 33 bytes long, </p><p>since we require the compressed form of the public key. </p><p>Only Ed25519 and ECDSA(secp256k1) keys and hence signatures are currently supported.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>pubKeyPrefix</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>First few bytes of the public key </p></td>
                </tr>
              
                <tr>
                  <td>contract</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>smart contract virtual signature (always length zero) </p></td>
                </tr>
              
                <tr>
                  <td>ed25519</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>ed25519 signature </p></td>
                </tr>
              
                <tr>
                  <td>RSA_3072</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>RSA-3072 signature </p></td>
                </tr>
              
                <tr>
                  <td>ECDSA_384</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>ECDSA p-384 signature </p></td>
                </tr>
              
                <tr>
                  <td>ECDSA_secp256k1</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>ECDSA(secp256k1) signature </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.StakingInfo">StakingInfo</h3>
        <p>Staking metadata for an account or a contract returned in CryptoGetInfo or ContractGetInfo queries</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>decline_reward</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>If true, this account or contract declined to receive a staking reward. </p></td>
                </tr>
              
                <tr>
                  <td>stake_period_start</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>The staking period during which either the staking settings for this account or contract changed (such as starting
staking or changing staked_node_id) or the most recent reward was earned, whichever is later. If this account or contract
is not currently staked to a node, then this field is not set. </p></td>
                </tr>
              
                <tr>
                  <td>pending_reward</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The amount in tinybars that will be received in the next reward situation. </p></td>
                </tr>
              
                <tr>
                  <td>staked_to_me</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The total of balance of all accounts staked to this account or contract. </p></td>
                </tr>
              
                <tr>
                  <td>staked_account_id</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account to which this account or contract is staking. </p></td>
                </tr>
              
                <tr>
                  <td>staked_node_id</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The ID of the node this account or contract is staked to. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.ThresholdKey">ThresholdKey</h3>
        <p>A set of public keys that are used together to form a threshold signature.  If the threshold is N</p><p>and there are M keys, then this is an N of M threshold signature. If an account is associated</p><p>with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list</p><p>of M signatures, where at most M-N of them are blank, and the other at least N of them are valid</p><p>signatures corresponding to at least N of the public keys listed here.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>threshold</td>
                  <td><a href="#uint32">uint32</a></td>
                  <td></td>
                  <td><p>A valid signature set must have at least this many signatures </p></td>
                </tr>
              
                <tr>
                  <td>keys</td>
                  <td><a href="#proto.KeyList">KeyList</a></td>
                  <td></td>
                  <td><p>List of all the keys that can sign </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.ThresholdSignature">ThresholdSignature</h3>
        <p>This message is <b>DEPRECATED</b> and <b>UNUSABLE</b> with network nodes. It is retained </p><p>here only for historical reasons.</p><p>Please use the SignaturePair and SignatureMap messages.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>sigs</td>
                  <td><a href="#proto.SignatureList">SignatureList</a></td>
                  <td></td>
                  <td><p>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be
non-null </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.TokenAssociation">TokenAssociation</h3>
        <p>A token - account association</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>token_id</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The token involved in the association </p></td>
                </tr>
              
                <tr>
                  <td>account_id</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account involved in the association </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.TokenBalance">TokenBalance</h3>
        <p>A number of <i>transferable units</i> of a certain token.</p><p>The transferable unit of a token is its smallest denomination, as given by the token's</p><p><tt>decimals</tt> property---each minted token contains <tt>10<sup>decimals</sup></tt></p><p>transferable units. For example, we could think of the cent as the transferable unit of the US</p><p>dollar (<tt>decimals=2</tt>); and the tinybar as the transferable unit of hbar</p><p>(<tt>decimals=8</tt>).</p><p>Transferable units are not directly comparable across different tokens.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>tokenId</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>A unique token id </p></td>
                </tr>
              
                <tr>
                  <td>balance</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>Number of transferable units of the identified token. For token of type FUNGIBLE_COMMON -
balance in the smallest denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of
NFTs held by the account </p></td>
                </tr>
              
                <tr>
                  <td>decimals</td>
                  <td><a href="#uint32">uint32</a></td>
                  <td></td>
                  <td><p>Tokens divide into &lt;tt&gt;10&lt;sup&gt;decimals&lt;/sup&gt;&lt;/tt&gt; pieces </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.TokenBalances">TokenBalances</h3>
        <p>A sequence of token balances</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>tokenBalances</td>
                  <td><a href="#proto.TokenBalance">TokenBalance</a></td>
                  <td>repeated</td>
                  <td><p> </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.TokenID">TokenID</h3>
        <p>Unique identifier for a token</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>shardNum</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>A nonnegative shard number </p></td>
                </tr>
              
                <tr>
                  <td>realmNum</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>A nonnegative realm number </p></td>
                </tr>
              
                <tr>
                  <td>tokenNum</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>A nonnegative token number </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.TokenRelationship">TokenRelationship</h3>
        <p>Token's information related to the given Account</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>tokenId</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The ID of the token </p></td>
                </tr>
              
                <tr>
                  <td>symbol</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The Symbol of the token </p></td>
                </tr>
              
                <tr>
                  <td>balance</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>For token of type FUNGIBLE_COMMON - the balance that the Account holds in the smallest
denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of NFTs held by the account </p></td>
                </tr>
              
                <tr>
                  <td>kycStatus</td>
                  <td><a href="#proto.TokenKycStatus">TokenKycStatus</a></td>
                  <td></td>
                  <td><p>The KYC status of the account (KycNotApplicable, Granted or Revoked). If the token does not
have KYC key, KycNotApplicable is returned </p></td>
                </tr>
              
                <tr>
                  <td>freezeStatus</td>
                  <td><a href="#proto.TokenFreezeStatus">TokenFreezeStatus</a></td>
                  <td></td>
                  <td><p>The Freeze status of the account (FreezeNotApplicable, Frozen or Unfrozen). If the token does
not have Freeze key, FreezeNotApplicable is returned </p></td>
                </tr>
              
                <tr>
                  <td>decimals</td>
                  <td><a href="#uint32">uint32</a></td>
                  <td></td>
                  <td><p>Tokens divide into &lt;tt&gt;10&lt;sup&gt;decimals&lt;/sup&gt;&lt;/tt&gt; pieces </p></td>
                </tr>
              
                <tr>
                  <td>automatic_association</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>Specifies if the relationship is created implicitly. False : explicitly associated, True :
implicitly associated. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.TokenTransferList">TokenTransferList</h3>
        <p>A list of token IDs and amounts representing the transferred out (negative) or into (positive)</p><p>amounts, represented in the lowest denomination of the token</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>token</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The ID of the token </p></td>
                </tr>
              
                <tr>
                  <td>transfers</td>
                  <td><a href="#proto.AccountAmount">AccountAmount</a></td>
                  <td>repeated</td>
                  <td><p>Applicable to tokens of type FUNGIBLE_COMMON. Multiple list of AccountAmounts, each of which
has an account and amount </p></td>
                </tr>
              
                <tr>
                  <td>nftTransfers</td>
                  <td><a href="#proto.NftTransfer">NftTransfer</a></td>
                  <td>repeated</td>
                  <td><p>Applicable to tokens of type NON_FUNGIBLE_UNIQUE. Multiple list of NftTransfers, each of
which has a sender and receiver account, including the serial number of the NFT </p></td>
                </tr>
              
                <tr>
                  <td>expected_decimals</td>
                  <td><a href="#google.protobuf.UInt32Value">google.protobuf.UInt32Value</a></td>
                  <td></td>
                  <td><p>If present, the number of decimals this fungible token type is expected to have. The transfer
will fail with UNEXPECTED_TOKEN_DECIMALS if the actual decimals differ. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.TopicID">TopicID</h3>
        <p>Unique identifier for a topic (used by the consensus service)</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>shardNum</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The shard number (nonnegative) </p></td>
                </tr>
              
                <tr>
                  <td>realmNum</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The realm number (nonnegative) </p></td>
                </tr>
              
                <tr>
                  <td>topicNum</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>Unique topic identifier within a realm (nonnegative). </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.TransactionFeeSchedule">TransactionFeeSchedule</h3>
        <p>The fees for a specific transaction or query based on the fee data.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>hederaFunctionality</td>
                  <td><a href="#proto.HederaFunctionality">HederaFunctionality</a></td>
                  <td></td>
                  <td><p>A particular transaction or query </p></td>
                </tr>
              
                <tr>
                  <td>feeData</td>
                  <td><a href="#proto.FeeData">FeeData</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> Resource price coefficients </p></td>
                </tr>
              
                <tr>
                  <td>fees</td>
                  <td><a href="#proto.FeeData">FeeData</a></td>
                  <td>repeated</td>
                  <td><p>Resource price coefficients. Supports subtype price definition. </p></td>
                </tr>
              
            </tbody>
          </table>

          
            
            
            <h4>Fields with deprecated option</h4>
            <table>
              <thead>
                <tr>
                  <td>Name</td>
                  <td>Option</td>
                </tr>
              </thead>
              <tbody>
              
                <tr>
                  <td>feeData</td>
                  <td><p>true</p></td>
                </tr>
              
              </tbody>
            </table>
            
          

        
      
        <h3 id="proto.TransactionID">TransactionID</h3>
        <p>The ID for a transaction. This is used for retrieving receipts and records for a transaction, for</p><p>appending to a file right after creating it, for instantiating a smart contract with bytecode in</p><p>a file just created, and internally by the network for detecting when duplicate transactions are</p><p>submitted. A user might get a transaction processed faster by submitting it to N nodes, each with</p><p>a different node account, but all with the same TransactionID. Then, the transaction will take</p><p>effect when the first of all those nodes submits the transaction and it reaches consensus. The</p><p>other transactions will not take effect. So this could make the transaction take effect faster,</p><p>if any given node might be slow. However, the full transaction fee is charged for each</p><p>transaction, so the total fee is N times as much if the transaction is sent to N nodes.</p><p>Applicable to Scheduled Transactions:</p><p>- The ID of a Scheduled Transaction has transactionValidStart and accountIDs inherited from the</p><p>ScheduleCreate transaction that created it. That is to say that they are equal</p><p>- The scheduled property is true for Scheduled Transactions</p><p>- transactionValidStart, accountID and scheduled properties should be omitted</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>transactionValidStart</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>The transaction is invalid if consensusTimestamp &lt; transactionID.transactionStartValid </p></td>
                </tr>
              
                <tr>
                  <td>accountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The Account ID that paid for this transaction </p></td>
                </tr>
              
                <tr>
                  <td>scheduled</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>Whether the Transaction is of type Scheduled or no </p></td>
                </tr>
              
                <tr>
                  <td>nonce</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p>The identifier for an internal transaction that was spawned as part 
of handling a user transaction. (These internal transactions share the 
transactionValidStart and accountID of the user transaction, so a
nonce is necessary to give them a unique TransactionID.)

An example is when a &#34;parent&#34; ContractCreate or ContractCall transaction 
calls one or more HTS precompiled contracts; each of the &#34;child&#34; 
transactions spawned for a precompile has a id with a different nonce. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.TransferList">TransferList</h3>
        <p>A list of accounts and amounts to transfer out of each account (negative) or into it (positive).</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>accountAmounts</td>
                  <td><a href="#proto.AccountAmount">AccountAmount</a></td>
                  <td>repeated</td>
                  <td><p>Multiple list of AccountAmount pairs, each of which has an account and
an amount to transfer into it (positive) or out of it (negative) </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      
        <h3 id="proto.HederaFunctionality">HederaFunctionality</h3>
        <p>The transactions and queries supported by Hedera Hashgraph.</p>
        <table class="enum-table">
          <thead>
            <tr><td>Name</td><td>Number</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>NONE</td>
                <td>0</td>
                <td><p>UNSPECIFIED - Need to keep first value as unspecified because first element is ignored and
not parsed (0 is ignored by parser)</p></td>
              </tr>
            
              <tr>
                <td>CryptoTransfer</td>
                <td>1</td>
                <td><p>crypto transfer</p></td>
              </tr>
            
              <tr>
                <td>CryptoUpdate</td>
                <td>2</td>
                <td><p>crypto update account</p></td>
              </tr>
            
              <tr>
                <td>CryptoDelete</td>
                <td>3</td>
                <td><p>crypto delete account</p></td>
              </tr>
            
              <tr>
                <td>CryptoAddLiveHash</td>
                <td>4</td>
                <td><p>Add a livehash to a crypto account</p></td>
              </tr>
            
              <tr>
                <td>CryptoDeleteLiveHash</td>
                <td>5</td>
                <td><p>Delete a livehash from a crypto account</p></td>
              </tr>
            
              <tr>
                <td>ContractCall</td>
                <td>6</td>
                <td><p>Smart Contract Call</p></td>
              </tr>
            
              <tr>
                <td>ContractCreate</td>
                <td>7</td>
                <td><p>Smart Contract Create Contract</p></td>
              </tr>
            
              <tr>
                <td>ContractUpdate</td>
                <td>8</td>
                <td><p>Smart Contract update contract</p></td>
              </tr>
            
              <tr>
                <td>FileCreate</td>
                <td>9</td>
                <td><p>File Operation create file</p></td>
              </tr>
            
              <tr>
                <td>FileAppend</td>
                <td>10</td>
                <td><p>File Operation append file</p></td>
              </tr>
            
              <tr>
                <td>FileUpdate</td>
                <td>11</td>
                <td><p>File Operation update file</p></td>
              </tr>
            
              <tr>
                <td>FileDelete</td>
                <td>12</td>
                <td><p>File Operation delete file</p></td>
              </tr>
            
              <tr>
                <td>CryptoGetAccountBalance</td>
                <td>13</td>
                <td><p>crypto get account balance</p></td>
              </tr>
            
              <tr>
                <td>CryptoGetAccountRecords</td>
                <td>14</td>
                <td><p>crypto get account record</p></td>
              </tr>
            
              <tr>
                <td>CryptoGetInfo</td>
                <td>15</td>
                <td><p>Crypto get info</p></td>
              </tr>
            
              <tr>
                <td>ContractCallLocal</td>
                <td>16</td>
                <td><p>Smart Contract Call</p></td>
              </tr>
            
              <tr>
                <td>ContractGetInfo</td>
                <td>17</td>
                <td><p>Smart Contract get info</p></td>
              </tr>
            
              <tr>
                <td>ContractGetBytecode</td>
                <td>18</td>
                <td><p>Smart Contract, get the runtime code</p></td>
              </tr>
            
              <tr>
                <td>GetBySolidityID</td>
                <td>19</td>
                <td><p>Smart Contract, get by solidity ID</p></td>
              </tr>
            
              <tr>
                <td>GetByKey</td>
                <td>20</td>
                <td><p>Smart Contract, get by key</p></td>
              </tr>
            
              <tr>
                <td>CryptoGetLiveHash</td>
                <td>21</td>
                <td><p>Get a live hash from a crypto account</p></td>
              </tr>
            
              <tr>
                <td>CryptoGetStakers</td>
                <td>22</td>
                <td><p>Crypto, get the stakers for the node</p></td>
              </tr>
            
              <tr>
                <td>FileGetContents</td>
                <td>23</td>
                <td><p>File Operations get file contents</p></td>
              </tr>
            
              <tr>
                <td>FileGetInfo</td>
                <td>24</td>
                <td><p>File Operations get the info of the file</p></td>
              </tr>
            
              <tr>
                <td>TransactionGetRecord</td>
                <td>25</td>
                <td><p>Crypto get the transaction records</p></td>
              </tr>
            
              <tr>
                <td>ContractGetRecords</td>
                <td>26</td>
                <td><p>Contract get the transaction records</p></td>
              </tr>
            
              <tr>
                <td>CryptoCreate</td>
                <td>27</td>
                <td><p>crypto create account</p></td>
              </tr>
            
              <tr>
                <td>SystemDelete</td>
                <td>28</td>
                <td><p>system delete file</p></td>
              </tr>
            
              <tr>
                <td>SystemUndelete</td>
                <td>29</td>
                <td><p>system undelete file</p></td>
              </tr>
            
              <tr>
                <td>ContractDelete</td>
                <td>30</td>
                <td><p>delete contract</p></td>
              </tr>
            
              <tr>
                <td>Freeze</td>
                <td>31</td>
                <td><p>freeze</p></td>
              </tr>
            
              <tr>
                <td>CreateTransactionRecord</td>
                <td>32</td>
                <td><p>Create Tx Record</p></td>
              </tr>
            
              <tr>
                <td>CryptoAccountAutoRenew</td>
                <td>33</td>
                <td><p>Crypto Auto Renew</p></td>
              </tr>
            
              <tr>
                <td>ContractAutoRenew</td>
                <td>34</td>
                <td><p>Contract Auto Renew</p></td>
              </tr>
            
              <tr>
                <td>GetVersionInfo</td>
                <td>35</td>
                <td><p>Get Version</p></td>
              </tr>
            
              <tr>
                <td>TransactionGetReceipt</td>
                <td>36</td>
                <td><p>Transaction Get Receipt</p></td>
              </tr>
            
              <tr>
                <td>ConsensusCreateTopic</td>
                <td>50</td>
                <td><p>Create Topic</p></td>
              </tr>
            
              <tr>
                <td>ConsensusUpdateTopic</td>
                <td>51</td>
                <td><p>Update Topic</p></td>
              </tr>
            
              <tr>
                <td>ConsensusDeleteTopic</td>
                <td>52</td>
                <td><p>Delete Topic</p></td>
              </tr>
            
              <tr>
                <td>ConsensusGetTopicInfo</td>
                <td>53</td>
                <td><p>Get Topic information</p></td>
              </tr>
            
              <tr>
                <td>ConsensusSubmitMessage</td>
                <td>54</td>
                <td><p>Submit message to topic</p></td>
              </tr>
            
              <tr>
                <td>UncheckedSubmit</td>
                <td>55</td>
                <td><p></p></td>
              </tr>
            
              <tr>
                <td>TokenCreate</td>
                <td>56</td>
                <td><p>Create Token</p></td>
              </tr>
            
              <tr>
                <td>TokenGetInfo</td>
                <td>58</td>
                <td><p>Get Token information</p></td>
              </tr>
            
              <tr>
                <td>TokenFreezeAccount</td>
                <td>59</td>
                <td><p>Freeze Account</p></td>
              </tr>
            
              <tr>
                <td>TokenUnfreezeAccount</td>
                <td>60</td>
                <td><p>Unfreeze Account</p></td>
              </tr>
            
              <tr>
                <td>TokenGrantKycToAccount</td>
                <td>61</td>
                <td><p>Grant KYC to Account</p></td>
              </tr>
            
              <tr>
                <td>TokenRevokeKycFromAccount</td>
                <td>62</td>
                <td><p>Revoke KYC from Account</p></td>
              </tr>
            
              <tr>
                <td>TokenDelete</td>
                <td>63</td>
                <td><p>Delete Token</p></td>
              </tr>
            
              <tr>
                <td>TokenUpdate</td>
                <td>64</td>
                <td><p>Update Token</p></td>
              </tr>
            
              <tr>
                <td>TokenMint</td>
                <td>65</td>
                <td><p>Mint tokens to treasury</p></td>
              </tr>
            
              <tr>
                <td>TokenBurn</td>
                <td>66</td>
                <td><p>Burn tokens from treasury</p></td>
              </tr>
            
              <tr>
                <td>TokenAccountWipe</td>
                <td>67</td>
                <td><p>Wipe token amount from Account holder</p></td>
              </tr>
            
              <tr>
                <td>TokenAssociateToAccount</td>
                <td>68</td>
                <td><p>Associate tokens to an account</p></td>
              </tr>
            
              <tr>
                <td>TokenDissociateFromAccount</td>
                <td>69</td>
                <td><p>Dissociate tokens from an account</p></td>
              </tr>
            
              <tr>
                <td>ScheduleCreate</td>
                <td>70</td>
                <td><p>Create Scheduled Transaction</p></td>
              </tr>
            
              <tr>
                <td>ScheduleDelete</td>
                <td>71</td>
                <td><p>Delete Scheduled Transaction</p></td>
              </tr>
            
              <tr>
                <td>ScheduleSign</td>
                <td>72</td>
                <td><p>Sign Scheduled Transaction</p></td>
              </tr>
            
              <tr>
                <td>ScheduleGetInfo</td>
                <td>73</td>
                <td><p>Get Scheduled Transaction Information</p></td>
              </tr>
            
              <tr>
                <td>TokenGetAccountNftInfos</td>
                <td>74</td>
                <td><p>Get Token Account Nft Information</p></td>
              </tr>
            
              <tr>
                <td>TokenGetNftInfo</td>
                <td>75</td>
                <td><p>Get Token Nft Information</p></td>
              </tr>
            
              <tr>
                <td>TokenGetNftInfos</td>
                <td>76</td>
                <td><p>Get Token Nft List Information</p></td>
              </tr>
            
              <tr>
                <td>TokenFeeScheduleUpdate</td>
                <td>77</td>
                <td><p>Update a token&#39;s custom fee schedule, if permissible</p></td>
              </tr>
            
              <tr>
                <td>NetworkGetExecutionTime</td>
                <td>78</td>
                <td><p>Get execution time(s) by TransactionID, if available</p></td>
              </tr>
            
              <tr>
                <td>TokenPause</td>
                <td>79</td>
                <td><p>Pause the Token</p></td>
              </tr>
            
              <tr>
                <td>TokenUnpause</td>
                <td>80</td>
                <td><p>Unpause the Token</p></td>
              </tr>
            
              <tr>
                <td>CryptoApproveAllowance</td>
                <td>81</td>
                <td><p>Approve allowance for a spender relative to the owner account</p></td>
              </tr>
            
              <tr>
                <td>CryptoDeleteAllowance</td>
                <td>82</td>
                <td><p>Deletes granted allowances on owner account</p></td>
              </tr>
            
              <tr>
                <td>GetAccountDetails</td>
                <td>83</td>
                <td><p>Gets all the information about an account, including balance and allowances. This does not get the list of
account records.</p></td>
              </tr>
            
              <tr>
                <td>EthereumTransaction</td>
                <td>84</td>
                <td><p>Ethereum Transaction</p></td>
              </tr>
            
              <tr>
                <td>NodeStakeUpdate</td>
                <td>85</td>
                <td><p>Updates the staking info at the end of staking period to indicate new staking period has started.</p></td>
              </tr>
            
              <tr>
                <td>UtilPrng</td>
                <td>86</td>
                <td><p>Generates a pseudorandom number.</p></td>
              </tr>
            
          </tbody>
        </table>
      
        <h3 id="proto.SubType">SubType</h3>
        <p>Allows a set of resource prices to be scoped to a certain type of a HAPI operation. </p><p>For example, the resource prices for a TokenMint operation are different between minting fungible</p><p>and non-fungible tokens. This enum allows us to "mark" a set of prices as applying to one or the</p><p>other.</p><p>Similarly, the resource prices for a basic TokenCreate without a custom fee schedule yield a</p><p>total price of $1. The resource prices for a TokenCreate with a custom fee schedule are different</p><p>and yield a total base price of $2.</p>
        <table class="enum-table">
          <thead>
            <tr><td>Name</td><td>Number</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>DEFAULT</td>
                <td>0</td>
                <td><p>The resource prices have no special scope</p></td>
              </tr>
            
              <tr>
                <td>TOKEN_FUNGIBLE_COMMON</td>
                <td>1</td>
                <td><p>The resource prices are scoped to an operation on a fungible common token</p></td>
              </tr>
            
              <tr>
                <td>TOKEN_NON_FUNGIBLE_UNIQUE</td>
                <td>2</td>
                <td><p>The resource prices are scoped to an operation on a non-fungible unique token</p></td>
              </tr>
            
              <tr>
                <td>TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES</td>
                <td>3</td>
                <td><p>The resource prices are scoped to an operation on a fungible common
token with a custom fee schedule</p></td>
              </tr>
            
              <tr>
                <td>TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES</td>
                <td>4</td>
                <td><p>The resource prices are scoped to an operation on a non-fungible unique
token with a custom fee schedule</p></td>
              </tr>
            
              <tr>
                <td>SCHEDULE_CREATE_CONTRACT_CALL</td>
                <td>5</td>
                <td><p>The resource prices are scoped to a ScheduleCreate containing a ContractCall.</p></td>
              </tr>
            
          </tbody>
        </table>
      
        <h3 id="proto.TokenFreezeStatus">TokenFreezeStatus</h3>
        <p>Possible Freeze statuses returned on TokenGetInfoQuery or CryptoGetInfoResponse in</p><p>TokenRelationship</p>
        <table class="enum-table">
          <thead>
            <tr><td>Name</td><td>Number</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>FreezeNotApplicable</td>
                <td>0</td>
                <td><p>UNDOCUMENTED</p></td>
              </tr>
            
              <tr>
                <td>Frozen</td>
                <td>1</td>
                <td><p>UNDOCUMENTED</p></td>
              </tr>
            
              <tr>
                <td>Unfrozen</td>
                <td>2</td>
                <td><p>UNDOCUMENTED</p></td>
              </tr>
            
          </tbody>
        </table>
      
        <h3 id="proto.TokenKycStatus">TokenKycStatus</h3>
        <p>Possible KYC statuses returned on TokenGetInfoQuery or CryptoGetInfoResponse in TokenRelationship</p>
        <table class="enum-table">
          <thead>
            <tr><td>Name</td><td>Number</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>KycNotApplicable</td>
                <td>0</td>
                <td><p>UNDOCUMENTED</p></td>
              </tr>
            
              <tr>
                <td>Granted</td>
                <td>1</td>
                <td><p>UNDOCUMENTED</p></td>
              </tr>
            
              <tr>
                <td>Revoked</td>
                <td>2</td>
                <td><p>UNDOCUMENTED</p></td>
              </tr>
            
          </tbody>
        </table>
      
        <h3 id="proto.TokenPauseStatus">TokenPauseStatus</h3>
        <p>Possible Pause statuses returned on TokenGetInfoQuery</p>
        <table class="enum-table">
          <thead>
            <tr><td>Name</td><td>Number</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>PauseNotApplicable</td>
                <td>0</td>
                <td><p>Indicates that a Token has no pauseKey</p></td>
              </tr>
            
              <tr>
                <td>Paused</td>
                <td>1</td>
                <td><p>Indicates that a Token is Paused</p></td>
              </tr>
            
              <tr>
                <td>Unpaused</td>
                <td>2</td>
                <td><p>Indicates that a Token is Unpaused.</p></td>
              </tr>
            
          </tbody>
        </table>
      
        <h3 id="proto.TokenSupplyType">TokenSupplyType</h3>
        <p>Possible Token Supply Types (IWA Compatibility).</p><p>Indicates how many tokens can have during its lifetime.</p>
        <table class="enum-table">
          <thead>
            <tr><td>Name</td><td>Number</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>INFINITE</td>
                <td>0</td>
                <td><p>Indicates that tokens of that type have an upper bound of Long.MAX_VALUE.</p></td>
              </tr>
            
              <tr>
                <td>FINITE</td>
                <td>1</td>
                <td><p>Indicates that tokens of that type have an upper bound of maxSupply,
provided on token creation.</p></td>
              </tr>
            
          </tbody>
        </table>
      
        <h3 id="proto.TokenType">TokenType</h3>
        <p>Possible Token Types (IWA Compatibility).</p><p>Apart from fungible and non-fungible, Tokens can have either a common or unique representation.</p><p>This distinction might seem subtle, but it is important when considering how tokens can be traced</p><p>and if they can have isolated and unique properties.</p>
        <table class="enum-table">
          <thead>
            <tr><td>Name</td><td>Number</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>FUNGIBLE_COMMON</td>
                <td>0</td>
                <td><p>Interchangeable value with one another, where any quantity of them has the same value as
another equal quantity if they are in the same class.  Share a single set of properties, not
distinct from one another. Simply represented as a balance or quantity to a given Hedera
account.</p></td>
              </tr>
            
              <tr>
                <td>NON_FUNGIBLE_UNIQUE</td>
                <td>1</td>
                <td><p>Unique, not interchangeable with other tokens of the same type as they typically have
different values.  Individually traced and can carry unique properties (e.g. serial number).</p></td>
              </tr>
            
          </tbody>
        </table>
      

      

      
    
      
      <div class="file-heading">
        <h2 id="consensus_create_topic.proto">consensus_create_topic.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.ConsensusCreateTopicTransactionBody">ConsensusCreateTopicTransactionBody</h3>
        <p>See [ConsensusService.createTopic()](#proto.ConsensusService)</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>Short publicly visible memo about the topic. No guarantee of uniqueness. </p></td>
                </tr>
              
                <tr>
                  <td>adminKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>Access control for updateTopic/deleteTopic.
Anyone can increase the topic&#39;s expirationTime via ConsensusService.updateTopic(), regardless of the adminKey.
If no adminKey is specified, updateTopic may only be used to extend the topic&#39;s expirationTime, and deleteTopic
is disallowed. </p></td>
                </tr>
              
                <tr>
                  <td>submitKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>Access control for submitMessage.
If unspecified, no access control is performed on ConsensusService.submitMessage (all submissions are allowed). </p></td>
                </tr>
              
                <tr>
                  <td>autoRenewPeriod</td>
                  <td><a href="#proto.Duration">Duration</a></td>
                  <td></td>
                  <td><p>The initial lifetime of the topic and the amount of time to attempt to extend the topic&#39;s lifetime by
automatically at the topic&#39;s expirationTime, if the autoRenewAccount is configured (once autoRenew functionality
is supported by HAPI).
Limited to MIN_AUTORENEW_PERIOD and MAX_AUTORENEW_PERIOD value by server-side configuration.
Required. </p></td>
                </tr>
              
                <tr>
                  <td>autoRenewAccount</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>Optional account to be used at the topic&#39;s expirationTime to extend the life of the topic (once autoRenew
functionality is supported by HAPI).
The topic lifetime will be extended up to a maximum of the autoRenewPeriod or however long the topic
can be extended using all funds on the account (whichever is the smaller duration/amount and if any extension
is possible with the account&#39;s funds).
If specified, there must be an adminKey and the autoRenewAccount must sign this transaction. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="consensus_delete_topic.proto">consensus_delete_topic.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.ConsensusDeleteTopicTransactionBody">ConsensusDeleteTopicTransactionBody</h3>
        <p>See [ConsensusService.deleteTopic()](#proto.ConsensusService)</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>topicID</td>
                  <td><a href="#proto.TopicID">TopicID</a></td>
                  <td></td>
                  <td><p>Topic identifier </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="consensus_get_topic_info.proto">consensus_get_topic_info.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.ConsensusGetTopicInfoQuery">ConsensusGetTopicInfoQuery</h3>
        <p>See [ConsensusService.getTopicInfo()](#proto.ConsensusService)</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>Standard info sent from client to node, including the signed payment, and what kind of response is requested
(cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>topicID</td>
                  <td><a href="#proto.TopicID">TopicID</a></td>
                  <td></td>
                  <td><p>The Topic for which information is being requested </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.ConsensusGetTopicInfoResponse">ConsensusGetTopicInfoResponse</h3>
        <p>Retrieve the parameters of and state of a consensus topic.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither. </p></td>
                </tr>
              
                <tr>
                  <td>topicID</td>
                  <td><a href="#proto.TopicID">TopicID</a></td>
                  <td></td>
                  <td><p>Topic identifier. </p></td>
                </tr>
              
                <tr>
                  <td>topicInfo</td>
                  <td><a href="#proto.ConsensusTopicInfo">ConsensusTopicInfo</a></td>
                  <td></td>
                  <td><p>Current state of the topic </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="consensus_service.proto">consensus_service.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      

      

      

      
        <h3 id="proto.ConsensusService">ConsensusService</h3>
        <p>The Consensus Service provides the ability for Hedera Hashgraph to provide aBFT consensus as to</p><p>the order and validity of messages submitted to a *topic*, as well as a *consensus timestamp* for</p><p>those messages.</p><p>Automatic renewal can be configured via an autoRenewAccount.</p><p>Any time an autoRenewAccount is added to a topic, that createTopic/updateTopic transaction must</p><p>be signed by the autoRenewAccount.</p><p>The autoRenewPeriod on an account must currently be set a value in createTopic between</p><p>MIN_AUTORENEW_PERIOD (6999999 seconds) and MAX_AUTORENEW_PERIOD (8000001 seconds). During</p><p>creation this sets the initial expirationTime of the topic (see more below).</p><p>If no adminKey is on a topic, there may not be an autoRenewAccount on the topic, deleteTopic is</p><p>not allowed, and the only change allowed via an updateTopic is to extend the expirationTime.</p><p>If an adminKey is on a topic, every updateTopic and deleteTopic transaction must be signed by the</p><p>adminKey, except for updateTopics which only extend the topic's expirationTime (no adminKey</p><p>authorization required).</p><p>If an updateTopic modifies the adminKey of a topic, the transaction signatures on the updateTopic</p><p>must fulfill both the pre-update and post-update adminKey signature requirements.</p><p>Mirrornet ConsensusService may be used to subscribe to changes on the topic, including changes to</p><p>the topic definition and the consensus ordering and timestamp of submitted messages.</p><p>Until autoRenew functionality is supported by HAPI, the topic will not expire, the</p><p>autoRenewAccount will not be charged, and the topic will not automatically be deleted.</p><p>Once autoRenew functionality is supported by HAPI:</p><p>1. Once the expirationTime is encountered, if an autoRenewAccount is configured on the topic, the</p><p>account will be charged automatically at the expirationTime, to extend the expirationTime of the</p><p>topic up to the topic's autoRenewPeriod (or as much extension as the account's balance will</p><p>supply).</p><p>2. If the topic expires and is not automatically renewed, the topic will enter the EXPIRED state.</p><p>All transactions on the topic will fail with TOPIC_EXPIRED, except an updateTopic() call that</p><p>modifies only the expirationTime.  getTopicInfo() will succeed. This state will be available for</p><p>a AUTORENEW_GRACE_PERIOD grace period (7 days).</p><p>3. After the grace period, if the topic's expirationTime is not extended, the topic will be</p><p>automatically deleted and no transactions or queries on the topic will succeed after that point.</p>
        <table class="enum-table">
          <thead>
            <tr><td>Method Name</td><td>Request Type</td><td>Response Type</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>createTopic</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Create a topic to be used for consensus.
If an autoRenewAccount is specified, that account must also sign this transaction.
If an adminKey is specified, the adminKey must sign the transaction.
On success, the resulting TransactionReceipt contains the newly created TopicId.
Request is [ConsensusCreateTopicTransactionBody](#proto.ConsensusCreateTopicTransactionBody)</p></td>
              </tr>
            
              <tr>
                <td>updateTopic</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Update a topic.
If there is no adminKey, the only authorized update (available to anyone) is to extend the expirationTime.
Otherwise transaction must be signed by the adminKey.
If an adminKey is updated, the transaction must be signed by the pre-update adminKey and post-update adminKey.
If a new autoRenewAccount is specified (not just being removed), that account must also sign the transaction.
Request is [ConsensusUpdateTopicTransactionBody](#proto.ConsensusUpdateTopicTransactionBody)</p></td>
              </tr>
            
              <tr>
                <td>deleteTopic</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Delete a topic. No more transactions or queries on the topic (via HAPI) will succeed.
If an adminKey is set, this transaction must be signed by that key.
If there is no adminKey, this transaction will fail UNAUTHORIZED.
Request is [ConsensusDeleteTopicTransactionBody](#proto.ConsensusDeleteTopicTransactionBody)</p></td>
              </tr>
            
              <tr>
                <td>getTopicInfo</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>Retrieve the latest state of a topic. This method is unrestricted and allowed on any topic by any payer account.
Deleted accounts will not be returned.
Request is [ConsensusGetTopicInfoQuery](#proto.ConsensusGetTopicInfoQuery)
Response is [ConsensusGetTopicInfoResponse](#proto.ConsensusGetTopicInfoResponse)</p></td>
              </tr>
            
              <tr>
                <td>submitMessage</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Submit a message for consensus.
Valid and authorized messages on valid topics will be ordered by the consensus service, gossipped to the
mirror net, and published (in order) to all subscribers (from the mirror net) on this topic.
The submitKey (if any) must sign this transaction.
On success, the resulting TransactionReceipt contains the topic&#39;s updated topicSequenceNumber and
topicRunningHash.
Request is [ConsensusSubmitMessageTransactionBody](#proto.ConsensusSubmitMessageTransactionBody)</p></td>
              </tr>
            
          </tbody>
        </table>

        
    
      
      <div class="file-heading">
        <h2 id="consensus_submit_message.proto">consensus_submit_message.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.ConsensusMessageChunkInfo">ConsensusMessageChunkInfo</h3>
        <p>UNDOCUMENTED</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>initialTransactionID</td>
                  <td><a href="#proto.TransactionID">TransactionID</a></td>
                  <td></td>
                  <td><p>TransactionID of the first chunk, gets copied to every subsequent chunk in a fragmented message. </p></td>
                </tr>
              
                <tr>
                  <td>total</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p>The total number of chunks in the message. </p></td>
                </tr>
              
                <tr>
                  <td>number</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p>The sequence number (from 1 to total) of the current chunk in the message. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.ConsensusSubmitMessageTransactionBody">ConsensusSubmitMessageTransactionBody</h3>
        <p>UNDOCUMENTED</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>topicID</td>
                  <td><a href="#proto.TopicID">TopicID</a></td>
                  <td></td>
                  <td><p>Topic to submit message to. </p></td>
                </tr>
              
                <tr>
                  <td>message</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>Message to be submitted. Max size of the Transaction (including signatures) is 6KiB. </p></td>
                </tr>
              
                <tr>
                  <td>chunkInfo</td>
                  <td><a href="#proto.ConsensusMessageChunkInfo">ConsensusMessageChunkInfo</a></td>
                  <td></td>
                  <td><p>Optional information of the current chunk in a fragmented message. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="consensus_topic_info.proto">consensus_topic_info.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.ConsensusTopicInfo">ConsensusTopicInfo</h3>
        <p>Current state of a topic.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The memo associated with the topic (UTF-8 encoding max 100 bytes) </p></td>
                </tr>
              
                <tr>
                  <td>runningHash</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>When a topic is created, its running hash is initialized to 48 bytes of binary zeros.
For each submitted message, the topic&#39;s running hash is then updated to the output
of a particular SHA-384 digest whose input data include the previous running hash.

See the TransactionReceipt.proto documentation for an exact description of the
data included in the SHA-384 digest used for the update. </p></td>
                </tr>
              
                <tr>
                  <td>sequenceNumber</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>Sequence number (starting at 1 for the first submitMessage) of messages on the topic. </p></td>
                </tr>
              
                <tr>
                  <td>expirationTime</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>Effective consensus timestamp at (and after) which submitMessage calls will no longer succeed on the topic
and the topic will expire and after AUTORENEW_GRACE_PERIOD be automatically deleted. </p></td>
                </tr>
              
                <tr>
                  <td>adminKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>Access control for update/delete of the topic. Null if there is no key. </p></td>
                </tr>
              
                <tr>
                  <td>submitKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>Access control for ConsensusService.submitMessage. Null if there is no key. </p></td>
                </tr>
              
                <tr>
                  <td>autoRenewPeriod</td>
                  <td><a href="#proto.Duration">Duration</a></td>
                  <td></td>
                  <td><p>If an auto-renew account is specified, when the topic expires, its lifetime will be extended
by up to this duration (depending on the solvency of the auto-renew account). If the
auto-renew account has no funds at all, the topic will be deleted instead. </p></td>
                </tr>
              
                <tr>
                  <td>autoRenewAccount</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account, if any, to charge for automatic renewal of the topic&#39;s lifetime upon expiry. </p></td>
                </tr>
              
                <tr>
                  <td>ledger_id</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The ledger ID the response was returned from; please see &lt;a href=&#34;https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md&#34;&gt;HIP-198&lt;/a&gt; for the network-specific IDs. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="consensus_update_topic.proto">consensus_update_topic.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.ConsensusUpdateTopicTransactionBody">ConsensusUpdateTopicTransactionBody</h3>
        <p>All fields left null will not be updated.</p><p>See [ConsensusService.updateTopic()](#proto.ConsensusService)</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>topicID</td>
                  <td><a href="#proto.TopicID">TopicID</a></td>
                  <td></td>
                  <td><p>UNDOCUMENTED </p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#google.protobuf.StringValue">google.protobuf.StringValue</a></td>
                  <td></td>
                  <td><p>If set, the new memo to be associated with the topic (UTF-8 encoding max 100 bytes) </p></td>
                </tr>
              
                <tr>
                  <td>expirationTime</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>Effective consensus timestamp at (and after) which all consensus transactions and queries will fail.
The expirationTime may be no longer than MAX_AUTORENEW_PERIOD (8000001 seconds) from the consensus timestamp of
this transaction.
On topics with no adminKey, extending the expirationTime is the only updateTopic option allowed on the topic.
If unspecified, no change. </p></td>
                </tr>
              
                <tr>
                  <td>adminKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>Access control for update/delete of the topic.
If unspecified, no change.
If empty keyList - the adminKey is cleared. </p></td>
                </tr>
              
                <tr>
                  <td>submitKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>Access control for ConsensusService.submitMessage.
If unspecified, no change.
If empty keyList - the submitKey is cleared. </p></td>
                </tr>
              
                <tr>
                  <td>autoRenewPeriod</td>
                  <td><a href="#proto.Duration">Duration</a></td>
                  <td></td>
                  <td><p>The amount of time to extend the topic&#39;s lifetime automatically at expirationTime if the autoRenewAccount is
configured and has funds (once autoRenew functionality is supported by HAPI).
Limited to between MIN_AUTORENEW_PERIOD (6999999 seconds) and MAX_AUTORENEW_PERIOD (8000001 seconds) by
servers-side configuration (which may change).
If unspecified, no change. </p></td>
                </tr>
              
                <tr>
                  <td>autoRenewAccount</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>Optional account to be used at the topic&#39;s expirationTime to extend the life of the topic.
Once autoRenew functionality is supported by HAPI, the topic lifetime will be extended up to a maximum of the
autoRenewPeriod or however long the topic can be extended using all funds on the account (whichever is the
smaller duration/amount).
If specified as the default value (0.0.0), the autoRenewAccount will be removed.
If unspecified, no change. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="contract_call.proto">contract_call.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.ContractCallTransactionBody">ContractCallTransactionBody</h3>
        <p>Call a function of the given smart contract instance, giving it functionParameters as its inputs.</p><p>The call can use at maximum the given amount of gas – the paying account will not be charged for</p><p>any unspent gas.</p><p>If this function results in data being stored, an amount of gas is calculated that reflects this</p><p>storage burden.</p><p>The amount of gas used, as well as other attributes of the transaction, e.g. size, number of</p><p>signatures to be verified, determine the fee for the transaction – which is charged to the paying</p><p>account.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>contractID</td>
                  <td><a href="#proto.ContractID">ContractID</a></td>
                  <td></td>
                  <td><p>The contract to call </p></td>
                </tr>
              
                <tr>
                  <td>gas</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>the maximum amount of gas to use for the call </p></td>
                </tr>
              
                <tr>
                  <td>amount</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>number of tinybars sent (the function must be payable if this is nonzero) </p></td>
                </tr>
              
                <tr>
                  <td>functionParameters</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>which function to call, and the parameters to pass to the function </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="contract_call_local.proto">contract_call_local.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.ContractCallLocalQuery">ContractCallLocalQuery</h3>
        <p>Call a function of the given smart contract instance, giving it functionParameters as its inputs.</p><p>This is performed locally on the particular node that the client is communicating with.</p><p>It cannot change the state of the contract instance (and so, cannot spend anything from the instance's cryptocurrency account).</p><p>It will not have a consensus timestamp. It cannot generate a record or a receipt. The response will contain the output</p><p>returned by the function call.  This is useful for calling getter functions, which purely read the state and don't change it.</p><p>It is faster and cheaper than a normal call, because it is purely local to a single  node.</p><p>Unlike a ContractCall transaction, the node will consume the entire amount of provided gas in determining</p><p>the fee for this query.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither). The payment must cover the fees and all of the gas offered. </p></td>
                </tr>
              
                <tr>
                  <td>contractID</td>
                  <td><a href="#proto.ContractID">ContractID</a></td>
                  <td></td>
                  <td><p>The contract to make a static call against </p></td>
                </tr>
              
                <tr>
                  <td>gas</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The amount of gas to use for the call; all of the gas offered will be used and charged a corresponding fee </p></td>
                </tr>
              
                <tr>
                  <td>functionParameters</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>which function to call, and the parameters to pass to the function </p></td>
                </tr>
              
                <tr>
                  <td>maxResultSize</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> max number of bytes that the result might include. The run will fail if it would have returned more than this number of bytes. </p></td>
                </tr>
              
                <tr>
                  <td>sender_id</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account that is the &#34;sender.&#34; If not present it is the accountId from the transactionId.
Typically a different value than specified in the transactionId requires a valid signature 
over either the hedera transaction or foreign transaction data. </p></td>
                </tr>
              
            </tbody>
          </table>

          
            
            
            <h4>Fields with deprecated option</h4>
            <table>
              <thead>
                <tr>
                  <td>Name</td>
                  <td>Option</td>
                </tr>
              </thead>
              <tbody>
              
                <tr>
                  <td>maxResultSize</td>
                  <td><p>true</p></td>
                </tr>
              
              </tbody>
            </table>
            
          

        
      
        <h3 id="proto.ContractCallLocalResponse">ContractCallLocalResponse</h3>
        <p>Response when the client sends the node ContractCallLocalQuery</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>functionResult</td>
                  <td><a href="#proto.ContractFunctionResult">ContractFunctionResult</a></td>
                  <td></td>
                  <td><p>the value returned by the function (if it completed and didn&#39;t fail) </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.ContractFunctionResult">ContractFunctionResult</h3>
        <p>The result returned by a call to a smart contract function. This is part of the response to a</p><p>ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance</p><p>transaction. The ContractCreateInstance transaction record has the results of the call to the</p><p>constructor.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>contractID</td>
                  <td><a href="#proto.ContractID">ContractID</a></td>
                  <td></td>
                  <td><p>the smart contract instance whose function was called </p></td>
                </tr>
              
                <tr>
                  <td>contractCallResult</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>the result returned by the function </p></td>
                </tr>
              
                <tr>
                  <td>errorMessage</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>message In case there was an error during smart contract execution </p></td>
                </tr>
              
                <tr>
                  <td>bloom</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>bloom filter for record </p></td>
                </tr>
              
                <tr>
                  <td>gasUsed</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>units of gas used to execute contract </p></td>
                </tr>
              
                <tr>
                  <td>logInfo</td>
                  <td><a href="#proto.ContractLoginfo">ContractLoginfo</a></td>
                  <td>repeated</td>
                  <td><p>the log info for events returned by the function </p></td>
                </tr>
              
                <tr>
                  <td>createdContractIDs</td>
                  <td><a href="#proto.ContractID">ContractID</a></td>
                  <td>repeated</td>
                  <td><p><strong>Deprecated.</strong> [DEPRECATED] the list of smart contracts that were created by the function call.

The created ids will now _also_ be externalized through internal transaction 
records, where each record has its alias field populated with the new contract&#39;s 
EVM address. (This is needed for contracts created with CREATE2, since 
there is no longer a simple relationship between the new contract&#39;s 0.0.X id 
and its Solidity address.) </p></td>
                </tr>
              
                <tr>
                  <td>evm_address</td>
                  <td><a href="#google.protobuf.BytesValue">google.protobuf.BytesValue</a></td>
                  <td></td>
                  <td><p>The new contract&#39;s 20-byte EVM address. Only populated after release 0.23, 
where each created contract will have its own record. (This is an important 
point--the field is not &lt;tt&gt;repeated&lt;/tt&gt; because there will be a separate 
child record for each created contract.)

Every contract has an EVM address determined by its &lt;tt&gt;shard.realm.num&lt;/tt&gt; id.
This address is as follows:
  &lt;ol&gt;
    &lt;li&gt;The first 4 bytes are the big-endian representation of the shard.&lt;/li&gt;
    &lt;li&gt;The next 8 bytes are the big-endian representation of the realm.&lt;/li&gt;
    &lt;li&gt;The final 8 bytes are the big-endian representation of the number.&lt;/li&gt;
  &lt;/ol&gt;  

Contracts created via CREATE2 have an &lt;b&gt;additional, primary address&lt;/b&gt; that is 
derived from the &lt;a href=&#34;https://eips.ethereum.org/EIPS/eip-1014&#34;&gt;EIP-1014&lt;/a&gt; 
specification, and does not have a simple relation to a &lt;tt&gt;shard.realm.num&lt;/tt&gt; id. 

(Please do note that CREATE2 contracts can also be referenced by the three-part 
EVM address described above.) </p></td>
                </tr>
              
                <tr>
                  <td>gas</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The amount of gas available for the call, aka the gasLimit. 

This field should only be populated when the paired TransactionBody in the record stream is not a
ContractCreateTransactionBody or a ContractCallTransactionBody. </p></td>
                </tr>
              
                <tr>
                  <td>amount</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>Number of tinybars sent (the function must be payable if this is nonzero).

This field should only be populated when the paired TransactionBody in the record stream is not a
ContractCreateTransactionBody or a ContractCallTransactionBody. </p></td>
                </tr>
              
                <tr>
                  <td>functionParameters</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The parameters passed into the contract call.

This field should only be populated when the paired TransactionBody in the record stream is not a
ContractCreateTransactionBody or a ContractCallTransactionBody. </p></td>
                </tr>
              
                <tr>
                  <td>sender_id</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account that is the &#34;sender.&#34; If not present it is the accountId from the transactionId.

This field should only be populated when the paired TransactionBody in the record stream is not a
ContractCreateTransactionBody or a ContractCallTransactionBody. </p></td>
                </tr>
              
            </tbody>
          </table>

          
            
            
            <h4>Fields with deprecated option</h4>
            <table>
              <thead>
                <tr>
                  <td>Name</td>
                  <td>Option</td>
                </tr>
              </thead>
              <tbody>
              
                <tr>
                  <td>createdContractIDs</td>
                  <td><p>true</p></td>
                </tr>
              
              </tbody>
            </table>
            
          

        
      
        <h3 id="proto.ContractLoginfo">ContractLoginfo</h3>
        <p>The log information for an event returned by a smart contract function call. One function call</p><p>may return several such events.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>contractID</td>
                  <td><a href="#proto.ContractID">ContractID</a></td>
                  <td></td>
                  <td><p>address of a contract that emitted the event </p></td>
                </tr>
              
                <tr>
                  <td>bloom</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>bloom filter for a particular log </p></td>
                </tr>
              
                <tr>
                  <td>topic</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td>repeated</td>
                  <td><p>topics of a particular event </p></td>
                </tr>
              
                <tr>
                  <td>data</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>event data </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="contract_create.proto">contract_create.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.ContractCreateTransactionBody">ContractCreateTransactionBody</h3>
        <p>Start a new smart contract instance. After the instance is created, the ContractID for it is in</p><p>the receipt, and can be retrieved by the Record or with a GetByKey query. The instance will run</p><p>the bytecode, either stored in a previously created file or in the transaction body itself for </p><p>small contracts.</p><p>The constructor will be executed using the given amount of gas, and any unspent gas will be</p><p>refunded to the paying account. Constructor inputs come from the given constructorParameters.</p><p>- The instance will exist for autoRenewPeriod seconds. When that is reached, it will renew</p><p>itself for another autoRenewPeriod seconds by charging its associated cryptocurrency account</p><p>(which it creates here). If it has insufficient cryptocurrency to extend that long, it will</p><p>extend as long as it can. If its balance is zero, the instance will be deleted.</p><p>- A smart contract instance normally enforces rules, so "the code is law". For example, an</p><p>ERC-20 contract prevents a transfer from being undone without a signature by the recipient of</p><p>the transfer. This is always enforced if the contract instance was created with the adminKeys</p><p>being null. But for some uses, it might be desirable to create something like an ERC-20</p><p>contract that has a specific group of trusted individuals who can act as a "supreme court"</p><p>with the ability to override the normal operation, when a sufficient number of them agree to</p><p>do so. If adminKeys is not null, then they can sign a transaction that can change the state of</p><p>the smart contract in arbitrary ways, such as to reverse a transaction that violates some</p><p>standard of behavior that is not covered by the code itself. The admin keys can also be used</p><p>to change the autoRenewPeriod, and change the adminKeys field itself. The API currently does</p><p>not implement this ability. But it does allow the adminKeys field to be set and queried, and</p><p>will in the future implement such admin abilities for any instance that has a non-null</p><p>adminKeys.</p><p>- If this constructor stores information, it is charged gas to store it. There is a fee in hbars</p><p>to maintain that storage until the expiration time, and that fee is added as part of the</p><p>transaction fee.</p><p>- An entity (account, file, or smart contract instance) must be created in a particular realm.</p><p>If the realmID is left null, then a new realm will be created with the given admin key. If a</p><p>new realm has a null adminKey, then anyone can create/modify/delete entities in that realm.</p><p>But if an admin key is given, then any transaction to create/modify/delete an entity in that</p><p>realm must be signed by that key, though anyone can still call functions on smart contract</p><p>instances that exist in that realm. A realm ceases to exist when everything within it has</p><p>expired and no longer exists.</p><p>- The current API ignores shardID, realmID, and newRealmAdminKey, and creates everything in</p><p>shard 0 and realm 0, with a null key. Future versions of the API will support multiple realms</p><p>and multiple shards.</p><p>- The optional memo field can contain a string whose length is up to 100 bytes. That is the size</p><p>after Unicode NFD then UTF-8 conversion. This field can be used to describe the smart contract.</p><p>It could also be used for other purposes. One recommended purpose is to hold a hexadecimal</p><p>string that is the SHA-384 hash of a PDF file containing a human-readable legal contract. Then,</p><p>if the admin keys are the public keys of human arbitrators, they can use that legal document to</p><p>guide their decisions during a binding arbitration tribunal, convened to consider any changes</p><p>to the smart contract in the future. The memo field can only be changed using the admin keys.</p><p>If there are no admin keys, then it cannot be changed after the smart contract is created.</p><p><b>Signing requirements:</b> If an admin key is set, it must sign the transaction. If an </p><p>auto-renew account is set, its key must sign the transaction.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>fileID</td>
                  <td><a href="#proto.FileID">FileID</a></td>
                  <td></td>
                  <td><p>The file containing the smart contract initcode. A copy will be made and held by the
contract instance, and have the same expiration time as the instance. </p></td>
                </tr>
              
                <tr>
                  <td>initcode</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The bytes of the smart contract initcode. This is only useful if the smart contract init
is less than the hedera transaction limit. In those cases fileID must be used. </p></td>
                </tr>
              
                <tr>
                  <td>adminKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>the state of the instance and its fields can be modified arbitrarily if this key signs a
transaction to modify it. If this is null, then such modifications are not possible, and
there is no administrator that can override the normal operation of this smart contract
instance. Note that if it is created with no admin keys, then there is no administrator to
authorize changing the admin keys, so there can never be any admin keys for that instance. </p></td>
                </tr>
              
                <tr>
                  <td>gas</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>gas to run the constructor </p></td>
                </tr>
              
                <tr>
                  <td>initialBalance</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>initial number of tinybars to put into the cryptocurrency account associated with and owned
by the smart contract </p></td>
                </tr>
              
                <tr>
                  <td>proxyAccountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> [Deprecated] ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an
invalid account, or is an account that isn&#39;t a node, then this account is automatically proxy
staked to a node chosen by the network, but without earning payments. If the proxyAccountID
account refuses to accept proxy staking , or if it is not currently running a node, then it
will behave as if  proxyAccountID was null. </p></td>
                </tr>
              
                <tr>
                  <td>autoRenewPeriod</td>
                  <td><a href="#proto.Duration">Duration</a></td>
                  <td></td>
                  <td><p>the instance will charge its account every this many seconds to renew for this long </p></td>
                </tr>
              
                <tr>
                  <td>constructorParameters</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>parameters to pass to the constructor </p></td>
                </tr>
              
                <tr>
                  <td>shardID</td>
                  <td><a href="#proto.ShardID">ShardID</a></td>
                  <td></td>
                  <td><p>shard in which to create this </p></td>
                </tr>
              
                <tr>
                  <td>realmID</td>
                  <td><a href="#proto.RealmID">RealmID</a></td>
                  <td></td>
                  <td><p>realm in which to create this (leave this null to create a new realm) </p></td>
                </tr>
              
                <tr>
                  <td>newRealmAdminKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>if realmID is null, then this the admin key for the new realm that will be created </p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>the memo that was submitted as part of the contract (max 100 bytes) </p></td>
                </tr>
              
                <tr>
                  <td>max_automatic_token_associations</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p>The maximum number of tokens that this contract can be automatically associated
with (i.e., receive air-drops from). </p></td>
                </tr>
              
                <tr>
                  <td>auto_renew_account_id</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>An account to charge for auto-renewal of this contract. If not set, or set to an
account with zero hbar balance, the contract&#39;s own hbar balance will be used to
cover auto-renewal fees. </p></td>
                </tr>
              
                <tr>
                  <td>staked_account_id</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>ID of the account to which this contract is staking. </p></td>
                </tr>
              
                <tr>
                  <td>staked_node_id</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>ID of the node this contract is staked to. </p></td>
                </tr>
              
                <tr>
                  <td>decline_reward</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>If true, the contract declines receiving a staking reward. The default value is false. </p></td>
                </tr>
              
            </tbody>
          </table>

          
            
            
            <h4>Fields with deprecated option</h4>
            <table>
              <thead>
                <tr>
                  <td>Name</td>
                  <td>Option</td>
                </tr>
              </thead>
              <tbody>
              
                <tr>
                  <td>proxyAccountID</td>
                  <td><p>true</p></td>
                </tr>
              
              </tbody>
            </table>
            
          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="contract_delete.proto">contract_delete.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.ContractDeleteTransactionBody">ContractDeleteTransactionBody</h3>
        <p>At consensus, marks a contract as deleted and transfers its remaining hBars, if any, to a</p><p>designated receiver. After a contract is deleted, it can no longer be called.</p><p>If the target contract is immutable (that is, was created without an admin key), then this</p><p>transaction resolves to MODIFYING_IMMUTABLE_CONTRACT.</p><p>--- Signing Requirements ---</p><p>1. The admin key of the target contract must sign.</p><p>2. If the transfer account or contract has receiverSigRequired, its associated key must also sign</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>contractID</td>
                  <td><a href="#proto.ContractID">ContractID</a></td>
                  <td></td>
                  <td><p>The id of the contract to be deleted </p></td>
                </tr>
              
                <tr>
                  <td>transferAccountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The id of an account to receive any remaining hBars from the deleted contract </p></td>
                </tr>
              
                <tr>
                  <td>transferContractID</td>
                  <td><a href="#proto.ContractID">ContractID</a></td>
                  <td></td>
                  <td><p>The id of a contract to receive any remaining hBars from the deleted contract </p></td>
                </tr>
              
                <tr>
                  <td>permanent_removal</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>If set to true, means this is a &#34;synthetic&#34; system transaction being used to 
alert mirror nodes that the contract is being permanently removed from the ledger.
&lt;b&gt;IMPORTANT:&lt;/b&gt; User transactions cannot set this field to true, as permanent
removal is always managed by the ledger itself. Any ContractDeleteTransactionBody
submitted to HAPI with permanent_removal=true will be rejected with precheck status
PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="contract_get_bytecode.proto">contract_get_bytecode.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.ContractGetBytecodeQuery">ContractGetBytecodeQuery</h3>
        <p>Get the runtime bytecode for a smart contract instance</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>standard info sent from client to node, including the signed payment, and what kind of
response is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>contractID</td>
                  <td><a href="#proto.ContractID">ContractID</a></td>
                  <td></td>
                  <td><p>the contract for which information is requested </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.ContractGetBytecodeResponse">ContractGetBytecodeResponse</h3>
        <p>Response when the client sends the node ContractGetBytecodeQuery</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>standard response from node to client, including the requested fields: cost, or state proof,
or both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>bytecode</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>the runtime bytecode of the contract </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="contract_get_info.proto">contract_get_info.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.ContractGetInfoQuery">ContractGetInfoQuery</h3>
        <p>Get information about a smart contract instance. This includes the account that it uses, the file</p><p>containing its initcode (if a file was used to initialize the contract), and the time when it will expire.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>standard info sent from client to node, including the signed payment, and what kind of
response is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>contractID</td>
                  <td><a href="#proto.ContractID">ContractID</a></td>
                  <td></td>
                  <td><p>the contract for which information is requested </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.ContractGetInfoResponse">ContractGetInfoResponse</h3>
        <p>Response when the client sends the node ContractGetInfoQuery</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>standard response from node to client, including the requested fields: cost, or state proof,
or both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>contractInfo</td>
                  <td><a href="#proto.ContractGetInfoResponse.ContractInfo">ContractGetInfoResponse.ContractInfo</a></td>
                  <td></td>
                  <td><p>the information about this contract instance (a state proof can be generated for this) </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.ContractGetInfoResponse.ContractInfo">ContractGetInfoResponse.ContractInfo</h3>
        <p></p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>contractID</td>
                  <td><a href="#proto.ContractID">ContractID</a></td>
                  <td></td>
                  <td><p>ID of the contract instance, in the format used in transactions </p></td>
                </tr>
              
                <tr>
                  <td>accountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>ID of the cryptocurrency account owned by the contract instance, in the format used in
transactions </p></td>
                </tr>
              
                <tr>
                  <td>contractAccountID</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>ID of both the contract instance and the cryptocurrency account owned by the contract
instance, in the format used by Solidity </p></td>
                </tr>
              
                <tr>
                  <td>adminKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>the state of the instance and its fields can be modified arbitrarily if this key signs a
transaction to modify it. If this is null, then such modifications are not possible, and
there is no administrator that can override the normal operation of this smart contract
instance. Note that if it is created with no admin keys, then there is no administrator
to authorize changing the admin keys, so there can never be any admin keys for that
instance. </p></td>
                </tr>
              
                <tr>
                  <td>expirationTime</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>the current time at which this contract instance (and its account) is set to expire </p></td>
                </tr>
              
                <tr>
                  <td>autoRenewPeriod</td>
                  <td><a href="#proto.Duration">Duration</a></td>
                  <td></td>
                  <td><p>the expiration time will extend every this many seconds. If there are insufficient funds,
then it extends as long as possible. If the account is empty when it expires, then it is
deleted. </p></td>
                </tr>
              
                <tr>
                  <td>storage</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>number of bytes of storage being used by this instance (which affects the cost to extend
the expiration time) </p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>the memo associated with the contract (max 100 bytes) </p></td>
                </tr>
              
                <tr>
                  <td>balance</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>The current balance, in tinybars </p></td>
                </tr>
              
                <tr>
                  <td>deleted</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>Whether the contract has been deleted </p></td>
                </tr>
              
                <tr>
                  <td>tokenRelationships</td>
                  <td><a href="#proto.TokenRelationship">TokenRelationship</a></td>
                  <td>repeated</td>
                  <td><p><strong>Deprecated.</strong> [DEPRECATED] The metadata of the tokens associated to the contract. This field was 
deprecated by &lt;a href=&#34;https://hips.hedera.com/hip/hip-367&#34;&gt;HIP-367&lt;/a&gt;, which allowed 
an account to be associated to an unlimited number of tokens. This scale makes it more 
efficient for users to consult mirror nodes to review their token associations. </p></td>
                </tr>
              
                <tr>
                  <td>ledger_id</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The ledger ID the response was returned from; please see &lt;a href=&#34;https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md&#34;&gt;HIP-198&lt;/a&gt; for the network-specific IDs. </p></td>
                </tr>
              
                <tr>
                  <td>auto_renew_account_id</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>ID of the an account to charge for auto-renewal of this contract. If not set, or set to an account with zero hbar
balance, the contract&#39;s own hbar balance will be used to cover auto-renewal fees. </p></td>
                </tr>
              
                <tr>
                  <td>max_automatic_token_associations</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p>The maximum number of tokens that a contract can be implicitly associated with. </p></td>
                </tr>
              
                <tr>
                  <td>staking_info</td>
                  <td><a href="#proto.StakingInfo">StakingInfo</a></td>
                  <td></td>
                  <td><p>Staking metadata for this contract. </p></td>
                </tr>
              
            </tbody>
          </table>

          
            
            
            <h4>Fields with deprecated option</h4>
            <table>
              <thead>
                <tr>
                  <td>Name</td>
                  <td>Option</td>
                </tr>
              </thead>
              <tbody>
              
                <tr>
                  <td>tokenRelationships</td>
                  <td><p>true</p></td>
                </tr>
              
              </tbody>
            </table>
            
          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="contract_get_records.proto">contract_get_records.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.ContractGetRecordsQuery">ContractGetRecordsQuery</h3>
        <p>Before v0.9.0, requested records of all transactions against the given contract in the last 25 hours.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>contractID</td>
                  <td><a href="#proto.ContractID">ContractID</a></td>
                  <td></td>
                  <td><p>The smart contract instance for which the records should be retrieved </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.ContractGetRecordsResponse">ContractGetRecordsResponse</h3>
        <p>Before v0.9.0, returned records of all transactions against the given contract in the last 25 hours.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>contractID</td>
                  <td><a href="#proto.ContractID">ContractID</a></td>
                  <td></td>
                  <td><p>The smart contract instance that this record is for </p></td>
                </tr>
              
                <tr>
                  <td>records</td>
                  <td><a href="#proto.TransactionRecord">TransactionRecord</a></td>
                  <td>repeated</td>
                  <td><p>List of records, each with contractCreateResult or contractCallResult as its body </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="contract_update.proto">contract_update.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.ContractUpdateTransactionBody">ContractUpdateTransactionBody</h3>
        <p>At consensus, updates the fields of a smart contract to the given values.</p><p>If no value is given for a field, that field is left unchanged on the contract. For an immutable</p><p>smart contract (that is, a contract created without an adminKey), only the expirationTime may be</p><p>updated; setting any other field in this case will cause the transaction status to resolve to</p><p>MODIFYING_IMMUTABLE_CONTRACT.</p><p>--- Signing Requirements ---</p><p>1. Whether or not a contract has an admin key, its expiry can be extended with only the</p><p>transaction payer's signature.</p><p>2. Updating any other field of a mutable contract requires the admin key's signature.</p><p>3. If the update transaction includes a new admin key, this new key must also sign <b>unless</b></p><p>it is exactly an empty <tt>KeyList</tt>. This special sentinel key removes the existing admin</p><p>key and causes the contract to become immutable. (Other <tt>Key</tt> structures without a</p><p>constituent <tt>Ed25519</tt> key will be rejected with <tt>INVALID_ADMIN_KEY</tt>.)</p><p>4. If the update transaction sets the AccountID auto_renew_account_id wrapper field to anything</p><p>other than the sentinel <tt>0.0.0</tt> value, then the key of the referenced account must sign.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>contractID</td>
                  <td><a href="#proto.ContractID">ContractID</a></td>
                  <td></td>
                  <td><p>The id of the contract to be updated </p></td>
                </tr>
              
                <tr>
                  <td>expirationTime</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>The new expiry of the contract, no earlier than the current expiry (resolves to
EXPIRATION_REDUCTION_NOT_ALLOWED otherwise) </p></td>
                </tr>
              
                <tr>
                  <td>adminKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The new key to control updates to the contract </p></td>
                </tr>
              
                <tr>
                  <td>proxyAccountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> [Deprecated] The new id of the account to which the contract is proxy staked </p></td>
                </tr>
              
                <tr>
                  <td>autoRenewPeriod</td>
                  <td><a href="#proto.Duration">Duration</a></td>
                  <td></td>
                  <td><p>(NOT YET IMPLEMENTED) The new interval at which the contract will pay to extend its expiry
(by the same interval) </p></td>
                </tr>
              
                <tr>
                  <td>fileID</td>
                  <td><a href="#proto.FileID">FileID</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> This field is unused and will have no impact on the specified smart contract. </p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> [Deprecated] If set with a non-zero length, the new memo to be associated with the account
(UTF-8 encoding max 100 bytes) </p></td>
                </tr>
              
                <tr>
                  <td>memoWrapper</td>
                  <td><a href="#google.protobuf.StringValue">google.protobuf.StringValue</a></td>
                  <td></td>
                  <td><p>If set, the new memo to be associated with the account (UTF-8 encoding max 100 bytes) </p></td>
                </tr>
              
                <tr>
                  <td>max_automatic_token_associations</td>
                  <td><a href="#google.protobuf.Int32Value">google.protobuf.Int32Value</a></td>
                  <td></td>
                  <td><p>If set, the new maximum number of tokens that this contract can be 
automatically associated with (i.e., receive air-drops from). </p></td>
                </tr>
              
                <tr>
                  <td>auto_renew_account_id</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>If set to the sentinel &lt;tt&gt;0.0.0&lt;/tt&gt; AccountID, this field removes the contract&#39;s auto-renew 
account. Otherwise it updates the contract&#39;s auto-renew account to the referenced account. </p></td>
                </tr>
              
                <tr>
                  <td>staked_account_id</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>ID of the new account to which this contract is staking. If set to the sentinel &lt;tt&gt;0.0.0&lt;/tt&gt; AccountID,
this field removes the contract&#39;s staked account ID. </p></td>
                </tr>
              
                <tr>
                  <td>staked_node_id</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>ID of the new node this contract is staked to. If set to the sentinel &lt;tt&gt;-1&lt;/tt&gt;, this field
removes the contract&#39;s staked node ID. </p></td>
                </tr>
              
                <tr>
                  <td>decline_reward</td>
                  <td><a href="#google.protobuf.BoolValue">google.protobuf.BoolValue</a></td>
                  <td></td>
                  <td><p>If true, the contract declines receiving a staking reward. </p></td>
                </tr>
              
            </tbody>
          </table>

          
            
            
            <h4>Fields with deprecated option</h4>
            <table>
              <thead>
                <tr>
                  <td>Name</td>
                  <td>Option</td>
                </tr>
              </thead>
              <tbody>
              
                <tr>
                  <td>proxyAccountID</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>fileID</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><p>true</p></td>
                </tr>
              
              </tbody>
            </table>
            
          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="crypto_add_live_hash.proto">crypto_add_live_hash.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.CryptoAddLiveHashTransactionBody">CryptoAddLiveHashTransactionBody</h3>
        <p>At consensus, attaches the given livehash to the given account.  The hash can be deleted by the</p><p>key controlling the account, or by any of the keys associated to the livehash.  Hence livehashes</p><p>provide a revocation service for their implied credentials; for example, when an authority grants</p><p>a credential to the account, the account owner will cosign with the authority (or authorities) to</p><p>attach a hash of the credential to the account---hence proving the grant. If the credential is</p><p>revoked, then any of the authorities may delete it (or the account owner). In this way, the</p><p>livehash mechanism acts as a revocation service.  An account cannot have two identical livehashes</p><p>associated. To modify the list of keys in a livehash, the livehash should first be deleted, then</p><p>recreated with a new list of keys.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>liveHash</td>
                  <td><a href="#proto.LiveHash">LiveHash</a></td>
                  <td></td>
                  <td><p>A hash of some credential or certificate, along with the keys of the entities that asserted it validity </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.LiveHash">LiveHash</h3>
        <p>A hash---presumably of some kind of credential or certificate---along with a list of keys, each</p><p>of which may be either a primitive or a threshold key.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>accountId</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account to which the livehash is attached </p></td>
                </tr>
              
                <tr>
                  <td>hash</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The SHA-384 hash of a credential or certificate </p></td>
                </tr>
              
                <tr>
                  <td>keys</td>
                  <td><a href="#proto.KeyList">KeyList</a></td>
                  <td></td>
                  <td><p>A list of keys (primitive or threshold), all of which must sign to attach the livehash to an account, and any one of which can later delete it. </p></td>
                </tr>
              
                <tr>
                  <td>duration</td>
                  <td><a href="#proto.Duration">Duration</a></td>
                  <td></td>
                  <td><p>The duration for which the livehash will remain valid </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="crypto_adjust_allowance.proto">crypto_adjust_allowance.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.CryptoAdjustAllowanceTransactionBody">CryptoAdjustAllowanceTransactionBody</h3>
        <p>Modifies or creates an hbar/token allowance for a spender <b>relative to the payer account</p><p>of this transaction</b>.</p><p>(So if account <tt>0.0.X</tt> pays for this transaction, then at consensus the spender</p><p>account will have new allowances to spend hbar or tokens from <tt>0.0.X</tt>).</p><p>If the allowance already exists, the hbar/token amount will be used to adjust the current</p><p>allowance balance. If this value is negative the approved allowance will be decreased.</p><p>The adjusted allowance balance cannot exceed the total supply of the token nor can it</p><p>be negative.</p><p>If the allowance does not exist, it will be created with the hbar/token amount being used</p><p>as the allowance balance.</p><p><b>IMPORTANT</b>: If an allowance for the spender does not currently exist, this transaction</p><p>behaves like an allowance approval.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>cryptoAllowances</td>
                  <td><a href="#proto.CryptoAllowance">CryptoAllowance</a></td>
                  <td>repeated</td>
                  <td><p>List of hbar allowances approved by the account owner. </p></td>
                </tr>
              
                <tr>
                  <td>nftAllowances</td>
                  <td><a href="#proto.NftAllowance">NftAllowance</a></td>
                  <td>repeated</td>
                  <td><p>List of non-fungible token allowances approved by the account owner. </p></td>
                </tr>
              
                <tr>
                  <td>tokenAllowances</td>
                  <td><a href="#proto.TokenAllowance">TokenAllowance</a></td>
                  <td>repeated</td>
                  <td><p>List of fungible token allowances approved by the account owner. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="crypto_approve_allowance.proto">crypto_approve_allowance.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.CryptoAllowance">CryptoAllowance</h3>
        <p>An approved allowance of hbar transfers for a spender.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>owner</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account ID of the hbar owner (ie. the grantor of the allowance). </p></td>
                </tr>
              
                <tr>
                  <td>spender</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account ID of the spender of the hbar allowance. </p></td>
                </tr>
              
                <tr>
                  <td>amount</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The amount of the spender&#39;s allowance in tinybars. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.CryptoApproveAllowanceTransactionBody">CryptoApproveAllowanceTransactionBody</h3>
        <p>Creates one or more hbar/token approved allowances <b>relative to the owner account specified in the allowances of</p><p>this transaction</b>. Each allowance grants a spender the right to transfer a pre-determined amount of the owner's</p><p>hbar/token to any other account of the spender's choice. If the owner is not specified in any allowance, the payer</p><p>of transaction is considered to be the owner for that particular allowance.</p><p>Setting the amount to zero in CryptoAllowance or TokenAllowance will remove the respective allowance for the spender.</p><p>(So if account <tt>0.0.X</tt> pays for this transaction and owner is not specified in the allowance,</p><p>then at consensus each spender account will have new allowances to spend hbar or tokens from <tt>0.0.X</tt>).</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>cryptoAllowances</td>
                  <td><a href="#proto.CryptoAllowance">CryptoAllowance</a></td>
                  <td>repeated</td>
                  <td><p>List of hbar allowances approved by the account owner. </p></td>
                </tr>
              
                <tr>
                  <td>nftAllowances</td>
                  <td><a href="#proto.NftAllowance">NftAllowance</a></td>
                  <td>repeated</td>
                  <td><p>List of non-fungible token allowances approved by the account owner. </p></td>
                </tr>
              
                <tr>
                  <td>tokenAllowances</td>
                  <td><a href="#proto.TokenAllowance">TokenAllowance</a></td>
                  <td>repeated</td>
                  <td><p>List of fungible token allowances approved by the account owner. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.NftAllowance">NftAllowance</h3>
        <p>An approved allowance of non-fungible token transfers for a spender.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>tokenId</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The NFT token type that the allowance pertains to. </p></td>
                </tr>
              
                <tr>
                  <td>owner</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account ID of the token owner (ie. the grantor of the allowance). </p></td>
                </tr>
              
                <tr>
                  <td>spender</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account ID of the token allowance spender. </p></td>
                </tr>
              
                <tr>
                  <td>serial_numbers</td>
                  <td><a href="#int64">int64</a></td>
                  <td>repeated</td>
                  <td><p>The list of serial numbers that the spender is permitted to transfer. </p></td>
                </tr>
              
                <tr>
                  <td>approved_for_all</td>
                  <td><a href="#google.protobuf.BoolValue">google.protobuf.BoolValue</a></td>
                  <td></td>
                  <td><p>If true, the spender has access to all of the owner&#39;s NFT units of type tokenId (currently
owned and any in the future). </p></td>
                </tr>
              
                <tr>
                  <td>delegating_spender</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account ID of the spender who is granted approvedForAll allowance and granting
approval on an NFT serial to another spender. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.TokenAllowance">TokenAllowance</h3>
        <p>An approved allowance of fungible token transfers for a spender.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>tokenId</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The token that the allowance pertains to. </p></td>
                </tr>
              
                <tr>
                  <td>owner</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account ID of the token owner (ie. the grantor of the allowance). </p></td>
                </tr>
              
                <tr>
                  <td>spender</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account ID of the token allowance spender. </p></td>
                </tr>
              
                <tr>
                  <td>amount</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The amount of the spender&#39;s token allowance. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="crypto_create.proto">crypto_create.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.CryptoCreateTransactionBody">CryptoCreateTransactionBody</h3>
        <p>Create a new account. After the account is created, the AccountID for it is in the receipt. It</p><p>can also be retrieved with a GetByKey query. Threshold values can be defined, and records are</p><p>generated and stored for 25 hours for any transfer that exceeds the thresholds. This account is</p><p>charged for each record generated, so the thresholds are useful for limiting record generation to</p><p>happen only for large transactions.</p><p>The Key field is the key used to sign transactions for this account. If the account has</p><p>receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this</p><p>account's key, both for transfers in and out. If it is false, then only transfers out have to be</p><p>signed by it. When the account is created, the payer account is charged enough hbars so that the</p><p>new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration</p><p>time, the new account will then be automatically charged to renew for another autoRenewPeriod</p><p>seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are</p><p>used to extend its expiration as long as possible. If it is has a zero balance when it expires,</p><p>then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired</p><p>is false, then the transaction does not have to be signed by the keys in the keys field. If it is</p><p>true, then it must be signed by them, in addition to the keys of the payer account.</p><p>An entity (account, file, or smart contract instance) must be created in a particular realm. If</p><p>the realmID is left null, then a new realm will be created with the given admin key. If a new</p><p>realm has a null adminKey, then anyone can create/modify/delete entities in that realm. But if an</p><p>admin key is given, then any transaction to create/modify/delete an entity in that realm must be</p><p>signed by that key, though anyone can still call functions on smart contract instances that exist</p><p>in that realm. A realm ceases to exist when everything within it has expired and no longer</p><p>exists.</p><p>The current API ignores shardID, realmID, and newRealmAdminKey, and creates everything in shard 0</p><p>and realm 0, with a null key. Future versions of the API will support multiple realms and</p><p>multiple shards.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>key</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The key that must sign each transfer out of the account. If receiverSigRequired is true, then
it must also sign any transfer into the account. </p></td>
                </tr>
              
                <tr>
                  <td>initialBalance</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>The initial number of tinybars to put into the account </p></td>
                </tr>
              
                <tr>
                  <td>proxyAccountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> [Deprecated] ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an
invalid account, or is an account that isn&#39;t a node, then this account is automatically proxy
staked to a node chosen by the network, but without earning payments. If the proxyAccountID
account refuses to accept proxy staking , or if it is not currently running a node, then it
will behave as if proxyAccountID was null. </p></td>
                </tr>
              
                <tr>
                  <td>sendRecordThreshold</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> [Deprecated]. The threshold amount (in tinybars) for which an account record is created for
any send/withdraw transaction </p></td>
                </tr>
              
                <tr>
                  <td>receiveRecordThreshold</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> [Deprecated]. The threshold amount (in tinybars) for which an account record is created for
any receive/deposit transaction </p></td>
                </tr>
              
                <tr>
                  <td>receiverSigRequired</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>If true, this account&#39;s key must sign any transaction depositing into this account (in
addition to all withdrawals) </p></td>
                </tr>
              
                <tr>
                  <td>autoRenewPeriod</td>
                  <td><a href="#proto.Duration">Duration</a></td>
                  <td></td>
                  <td><p>The account is charged to extend its expiration date every this many seconds. If it doesn&#39;t
have enough balance, it extends as long as possible. If it is empty when it expires, then it
is deleted. </p></td>
                </tr>
              
                <tr>
                  <td>shardID</td>
                  <td><a href="#proto.ShardID">ShardID</a></td>
                  <td></td>
                  <td><p>The shard in which this account is created </p></td>
                </tr>
              
                <tr>
                  <td>realmID</td>
                  <td><a href="#proto.RealmID">RealmID</a></td>
                  <td></td>
                  <td><p>The realm in which this account is created (leave this null to create a new realm) </p></td>
                </tr>
              
                <tr>
                  <td>newRealmAdminKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>If realmID is null, then this the admin key for the new realm that will be created </p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The memo associated with the account (UTF-8 encoding max 100 bytes) </p></td>
                </tr>
              
                <tr>
                  <td>max_automatic_token_associations</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p>The maximum number of tokens that an Account can be implicitly associated with. Defaults to 0
and up to a maximum value of 1000. </p></td>
                </tr>
              
                <tr>
                  <td>staked_account_id</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>ID of the account to which this account is staking. </p></td>
                </tr>
              
                <tr>
                  <td>staked_node_id</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>ID of the node this account is staked to. </p></td>
                </tr>
              
                <tr>
                  <td>decline_reward</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>If true, the account declines receiving a staking reward. The default value is false. </p></td>
                </tr>
              
            </tbody>
          </table>

          
            
            
            <h4>Fields with deprecated option</h4>
            <table>
              <thead>
                <tr>
                  <td>Name</td>
                  <td>Option</td>
                </tr>
              </thead>
              <tbody>
              
                <tr>
                  <td>proxyAccountID</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>sendRecordThreshold</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>receiveRecordThreshold</td>
                  <td><p>true</p></td>
                </tr>
              
              </tbody>
            </table>
            
          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="crypto_delete.proto">crypto_delete.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</h3>
        <p>Mark an account as deleted, moving all its current hbars to another account. It will remain in</p><p>the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a</p><p>deleted account can still have its expiration extended in the normal way.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>transferAccountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account ID which will receive all remaining hbars </p></td>
                </tr>
              
                <tr>
                  <td>deleteAccountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account ID which should be deleted </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="crypto_delete_allowance.proto">crypto_delete_allowance.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.CryptoDeleteAllowanceTransactionBody">CryptoDeleteAllowanceTransactionBody</h3>
        <p>Deletes one or more non-fungible approved allowances from an owner's account. This operation</p><p>will remove the allowances granted to one or more specific non-fungible token serial numbers. Each owner account</p><p>listed as wiping an allowance must sign the transaction. Hbar and fungible token allowances</p><p>can be removed by setting the amount to zero in CryptoApproveAllowance.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>nftAllowances</td>
                  <td><a href="#proto.NftRemoveAllowance">NftRemoveAllowance</a></td>
                  <td>repeated</td>
                  <td><p>List of non-fungible token allowances to remove. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.NftRemoveAllowance">NftRemoveAllowance</h3>
        <p>Nft allowances to be removed on an owner account</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>token_id</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The token that the allowance pertains to. </p></td>
                </tr>
              
                <tr>
                  <td>owner</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account ID of the token owner (ie. the grantor of the allowance). </p></td>
                </tr>
              
                <tr>
                  <td>serial_numbers</td>
                  <td><a href="#int64">int64</a></td>
                  <td>repeated</td>
                  <td><p>The list of serial numbers to remove allowances from. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="crypto_delete_live_hash.proto">crypto_delete_live_hash.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.CryptoDeleteLiveHashTransactionBody">CryptoDeleteLiveHashTransactionBody</h3>
        <p>At consensus, deletes a livehash associated to the given account. The transaction must be signed</p><p>by either the key of the owning account, or at least one of the keys associated to the livehash.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>accountOfLiveHash</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account owning the livehash </p></td>
                </tr>
              
                <tr>
                  <td>liveHashToDelete</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The SHA-384 livehash to delete from the account </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="crypto_get_account_balance.proto">crypto_get_account_balance.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.CryptoGetAccountBalanceQuery">CryptoGetAccountBalanceQuery</h3>
        <p>Get the balance of a cryptocurrency account. This returns only the balance, so it is a smaller</p><p>reply than CryptoGetInfo, which returns the balance plus additional information.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>Standard info sent from client to node, including the signed payment, and what kind of
response is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>accountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account ID for which information is requested </p></td>
                </tr>
              
                <tr>
                  <td>contractID</td>
                  <td><a href="#proto.ContractID">ContractID</a></td>
                  <td></td>
                  <td><p>The account ID for which information is requested </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.CryptoGetAccountBalanceResponse">CryptoGetAccountBalanceResponse</h3>
        <p>Response when the client sends the node CryptoGetAccountBalanceQuery</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof,
or both, or neither. </p></td>
                </tr>
              
                <tr>
                  <td>accountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account ID that is being described (this is useful with state proofs, for proving to a
third party) </p></td>
                </tr>
              
                <tr>
                  <td>balance</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>The current balance, in tinybars. </p></td>
                </tr>
              
                <tr>
                  <td>tokenBalances</td>
                  <td><a href="#proto.TokenBalance">TokenBalance</a></td>
                  <td>repeated</td>
                  <td><p><strong>Deprecated.</strong> [DEPRECATED] The balances of the tokens associated to the account. This field was 
deprecated by &lt;a href=&#34;https://hips.hedera.com/hip/hip-367&#34;&gt;HIP-367&lt;/a&gt;, which allowed 
an account to be associated to an unlimited number of tokens. This scale makes it more 
efficient for users to consult mirror nodes to review their token balances. </p></td>
                </tr>
              
            </tbody>
          </table>

          
            
            
            <h4>Fields with deprecated option</h4>
            <table>
              <thead>
                <tr>
                  <td>Name</td>
                  <td>Option</td>
                </tr>
              </thead>
              <tbody>
              
                <tr>
                  <td>tokenBalances</td>
                  <td><p>true</p></td>
                </tr>
              
              </tbody>
            </table>
            
          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="crypto_get_account_records.proto">crypto_get_account_records.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.CryptoGetAccountRecordsQuery">CryptoGetAccountRecordsQuery</h3>
        <p>Requests records of all transactions for which the given account was the effective payer in the last 3 minutes of consensus time and <tt>ledger.keepRecordsInState=true</tt> was true during <tt>handleTransaction</tt>.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>accountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account ID for which the records should be retrieved </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.CryptoGetAccountRecordsResponse">CryptoGetAccountRecordsResponse</h3>
        <p>Returns records of all transactions for which the given account was the effective payer in the last 3 minutes of consensus time and <tt>ledger.keepRecordsInState=true</tt> was true during <tt>handleTransaction</tt>.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>accountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account that this record is for </p></td>
                </tr>
              
                <tr>
                  <td>records</td>
                  <td><a href="#proto.TransactionRecord">TransactionRecord</a></td>
                  <td>repeated</td>
                  <td><p>List of records </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="crypto_get_info.proto">crypto_get_info.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.CryptoGetInfoQuery">CryptoGetInfoQuery</h3>
        <p>Get all the information about an account, including the balance. This does not get the list of</p><p>account records.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>Standard info sent from client to node, including the signed payment, and what kind of
response is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>accountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account ID for which information is requested </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.CryptoGetInfoResponse">CryptoGetInfoResponse</h3>
        <p>Response when the client sends the node CryptoGetInfoQuery</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof,
or both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>accountInfo</td>
                  <td><a href="#proto.CryptoGetInfoResponse.AccountInfo">CryptoGetInfoResponse.AccountInfo</a></td>
                  <td></td>
                  <td><p>Info about the account (a state proof can be generated for this) </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.CryptoGetInfoResponse.AccountInfo">CryptoGetInfoResponse.AccountInfo</h3>
        <p></p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>accountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account ID for which this information applies </p></td>
                </tr>
              
                <tr>
                  <td>contractAccountID</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The Contract Account ID comprising of both the contract instance and the cryptocurrency
account owned by the contract instance, in the format used by Solidity </p></td>
                </tr>
              
                <tr>
                  <td>deleted</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>If true, then this account has been deleted, it will disappear when it expires, and all
transactions for it will fail except the transaction to extend its expiration date </p></td>
                </tr>
              
                <tr>
                  <td>proxyAccountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> [Deprecated] The Account ID of the account to which this is proxy staked. If proxyAccountID is null,
or is an invalid account, or is an account that isn&#39;t a node, then this account is
automatically proxy staked to a node chosen by the network, but without earning payments.
If the proxyAccountID account refuses to accept proxy staking , or if it is not currently
running a node, then it will behave as if proxyAccountID was null. </p></td>
                </tr>
              
                <tr>
                  <td>proxyReceived</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The total number of tinybars proxy staked to this account </p></td>
                </tr>
              
                <tr>
                  <td>key</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The key for the account, which must sign in order to transfer out, or to modify the
account in any way other than extending its expiration date. </p></td>
                </tr>
              
                <tr>
                  <td>balance</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>The current balance of account in tinybars </p></td>
                </tr>
              
                <tr>
                  <td>generateSendRecordThreshold</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> [Deprecated]. The threshold amount, in tinybars, at which a record is created of any
transaction that decreases the balance of this account by more than the threshold </p></td>
                </tr>
              
                <tr>
                  <td>generateReceiveRecordThreshold</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> [Deprecated]. The threshold amount, in tinybars, at which a record is created of any
transaction that increases the balance of this account by more than the threshold </p></td>
                </tr>
              
                <tr>
                  <td>receiverSigRequired</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>If true, no transaction can transfer to this account unless signed by this account&#39;s key </p></td>
                </tr>
              
                <tr>
                  <td>expirationTime</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>The TimeStamp time at which this account is set to expire </p></td>
                </tr>
              
                <tr>
                  <td>autoRenewPeriod</td>
                  <td><a href="#proto.Duration">Duration</a></td>
                  <td></td>
                  <td><p>The duration for expiration time will extend every this many seconds. If there are
insufficient funds, then it extends as long as possible. If it is empty when it expires,
then it is deleted. </p></td>
                </tr>
              
                <tr>
                  <td>liveHashes</td>
                  <td><a href="#proto.LiveHash">LiveHash</a></td>
                  <td>repeated</td>
                  <td><p>All of the livehashes attached to the account (each of which is a hash along with the
keys that authorized it and can delete it) </p></td>
                </tr>
              
                <tr>
                  <td>tokenRelationships</td>
                  <td><a href="#proto.TokenRelationship">TokenRelationship</a></td>
                  <td>repeated</td>
                  <td><p><strong>Deprecated.</strong> [DEPRECATED] The metadata of the tokens associated to the account. This field was 
deprecated by &lt;a href=&#34;https://hips.hedera.com/hip/hip-367&#34;&gt;HIP-367&lt;/a&gt;, which allowed 
an account to be associated to an unlimited number of tokens. This scale makes it more 
efficient for users to consult mirror nodes to review their token associations. </p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The memo associated with the account </p></td>
                </tr>
              
                <tr>
                  <td>ownedNfts</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The number of NFTs owned by this account </p></td>
                </tr>
              
                <tr>
                  <td>max_automatic_token_associations</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p>The maximum number of tokens that an Account can be implicitly associated with. </p></td>
                </tr>
              
                <tr>
                  <td>alias</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The alias of this account </p></td>
                </tr>
              
                <tr>
                  <td>ledger_id</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The ledger ID the response was returned from; please see &lt;a href=&#34;https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md&#34;&gt;HIP-198&lt;/a&gt; for the network-specific IDs. </p></td>
                </tr>
              
                <tr>
                  <td>ethereum_nonce</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The ethereum transaction nonce associated with this account. </p></td>
                </tr>
              
                <tr>
                  <td>staking_info</td>
                  <td><a href="#proto.StakingInfo">StakingInfo</a></td>
                  <td></td>
                  <td><p>Staking metadata for this account. </p></td>
                </tr>
              
            </tbody>
          </table>

          
            
            
            <h4>Fields with deprecated option</h4>
            <table>
              <thead>
                <tr>
                  <td>Name</td>
                  <td>Option</td>
                </tr>
              </thead>
              <tbody>
              
                <tr>
                  <td>proxyAccountID</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>generateSendRecordThreshold</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>generateReceiveRecordThreshold</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>tokenRelationships</td>
                  <td><p>true</p></td>
                </tr>
              
              </tbody>
            </table>
            
          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="crypto_get_live_hash.proto">crypto_get_live_hash.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.CryptoGetLiveHashQuery">CryptoGetLiveHashQuery</h3>
        <p>Requests a livehash associated to an account.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>Standard info sent from client to node, including the signed payment, and what kind of
response is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>accountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account to which the livehash is associated </p></td>
                </tr>
              
                <tr>
                  <td>hash</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The SHA-384 data in the livehash </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.CryptoGetLiveHashResponse">CryptoGetLiveHashResponse</h3>
        <p>Returns the full livehash associated to an account, if it is present. Note that the only way to</p><p>obtain a state proof exhibiting the absence of a livehash from an account is to retrieve a state</p><p>proof of the entire account with its list of livehashes.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof,
or both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>liveHash</td>
                  <td><a href="#proto.LiveHash">LiveHash</a></td>
                  <td></td>
                  <td><p>The livehash, if present </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="crypto_get_stakers.proto">crypto_get_stakers.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.AllProxyStakers">AllProxyStakers</h3>
        <p>all of the accounts proxy staking to a given account, and the amounts proxy staked</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>accountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The Account ID that is being proxy staked to </p></td>
                </tr>
              
                <tr>
                  <td>proxyStaker</td>
                  <td><a href="#proto.ProxyStaker">ProxyStaker</a></td>
                  <td>repeated</td>
                  <td><p>Each of the proxy staking accounts, and the amount they are proxy staking </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.CryptoGetStakersQuery">CryptoGetStakersQuery</h3>
        <p>Get all the accounts that are proxy staking to this account. For each of them, give the amount</p><p>currently staked. This is not yet implemented, but will be in a future version of the API.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>Standard info sent from client to node, including the signed payment, and what kind of
response is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>accountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The Account ID for which the records should be retrieved </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.CryptoGetStakersResponse">CryptoGetStakersResponse</h3>
        <p>Response when the client sends the node CryptoGetStakersQuery</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof,
or both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>stakers</td>
                  <td><a href="#proto.AllProxyStakers">AllProxyStakers</a></td>
                  <td></td>
                  <td><p>List of accounts proxy staking to this account, and the amount each is currently proxy
staking </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.ProxyStaker">ProxyStaker</h3>
        <p>information about a single account that is proxy staking</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>accountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The Account ID that is proxy staking </p></td>
                </tr>
              
                <tr>
                  <td>amount</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The number of hbars that are currently proxy staked </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="crypto_service.proto">crypto_service.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      

      

      

      
        <h3 id="proto.CryptoService">CryptoService</h3>
        <p>Transactions and queries for the Crypto Service</p>
        <table class="enum-table">
          <thead>
            <tr><td>Method Name</td><td>Request Type</td><td>Response Type</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>createAccount</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Creates a new account by submitting the transaction</p></td>
              </tr>
            
              <tr>
                <td>updateAccount</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Updates an account by submitting the transaction</p></td>
              </tr>
            
              <tr>
                <td>cryptoTransfer</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Initiates a transfer by submitting the transaction</p></td>
              </tr>
            
              <tr>
                <td>cryptoDelete</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Deletes and account by submitting the transaction</p></td>
              </tr>
            
              <tr>
                <td>approveAllowances</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Adds one or more approved allowances for spenders to transfer the paying account&#39;s hbar or tokens.</p></td>
              </tr>
            
              <tr>
                <td>deleteAllowances</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Deletes one or more of the specific approved NFT serial numbers on an owner account.</p></td>
              </tr>
            
              <tr>
                <td>addLiveHash</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>(NOT CURRENTLY SUPPORTED) Adds a livehash</p></td>
              </tr>
            
              <tr>
                <td>deleteLiveHash</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>(NOT CURRENTLY SUPPORTED) Deletes a livehash</p></td>
              </tr>
            
              <tr>
                <td>getLiveHash</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>(NOT CURRENTLY SUPPORTED) Retrieves a livehash for an account</p></td>
              </tr>
            
              <tr>
                <td>getAccountRecords</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>Returns all transactions in the last 180s of consensus time for which the given account was
the effective payer &lt;b&gt;and&lt;/b&gt; network property &lt;tt&gt;ledger.keepRecordsInState&lt;/tt&gt; was
&lt;tt&gt;true&lt;/tt&gt;.</p></td>
              </tr>
            
              <tr>
                <td>cryptoGetBalance</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>Retrieves the balance of an account</p></td>
              </tr>
            
              <tr>
                <td>getAccountInfo</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>Retrieves the metadata of an account</p></td>
              </tr>
            
              <tr>
                <td>getTransactionReceipts</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>Retrieves the latest receipt for a transaction that is either awaiting consensus, or reached
consensus in the last 180 seconds</p></td>
              </tr>
            
              <tr>
                <td>getFastTransactionRecord</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>(NOT CURRENTLY SUPPORTED) Returns the records of transactions recently funded by an account</p></td>
              </tr>
            
              <tr>
                <td>getTxRecordByTxID</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>Retrieves the record of a transaction that is either awaiting consensus, or reached consensus
in the last 180 seconds</p></td>
              </tr>
            
              <tr>
                <td>getStakersByAccountID</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>(NOT CURRENTLY SUPPORTED) Retrieves the stakers for a node by account id</p></td>
              </tr>
            
          </tbody>
        </table>

        
    
      
      <div class="file-heading">
        <h2 id="crypto_transfer.proto">crypto_transfer.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.CryptoTransferTransactionBody">CryptoTransferTransactionBody</h3>
        <p>Transfers cryptocurrency among two or more accounts by making the desired adjustments to their</p><p>balances. Each transfer list can specify up to 10 adjustments. Each negative amount is withdrawn</p><p>from the corresponding account (a sender), and each positive one is added to the corresponding</p><p>account (a receiver). The amounts list must sum to zero. Each amount is a number of tinybars</p><p>(there are 100,000,000 tinybars in one hbar).  If any sender account fails to have sufficient</p><p>hbars, then the entire transaction fails, and none of those transfers occur, though the</p><p>transaction fee is still charged. This transaction must be signed by the keys for all the sending</p><p>accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures</p><p>are in the same order as the accounts, skipping those accounts that don't need a signature.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>transfers</td>
                  <td><a href="#proto.TransferList">TransferList</a></td>
                  <td></td>
                  <td><p>The desired hbar balance adjustments </p></td>
                </tr>
              
                <tr>
                  <td>tokenTransfers</td>
                  <td><a href="#proto.TokenTransferList">TokenTransferList</a></td>
                  <td>repeated</td>
                  <td><p>The desired token unit balance adjustments; if any custom fees are assessed, the ledger will
try to deduct them from the payer of this CryptoTransfer, resolving the transaction to
INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE if this is not possible </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="crypto_update.proto">crypto_update.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</h3>
        <p>Change properties for the given account. Any null field is ignored (left unchanged). This</p><p>transaction must be signed by the existing key for this account. If the transaction is changing</p><p>the key field, then the transaction must be signed by both the old key (from before the change)</p><p>and the new key. The old key must sign for security. The new key must sign as a safeguard to</p><p>avoid accidentally changing to an invalid key, and then having no way to recover.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>accountIDToUpdate</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account ID which is being updated in this transaction </p></td>
                </tr>
              
                <tr>
                  <td>key</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The new key </p></td>
                </tr>
              
                <tr>
                  <td>proxyAccountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> [Deprecated] ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an
invalid account, or is an account that isn&#39;t a node, then this account is automatically proxy
staked to a node chosen by the network, but without earning payments. If the proxyAccountID
account refuses to accept proxy staking , or if it is not currently running a node, then it
will behave as if proxyAccountID was null. </p></td>
                </tr>
              
                <tr>
                  <td>proxyFraction</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> [Deprecated]. Payments earned from proxy staking are shared between the node and this
account, with proxyFraction / 10000 going to this account </p></td>
                </tr>
              
                <tr>
                  <td>sendRecordThreshold</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> [Deprecated]. The new threshold amount (in tinybars) for which an account record is
created for any send/withdraw transaction </p></td>
                </tr>
              
                <tr>
                  <td>sendRecordThresholdWrapper</td>
                  <td><a href="#google.protobuf.UInt64Value">google.protobuf.UInt64Value</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> [Deprecated]. The new threshold amount (in tinybars) for which an account record is
created for any send/withdraw transaction </p></td>
                </tr>
              
                <tr>
                  <td>receiveRecordThreshold</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> [Deprecated]. The new threshold amount (in tinybars) for which an account record is
created for any receive/deposit transaction. </p></td>
                </tr>
              
                <tr>
                  <td>receiveRecordThresholdWrapper</td>
                  <td><a href="#google.protobuf.UInt64Value">google.protobuf.UInt64Value</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> [Deprecated]. The new threshold amount (in tinybars) for which an account record is
created for any receive/deposit transaction. </p></td>
                </tr>
              
                <tr>
                  <td>autoRenewPeriod</td>
                  <td><a href="#proto.Duration">Duration</a></td>
                  <td></td>
                  <td><p>The duration in which it will automatically extend the expiration period. If it doesn&#39;t have
enough balance, it extends as long as possible. If it is empty when it expires, then it is
deleted. </p></td>
                </tr>
              
                <tr>
                  <td>expirationTime</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>The new expiration time to extend to (ignored if equal to or before the current one) </p></td>
                </tr>
              
                <tr>
                  <td>receiverSigRequired</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> [Deprecated] Do NOT use this field to set a false value because the server cannot
distinguish from the default value. Use receiverSigRequiredWrapper field for this
purpose. </p></td>
                </tr>
              
                <tr>
                  <td>receiverSigRequiredWrapper</td>
                  <td><a href="#google.protobuf.BoolValue">google.protobuf.BoolValue</a></td>
                  <td></td>
                  <td><p>If true, this account&#39;s key must sign any transaction depositing into this account (in
addition to all withdrawals) </p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#google.protobuf.StringValue">google.protobuf.StringValue</a></td>
                  <td></td>
                  <td><p>If set, the new memo to be associated with the account (UTF-8 encoding max 100 bytes) </p></td>
                </tr>
              
                <tr>
                  <td>max_automatic_token_associations</td>
                  <td><a href="#google.protobuf.Int32Value">google.protobuf.Int32Value</a></td>
                  <td></td>
                  <td><p>The maximum number of tokens that an Account can be implicitly associated with. Up to a 1000
including implicit and explicit associations. </p></td>
                </tr>
              
                <tr>
                  <td>staked_account_id</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>ID of the new account to which this account is staking. If set to the sentinel &lt;tt&gt;0.0.0&lt;/tt&gt; AccountID,
this field removes this account&#39;s staked account ID. </p></td>
                </tr>
              
                <tr>
                  <td>staked_node_id</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>ID of the new node this account is staked to. If set to the sentinel &lt;tt&gt;-1&lt;/tt&gt;, this field
removes this account&#39;s staked node ID. </p></td>
                </tr>
              
                <tr>
                  <td>decline_reward</td>
                  <td><a href="#google.protobuf.BoolValue">google.protobuf.BoolValue</a></td>
                  <td></td>
                  <td><p>If true, the account declines receiving a staking reward. The default value is false. </p></td>
                </tr>
              
            </tbody>
          </table>

          
            
            
            <h4>Fields with deprecated option</h4>
            <table>
              <thead>
                <tr>
                  <td>Name</td>
                  <td>Option</td>
                </tr>
              </thead>
              <tbody>
              
                <tr>
                  <td>proxyAccountID</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>proxyFraction</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>sendRecordThreshold</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>sendRecordThresholdWrapper</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>receiveRecordThreshold</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>receiveRecordThresholdWrapper</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>receiverSigRequired</td>
                  <td><p>true</p></td>
                </tr>
              
              </tbody>
            </table>
            
          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="custom_fees.proto">custom_fees.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.AssessedCustomFee">AssessedCustomFee</h3>
        <p>A custom transfer fee that was assessed during handling of a CryptoTransfer.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>amount</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The number of units assessed for the fee </p></td>
                </tr>
              
                <tr>
                  <td>token_id</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The denomination of the fee; taken as hbar if left unset </p></td>
                </tr>
              
                <tr>
                  <td>fee_collector_account_id</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account to receive the assessed fee </p></td>
                </tr>
              
                <tr>
                  <td>effective_payer_account_id</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td>repeated</td>
                  <td><p>The account(s) whose final balances would have been higher in the absence of this assessed fee </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.CustomFee">CustomFee</h3>
        <p>A transfer fee to assess during a CryptoTransfer that transfers units of the token to which the</p><p>fee is attached. A custom fee may be either fixed or fractional, and must specify a fee collector</p><p>account to receive the assessed fees. Only positive fees may be assessed.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>fixed_fee</td>
                  <td><a href="#proto.FixedFee">FixedFee</a></td>
                  <td></td>
                  <td><p>Fixed fee to be charged </p></td>
                </tr>
              
                <tr>
                  <td>fractional_fee</td>
                  <td><a href="#proto.FractionalFee">FractionalFee</a></td>
                  <td></td>
                  <td><p>Fractional fee to be charged </p></td>
                </tr>
              
                <tr>
                  <td>royalty_fee</td>
                  <td><a href="#proto.RoyaltyFee">RoyaltyFee</a></td>
                  <td></td>
                  <td><p>Royalty fee to be charged </p></td>
                </tr>
              
                <tr>
                  <td>fee_collector_account_id</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account to receive the custom fee </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.FixedFee">FixedFee</h3>
        <p>A fixed number of units (hbar or token) to assess as a fee during a CryptoTransfer that transfers</p><p>units of the token to which this fixed fee is attached.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>amount</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The number of units to assess as a fee </p></td>
                </tr>
              
                <tr>
                  <td>denominating_token_id</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The denomination of the fee; taken as hbar if left unset and, in a TokenCreate, taken as the id
of the newly created token if set to the sentinel value of 0.0.0 </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.FractionalFee">FractionalFee</h3>
        <p>A fraction of the transferred units of a token to assess as a fee. The amount assessed will never</p><p>be less than the given minimum_amount, and never greater than the given maximum_amount.  The</p><p>denomination is always units of the token to which this fractional fee is attached.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>fractional_amount</td>
                  <td><a href="#proto.Fraction">Fraction</a></td>
                  <td></td>
                  <td><p>The fraction of the transferred units to assess as a fee </p></td>
                </tr>
              
                <tr>
                  <td>minimum_amount</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The minimum amount to assess </p></td>
                </tr>
              
                <tr>
                  <td>maximum_amount</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The maximum amount to assess (zero implies no maximum) </p></td>
                </tr>
              
                <tr>
                  <td>net_of_transfers</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>If true, assesses the fee to the sender, so the receiver gets the full amount from the token
transfer list, and the sender is charged an additional fee; if false, the receiver does NOT get
the full amount, but only what is left over after paying the fractional fee </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.RoyaltyFee">RoyaltyFee</h3>
        <p>A fee to assess during a CryptoTransfer that changes ownership of an NFT. Defines the fraction of</p><p>the fungible value exchanged for an NFT that the ledger should collect as a royalty. ("Fungible</p><p>value" includes both ℏ and units of fungible HTS tokens.) When the NFT sender does not receive</p><p>any fungible value, the ledger will assess the fallback fee, if present, to the new NFT owner.</p><p>Royalty fees can only be added to tokens of type type NON_FUNGIBLE_UNIQUE.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>exchange_value_fraction</td>
                  <td><a href="#proto.Fraction">Fraction</a></td>
                  <td></td>
                  <td><p>The fraction of fungible value exchanged for an NFT to collect as royalty </p></td>
                </tr>
              
                <tr>
                  <td>fallback_fee</td>
                  <td><a href="#proto.FixedFee">FixedFee</a></td>
                  <td></td>
                  <td><p>If present, the fixed fee to assess to the NFT receiver when no fungible value is exchanged
with the sender </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="duration.proto">duration.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.Duration">Duration</h3>
        <p>A length of time in seconds.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>seconds</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The number of seconds </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="ethereum_transaction.proto">ethereum_transaction.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.EthereumTransactionBody">EthereumTransactionBody</h3>
        <p></p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>ethereum_data</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The raw Ethereum transaction (RLP encoded type 0, 1, and 2). Complete 
unless the callData field is set. </p></td>
                </tr>
              
                <tr>
                  <td>call_data</td>
                  <td><a href="#proto.FileID">FileID</a></td>
                  <td></td>
                  <td><p>For large transactions (for example contract create) this is the callData
of the ethereumData. The data in the ethereumData will be re-written with 
the callData element as a zero length string with the original contents in 
the referenced file at time of execution. The ethereumData will need to be 
&#34;rehydrated&#34; with the callData for signature validation to pass. </p></td>
                </tr>
              
                <tr>
                  <td>max_gas_allowance</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The maximum amount, in tinybars, that the payer of the hedera transaction 
is willing to pay to complete the transaction.

Ordinarily the account with the ECDSA alias corresponding to the public 
key that is extracted from the ethereum_data signature is responsible for
fees that result from the execution of the transaction. If that amount of
authorized fees is not sufficient then the payer of the transaction can be
charged, up to but not exceeding this amount. If the ethereum_data 
transaction authorized an amount that was insufficient then the payer will
only be charged the amount needed to make up the difference. If the gas 
price in the transaction was set to zero then the payer will be assessed 
the entire fee. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="exchange_rate.proto">exchange_rate.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.ExchangeRate">ExchangeRate</h3>
        <p>An exchange rate between hbar and cents (USD) and the time at which the exchange rate will</p><p>expire, and be superseded by a new exchange rate.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>hbarEquiv</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p>Denominator in calculation of exchange rate between hbar and cents </p></td>
                </tr>
              
                <tr>
                  <td>centEquiv</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p>Numerator in calculation of exchange rate between hbar and cents </p></td>
                </tr>
              
                <tr>
                  <td>expirationTime</td>
                  <td><a href="#proto.TimestampSeconds">TimestampSeconds</a></td>
                  <td></td>
                  <td><p>Expiration time in seconds for this exchange rate </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.ExchangeRateSet">ExchangeRateSet</h3>
        <p>Two sets of exchange rates</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>currentRate</td>
                  <td><a href="#proto.ExchangeRate">ExchangeRate</a></td>
                  <td></td>
                  <td><p>Current exchange rate </p></td>
                </tr>
              
                <tr>
                  <td>nextRate</td>
                  <td><a href="#proto.ExchangeRate">ExchangeRate</a></td>
                  <td></td>
                  <td><p>Next exchange rate which will take effect when current rate expires </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="file_append.proto">file_append.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.FileAppendTransactionBody">FileAppendTransactionBody</h3>
        <p>Append the given contents to the end of the specified file. If a file is too big to create with a</p><p>single FileCreateTransaction, then it can be created with the first part of its contents, and</p><p>then appended as many times as necessary to create the entire file. This transaction must be</p><p>signed by all initial M-of-M KeyList keys. If keys contains additional KeyList or ThresholdKey</p><p>then M-of-M secondary KeyList or ThresholdKey signing requirements must be meet.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>fileID</td>
                  <td><a href="#proto.FileID">FileID</a></td>
                  <td></td>
                  <td><p>The file to which the bytes will be appended </p></td>
                </tr>
              
                <tr>
                  <td>contents</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The bytes that will be appended to the end of the specified file </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="file_create.proto">file_create.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.FileCreateTransactionBody">FileCreateTransactionBody</h3>
        <p>Create a new file, containing the given contents.</p><p>After the file is created, the FileID for it can be found in the receipt, or record, or retrieved</p><p>with a GetByKey query.</p><p>The file contains the specified contents (possibly empty). The file will automatically disappear</p><p>at the expirationTime, unless its expiration is extended by another transaction before that time.</p><p>If the file is deleted, then its contents will become empty and it will be marked as deleted</p><p>until it expires, and then it will cease to exist.</p><p>The keys field is a list of keys. All keys within the top-level key list must sign (M-M) to</p><p>create or modify a file. However, to delete the file, only one key (1-M) is required to sign from</p><p>the top-level key list.  Each of those "keys" may itself be threshold key containing other keys</p><p>(including other threshold keys). In other words, the behavior is an AND for create/modify, OR</p><p>for delete. This is useful for acting as a revocation server. If it is desired to have the</p><p>behavior be AND for all 3 operations (or OR for all 3), then the list should have only a single</p><p>Key, which is a threshold key, with N=1 for OR, N=M for AND.</p><p>If a file is created without ANY keys in the keys field, the file is immutable and ONLY the</p><p>expirationTime of the file can be changed with a FileUpdate transaction. The file contents or its</p><p>keys cannot be changed.</p><p>An entity (account, file, or smart contract instance) must be created in a particular realm. If</p><p>the realmID is left null, then a new realm will be created with the given admin key. If a new</p><p>realm has a null adminKey, then anyone can create/modify/delete entities in that realm. But if an</p><p>admin key is given, then any transaction to create/modify/delete an entity in that realm must be</p><p>signed by that key, though anyone can still call functions on smart contract instances that exist</p><p>in that realm. A realm ceases to exist when everything within it has expired and no longer</p><p>exists.</p><p>The current API ignores shardID, realmID, and newRealmAdminKey, and creates everything in shard 0</p><p>and realm 0, with a null key. Future versions of the API will support multiple realms and</p><p>multiple shards.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>expirationTime</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>The time at which this file should expire (unless FileUpdateTransaction is used before then
to extend its life) </p></td>
                </tr>
              
                <tr>
                  <td>keys</td>
                  <td><a href="#proto.KeyList">KeyList</a></td>
                  <td></td>
                  <td><p>All keys at the top level of a key list must sign to create or modify the file. Any one of
the keys at the top level key list can sign to delete the file. </p></td>
                </tr>
              
                <tr>
                  <td>contents</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The bytes that are the contents of the file </p></td>
                </tr>
              
                <tr>
                  <td>shardID</td>
                  <td><a href="#proto.ShardID">ShardID</a></td>
                  <td></td>
                  <td><p>Shard in which this file is created </p></td>
                </tr>
              
                <tr>
                  <td>realmID</td>
                  <td><a href="#proto.RealmID">RealmID</a></td>
                  <td></td>
                  <td><p>The Realm in which to the file is created (leave this null to create a new realm) </p></td>
                </tr>
              
                <tr>
                  <td>newRealmAdminKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>If realmID is null, then this the admin key for the new realm that will be created </p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The memo associated with the file (UTF-8 encoding max 100 bytes) </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="file_delete.proto">file_delete.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.FileDeleteTransactionBody">FileDeleteTransactionBody</h3>
        <p>Delete the given file. After deletion, it will be marked as deleted and will have no contents.</p><p>But information about it will continue to exist until it expires. A list of keys was given when</p><p>the file was created. All the top level keys on that list must sign transactions to create or</p><p>modify the file, but any single one of the top level keys can be used to delete the file. This</p><p>transaction must be signed by 1-of-M KeyList keys. If keys contains additional KeyList or</p><p>ThresholdKey then 1-of-M secondary KeyList or ThresholdKey signing requirements must be meet.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>fileID</td>
                  <td><a href="#proto.FileID">FileID</a></td>
                  <td></td>
                  <td><p>The file to delete. It will be marked as deleted until it expires. Then it will disappear. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="file_get_contents.proto">file_get_contents.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.FileGetContentsQuery">FileGetContentsQuery</h3>
        <p>Get the contents of a file. The content field is empty (no bytes) if the file is empty.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>Standard info sent from client to node, including the signed payment, and what kind of
response is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>fileID</td>
                  <td><a href="#proto.FileID">FileID</a></td>
                  <td></td>
                  <td><p>The file ID of the file whose contents are requested </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.FileGetContentsResponse">FileGetContentsResponse</h3>
        <p>Response when the client sends the node FileGetContentsQuery</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof,
or both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>fileContents</td>
                  <td><a href="#proto.FileGetContentsResponse.FileContents">FileGetContentsResponse.FileContents</a></td>
                  <td></td>
                  <td><p>the file ID and contents (a state proof can be generated for this) </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.FileGetContentsResponse.FileContents">FileGetContentsResponse.FileContents</h3>
        <p></p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>fileID</td>
                  <td><a href="#proto.FileID">FileID</a></td>
                  <td></td>
                  <td><p>The file ID of the file whose contents are being returned </p></td>
                </tr>
              
                <tr>
                  <td>contents</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The bytes contained in the file </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="file_get_info.proto">file_get_info.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.FileGetInfoQuery">FileGetInfoQuery</h3>
        <p>Get all of the information about a file, except for its contents. When a file expires, it no</p><p>longer exists, and there will be no info about it, and the fileInfo field will be blank. If a</p><p>transaction or smart contract deletes the file, but it has not yet expired, then the fileInfo</p><p>field will be non-empty, the deleted field will be true, its size will be 0, and its contents</p><p>will be empty.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>Standard info sent from client to node, including the signed payment, and what kind of
response is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>fileID</td>
                  <td><a href="#proto.FileID">FileID</a></td>
                  <td></td>
                  <td><p>The file ID of the file for which information is requested </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.FileGetInfoResponse">FileGetInfoResponse</h3>
        <p>Response when the client sends the node FileGetInfoQuery</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof,
or both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>fileInfo</td>
                  <td><a href="#proto.FileGetInfoResponse.FileInfo">FileGetInfoResponse.FileInfo</a></td>
                  <td></td>
                  <td><p>The information about the file </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.FileGetInfoResponse.FileInfo">FileGetInfoResponse.FileInfo</h3>
        <p></p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>fileID</td>
                  <td><a href="#proto.FileID">FileID</a></td>
                  <td></td>
                  <td><p>The file ID of the file for which information is requested </p></td>
                </tr>
              
                <tr>
                  <td>size</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>Number of bytes in contents </p></td>
                </tr>
              
                <tr>
                  <td>expirationTime</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>The current time at which this account is set to expire </p></td>
                </tr>
              
                <tr>
                  <td>deleted</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>True if deleted but not yet expired </p></td>
                </tr>
              
                <tr>
                  <td>keys</td>
                  <td><a href="#proto.KeyList">KeyList</a></td>
                  <td></td>
                  <td><p>One of these keys must sign in order to modify or delete the file </p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The memo associated with the file </p></td>
                </tr>
              
                <tr>
                  <td>ledger_id</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The ledger ID the response was returned from; please see &lt;a href=&#34;https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md&#34;&gt;HIP-198&lt;/a&gt; for the network-specific IDs. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="file_service.proto">file_service.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      

      

      

      
        <h3 id="proto.FileService">FileService</h3>
        <p>Transactions and queries for the file service.</p>
        <table class="enum-table">
          <thead>
            <tr><td>Method Name</td><td>Request Type</td><td>Response Type</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>createFile</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Creates a file</p></td>
              </tr>
            
              <tr>
                <td>updateFile</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Updates a file</p></td>
              </tr>
            
              <tr>
                <td>deleteFile</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Deletes a file</p></td>
              </tr>
            
              <tr>
                <td>appendContent</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Appends to a file</p></td>
              </tr>
            
              <tr>
                <td>getFileContent</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>Retrieves the file contents</p></td>
              </tr>
            
              <tr>
                <td>getFileInfo</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>Retrieves the file information</p></td>
              </tr>
            
              <tr>
                <td>systemDelete</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Deletes a file if the submitting account has network admin privileges</p></td>
              </tr>
            
              <tr>
                <td>systemUndelete</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Undeletes a file if the submitting account has network admin privileges</p></td>
              </tr>
            
          </tbody>
        </table>

        
    
      
      <div class="file-heading">
        <h2 id="file_update.proto">file_update.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.FileUpdateTransactionBody">FileUpdateTransactionBody</h3>
        <p>Modify the metadata and/or contents of a file. If a field is not set in the transaction body, the</p><p>corresponding file attribute will be unchanged. This transaction must be signed by all the keys</p><p>in the top level of a key list (M-of-M) of the file being updated. If the keys themselves are</p><p>being updated, then the transaction must also be signed by all the new keys. If the keys contain</p><p>additional KeyList or ThresholdKey then M-of-M secondary KeyList or ThresholdKey signing</p><p>requirements must be meet</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>fileID</td>
                  <td><a href="#proto.FileID">FileID</a></td>
                  <td></td>
                  <td><p>The ID of the file to update </p></td>
                </tr>
              
                <tr>
                  <td>expirationTime</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>The new expiry time (ignored if not later than the current expiry) </p></td>
                </tr>
              
                <tr>
                  <td>keys</td>
                  <td><a href="#proto.KeyList">KeyList</a></td>
                  <td></td>
                  <td><p>The new list of keys that can modify or delete the file </p></td>
                </tr>
              
                <tr>
                  <td>contents</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The new contents that should overwrite the file&#39;s current contents </p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#google.protobuf.StringValue">google.protobuf.StringValue</a></td>
                  <td></td>
                  <td><p>If set, the new memo to be associated with the file (UTF-8 encoding max 100 bytes) </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="freeze.proto">freeze.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.FreezeTransactionBody">FreezeTransactionBody</h3>
        <p>At consensus, sets the consensus time at which the platform should stop creating events and</p><p>accepting transactions, and enter a maintenance window.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>startHour</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> !! DEPRECATED and REJECTED by nodes
The start hour (in UTC time), a value between 0 and 23 </p></td>
                </tr>
              
                <tr>
                  <td>startMin</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> !! DEPRECATED and REJECTED by nodes
The start minute (in UTC time), a value between 0 and 59 </p></td>
                </tr>
              
                <tr>
                  <td>endHour</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> !! DEPRECATED and REJECTED by nodes
The end hour (in UTC time), a value between 0 and 23 </p></td>
                </tr>
              
                <tr>
                  <td>endMin</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> !! DEPRECATED and REJECTED by nodes
The end minute (in UTC time), a value between 0 and 59 </p></td>
                </tr>
              
                <tr>
                  <td>update_file</td>
                  <td><a href="#proto.FileID">FileID</a></td>
                  <td></td>
                  <td><p>If set, the file whose contents should be used for a network software update during the
maintenance window. </p></td>
                </tr>
              
                <tr>
                  <td>file_hash</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>If set, the expected hash of the contents of the update file (used to verify the update). </p></td>
                </tr>
              
                <tr>
                  <td>start_time</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>The consensus time at which the maintenance window should begin. </p></td>
                </tr>
              
                <tr>
                  <td>freeze_type</td>
                  <td><a href="#proto.FreezeType">FreezeType</a></td>
                  <td></td>
                  <td><p>The type of network freeze or upgrade operation to perform. </p></td>
                </tr>
              
            </tbody>
          </table>

          
            
            
            <h4>Fields with deprecated option</h4>
            <table>
              <thead>
                <tr>
                  <td>Name</td>
                  <td>Option</td>
                </tr>
              </thead>
              <tbody>
              
                <tr>
                  <td>startHour</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>startMin</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>endHour</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>endMin</td>
                  <td><p>true</p></td>
                </tr>
              
              </tbody>
            </table>
            
          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="freeze_service.proto">freeze_service.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      

      

      

      
        <h3 id="proto.FreezeService">FreezeService</h3>
        <p>The request and responses for freeze service.</p>
        <table class="enum-table">
          <thead>
            <tr><td>Method Name</td><td>Request Type</td><td>Response Type</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>freeze</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Freezes the nodes by submitting the transaction. The grpc server returns the
TransactionResponse</p></td>
              </tr>
            
          </tbody>
        </table>

        
    
      
      <div class="file-heading">
        <h2 id="freeze_type.proto">freeze_type.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      

      
        <h3 id="proto.FreezeType">FreezeType</h3>
        <p>The type of network freeze or upgrade operation to be performed. This type dictates which </p><p>fields are required.</p>
        <table class="enum-table">
          <thead>
            <tr><td>Name</td><td>Number</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>UNKNOWN_FREEZE_TYPE</td>
                <td>0</td>
                <td><p>An (invalid) default value for this enum, to ensure the client explicitly sets 
the intended type of freeze transaction.</p></td>
              </tr>
            
              <tr>
                <td>FREEZE_ONLY</td>
                <td>1</td>
                <td><p>Freezes the network at the specified time. The start_time field must be provided and 
must reference a future time. Any values specified for the update_file and file_hash 
fields will be ignored. This transaction does not perform any network changes or 
upgrades and requires manual intervention to restart the network.</p></td>
              </tr>
            
              <tr>
                <td>PREPARE_UPGRADE</td>
                <td>2</td>
                <td><p>A non-freezing operation that initiates network wide preparation in advance of a 
scheduled freeze upgrade. The update_file and file_hash fields must be provided and 
valid. The start_time field may be omitted and any value present will be ignored.</p></td>
              </tr>
            
              <tr>
                <td>FREEZE_UPGRADE</td>
                <td>3</td>
                <td><p>Freezes the network at the specified time and performs the previously prepared 
automatic upgrade across the entire network.</p></td>
              </tr>
            
              <tr>
                <td>FREEZE_ABORT</td>
                <td>4</td>
                <td><p>Aborts a pending network freeze operation.</p></td>
              </tr>
            
              <tr>
                <td>TELEMETRY_UPGRADE</td>
                <td>5</td>
                <td><p>Performs an immediate upgrade on auxilary services and containers providing 
telemetry/metrics. Does not impact network operations.</p></td>
              </tr>
            
          </tbody>
        </table>
      

      

      
    
      
      <div class="file-heading">
        <h2 id="get_account_details.proto">get_account_details.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.GetAccountDetailsQuery">GetAccountDetailsQuery</h3>
        <p>Gets all the information about an account, including balance and allowances. This does not get the list of</p><p>account records.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>Account details sent from client to node, including the signed payment, and what kind of
response is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>account_id</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account ID for which information is requested </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.GetAccountDetailsResponse">GetAccountDetailsResponse</h3>
        <p>Response when the client sends the node GetAccountDetailsQuery</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof,
or both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>account_details</td>
                  <td><a href="#proto.GetAccountDetailsResponse.AccountDetails">GetAccountDetailsResponse.AccountDetails</a></td>
                  <td></td>
                  <td><p>Details of the account (a state proof can be generated for this) </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.GetAccountDetailsResponse.AccountDetails">GetAccountDetailsResponse.AccountDetails</h3>
        <p></p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>account_id</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account ID for which this information applies </p></td>
                </tr>
              
                <tr>
                  <td>contract_account_id</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The Contract Account ID comprising of both the contract instance and the cryptocurrency
account owned by the contract instance, in the format used by Solidity </p></td>
                </tr>
              
                <tr>
                  <td>deleted</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>If true, then this account has been deleted, it will disappear when it expires, and all
transactions for it will fail except the transaction to extend its expiration date </p></td>
                </tr>
              
                <tr>
                  <td>proxy_account_id</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> [Deprecated] The Account ID of the account to which this is proxy staked. If proxyAccountID is null,
or is an invalid account, or is an account that isn&#39;t a node, then this account is
automatically proxy staked to a node chosen by the network, but without earning payments.
If the proxyAccountID account refuses to accept proxy staking , or if it is not currently
running a node, then it will behave as if proxyAccountID was null. </p></td>
                </tr>
              
                <tr>
                  <td>proxy_received</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The total number of tinybars proxy staked to this account </p></td>
                </tr>
              
                <tr>
                  <td>key</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The key for the account, which must sign in order to transfer out, or to modify the
account in any way other than extending its expiration date. </p></td>
                </tr>
              
                <tr>
                  <td>balance</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>The current balance of account in tinybars </p></td>
                </tr>
              
                <tr>
                  <td>receiver_sig_required</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>If true, no transaction can transfer to this account unless signed by this account&#39;s key </p></td>
                </tr>
              
                <tr>
                  <td>expiration_time</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>The TimeStamp time at which this account is set to expire </p></td>
                </tr>
              
                <tr>
                  <td>auto_renew_period</td>
                  <td><a href="#proto.Duration">Duration</a></td>
                  <td></td>
                  <td><p>The duration for expiration time will extend every this many seconds. If there are
insufficient funds, then it extends as long as possible. If it is empty when it expires,
then it is deleted. </p></td>
                </tr>
              
                <tr>
                  <td>token_relationships</td>
                  <td><a href="#proto.TokenRelationship">TokenRelationship</a></td>
                  <td>repeated</td>
                  <td><p>All tokens related to this account </p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The memo associated with the account </p></td>
                </tr>
              
                <tr>
                  <td>owned_nfts</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The number of NFTs owned by this account </p></td>
                </tr>
              
                <tr>
                  <td>max_automatic_token_associations</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p>The maximum number of tokens that an Account can be implicitly associated with. </p></td>
                </tr>
              
                <tr>
                  <td>alias</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The alias of this account </p></td>
                </tr>
              
                <tr>
                  <td>ledger_id</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The ledger ID the response was returned from; please see &lt;a href=&#34;https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md&#34;&gt;HIP-198&lt;/a&gt; for the network-specific IDs. </p></td>
                </tr>
              
                <tr>
                  <td>granted_crypto_allowances</td>
                  <td><a href="#proto.GrantedCryptoAllowance">GrantedCryptoAllowance</a></td>
                  <td>repeated</td>
                  <td><p>All of the hbar allowances approved by the account owner. </p></td>
                </tr>
              
                <tr>
                  <td>granted_nft_allowances</td>
                  <td><a href="#proto.GrantedNftAllowance">GrantedNftAllowance</a></td>
                  <td>repeated</td>
                  <td><p>All of the non-fungible token allowances approved by the account owner. </p></td>
                </tr>
              
                <tr>
                  <td>granted_token_allowances</td>
                  <td><a href="#proto.GrantedTokenAllowance">GrantedTokenAllowance</a></td>
                  <td>repeated</td>
                  <td><p>All of the fungible token allowances approved by the account owner. </p></td>
                </tr>
              
            </tbody>
          </table>

          
            
            
            <h4>Fields with deprecated option</h4>
            <table>
              <thead>
                <tr>
                  <td>Name</td>
                  <td>Option</td>
                </tr>
              </thead>
              <tbody>
              
                <tr>
                  <td>proxy_account_id</td>
                  <td><p>true</p></td>
                </tr>
              
              </tbody>
            </table>
            
          

        
      
        <h3 id="proto.GrantedCryptoAllowance">GrantedCryptoAllowance</h3>
        <p>A granted allowance of hbar transfers for a spender relative to the owner account.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>spender</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account ID of the spender of the hbar allowance. </p></td>
                </tr>
              
                <tr>
                  <td>amount</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The amount of the spender&#39;s allowance in tinybars. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.GrantedNftAllowance">GrantedNftAllowance</h3>
        <p>A granted allowance for all the NFTs of a token for a spender relative to the owner account.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>token_id</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The token that the allowance pertains to. </p></td>
                </tr>
              
                <tr>
                  <td>spender</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account ID of the spender that has been granted access to all NFTs of the owner </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.GrantedTokenAllowance">GrantedTokenAllowance</h3>
        <p>A granted allowance of fungible token transfers for a spender relative to the owner account.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>token_id</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The token that the allowance pertains to. </p></td>
                </tr>
              
                <tr>
                  <td>spender</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account ID of the token allowance spender. </p></td>
                </tr>
              
                <tr>
                  <td>amount</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The amount of the spender&#39;s token allowance. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="get_by_key.proto">get_by_key.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.EntityID">EntityID</h3>
        <p>the ID for a single entity (account, livehash, file, or smart contract instance)</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>accountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The Account ID for the cryptocurrency account </p></td>
                </tr>
              
                <tr>
                  <td>liveHash</td>
                  <td><a href="#proto.LiveHash">LiveHash</a></td>
                  <td></td>
                  <td><p>A uniquely identifying livehash of an acount </p></td>
                </tr>
              
                <tr>
                  <td>fileID</td>
                  <td><a href="#proto.FileID">FileID</a></td>
                  <td></td>
                  <td><p>The file ID of the file </p></td>
                </tr>
              
                <tr>
                  <td>contractID</td>
                  <td><a href="#proto.ContractID">ContractID</a></td>
                  <td></td>
                  <td><p>The smart contract ID that identifies instance </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.GetByKeyQuery">GetByKeyQuery</h3>
        <p>Get all accounts, claims, files, and smart contract instances whose associated keys include the</p><p>given Key. The given Key must not be a contractID or a ThresholdKey. This is not yet implemented</p><p>in the API, but will be in the future.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>Standard info sent from client to node, including the signed payment, and what kind of
response is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>key</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The key to search for. It must not contain a contractID nor a ThresholdSignature. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.GetByKeyResponse">GetByKeyResponse</h3>
        <p>Response when the client sends the node GetByKeyQuery</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof,
or both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>entities</td>
                  <td><a href="#proto.EntityID">EntityID</a></td>
                  <td>repeated</td>
                  <td><p>The list of entities that include this public key in their associated Key list </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="get_by_solidity_id.proto">get_by_solidity_id.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.GetBySolidityIDQuery">GetBySolidityIDQuery</h3>
        <p>Get the IDs in the format used by transactions, given the ID in the format used by Solidity. If</p><p>the Solidity ID is for a smart contract instance, then both the ContractID and associated</p><p>AccountID will be returned.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>Standard info sent from client to node, including the signed payment, and what kind of
response is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>solidityID</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The ID in the format used by Solidity </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.GetBySolidityIDResponse">GetBySolidityIDResponse</h3>
        <p>Response when the client sends the node GetBySolidityIDQuery</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof,
or both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>accountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The Account ID for the cryptocurrency account </p></td>
                </tr>
              
                <tr>
                  <td>fileID</td>
                  <td><a href="#proto.FileID">FileID</a></td>
                  <td></td>
                  <td><p>The file Id for the file </p></td>
                </tr>
              
                <tr>
                  <td>contractID</td>
                  <td><a href="#proto.ContractID">ContractID</a></td>
                  <td></td>
                  <td><p>A smart contract ID for the instance (if this is included, then the associated accountID will
also be included) </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="network_get_execution_time.proto">network_get_execution_time.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.NetworkGetExecutionTimeQuery">NetworkGetExecutionTimeQuery</h3>
        <p>Gets the time in nanoseconds spent in <tt>handleTransaction</tt> for one or more </p><p>TransactionIDs (assuming they have reached consensus "recently", since only a limited </p><p>number of execution times are kept in-memory, depending on the value of the node-local </p><p>property <tt>stats.executionTimesToTrack</tt>).</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>standard info sent from client to node including the signed payment, and what kind of response
is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>transaction_ids</td>
                  <td><a href="#proto.TransactionID">TransactionID</a></td>
                  <td>repeated</td>
                  <td><p>The id(s) of the transactions to get the execution time(s) of </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.NetworkGetExecutionTimeResponse">NetworkGetExecutionTimeResponse</h3>
        <p>Response when the client sends the node NetworkGetExecutionTimeQuery; returns</p><p>INVALID_TRANSACTION_ID if any of the given TransactionIDs do not have available</p><p>execution times in the answering node.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof,
or both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>execution_times</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td>repeated</td>
                  <td><p>The execution time(s) of the requested TransactionIDs, if available </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="network_get_version_info.proto">network_get_version_info.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.NetworkGetVersionInfoQuery">NetworkGetVersionInfoQuery</h3>
        <p>Get the deployed versions of Hedera Services and the HAPI proto in semantic version format</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>Standard info sent from client to node, including the signed payment, and what kind of
response is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.NetworkGetVersionInfoResponse">NetworkGetVersionInfoResponse</h3>
        <p>Response when the client sends the node NetworkGetVersionInfoQuery</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof,
or both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>hapiProtoVersion</td>
                  <td><a href="#proto.SemanticVersion">SemanticVersion</a></td>
                  <td></td>
                  <td><p>The Hedera API (HAPI) protobuf version recognized by the responding node. </p></td>
                </tr>
              
                <tr>
                  <td>hederaServicesVersion</td>
                  <td><a href="#proto.SemanticVersion">SemanticVersion</a></td>
                  <td></td>
                  <td><p>The version of the Hedera Services software deployed on the responding node. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="network_service.proto">network_service.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      

      

      

      
        <h3 id="proto.NetworkService">NetworkService</h3>
        <p>The requests and responses for different network services.</p>
        <table class="enum-table">
          <thead>
            <tr><td>Method Name</td><td>Request Type</td><td>Response Type</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>getVersionInfo</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>Retrieves the active versions of Hedera Services and HAPI proto</p></td>
              </tr>
            
              <tr>
                <td>getExecutionTime</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>Retrieves the time in nanoseconds spent in &lt;tt&gt;handleTransaction&lt;/tt&gt; for one or more 
TransactionIDs (assuming they have reached consensus &#34;recently&#34;, since only a limited 
number of execution times are kept in-memory, depending on the value of the node-local 
property &lt;tt&gt;stats.executionTimesToTrack&lt;/tt&gt;).</p></td>
              </tr>
            
              <tr>
                <td>uncheckedSubmit</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Submits a &#34;wrapped&#34; transaction to the network, skipping its standard prechecks. (Note that
the &#34;wrapper&#34; &lt;tt&gt;UncheckedSubmit&lt;/tt&gt; transaction is still subject to normal prechecks,
including an authorization requirement that its payer be either the treasury or system admin
account.)</p></td>
              </tr>
            
              <tr>
                <td>getAccountDetails</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>Get all the information about an account, including balance and allowances. This does not get the list of
account records.</p></td>
              </tr>
            
          </tbody>
        </table>

        
    
      
      <div class="file-heading">
        <h2 id="node_stake_update.proto">node_stake_update.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.NodeStake">NodeStake</h3>
        <p>Staking info for each node at the end of a staking period.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>max_stake</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The maximum stake (rewarded or not rewarded) this node can have as consensus weight. If its stake to
reward is above this maximum at the start of a period, then accounts staking to the node in that 
period will be rewarded at a lower rate scaled by (maxStake / stakeRewardStart). </p></td>
                </tr>
              
                <tr>
                  <td>min_stake</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The minimum stake (rewarded or not rewarded) this node must reach before having non-zero consensus weight.
If its total stake is below this minimum at the start of a period, then accounts staking to the node in 
that period will receive no rewards. </p></td>
                </tr>
              
                <tr>
                  <td>node_id</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The id of this node. </p></td>
                </tr>
              
                <tr>
                  <td>reward_rate</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The reward rate _per whole hbar_ that was staked to this node with declineReward=false from the start of 
the staking period that is ending. </p></td>
                </tr>
              
                <tr>
                  <td>stake</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>Consensus weight of this node for the new staking period. </p></td>
                </tr>
              
                <tr>
                  <td>stake_not_rewarded</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>Total of (balance &#43; stakedToMe) for all accounts staked to this node with declineReward=true, at the 
beginning of the new staking period. </p></td>
                </tr>
              
                <tr>
                  <td>stake_rewarded</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>Total of (balance &#43; stakedToMe) for all accounts staked to this node with declineReward=false, at the 
beginning of the new staking period. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.NodeStakeUpdateTransactionBody">NodeStakeUpdateTransactionBody</h3>
        <p>Updates the staking info at the end of staking period to indicate new staking period has started.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>end_of_staking_period</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>Time and date of the end of the staking period that is ending </p></td>
                </tr>
              
                <tr>
                  <td>node_stake</td>
                  <td><a href="#proto.NodeStake">NodeStake</a></td>
                  <td>repeated</td>
                  <td><p>Staking info of each node at the beginning of the new staking period </p></td>
                </tr>
              
                <tr>
                  <td>max_staking_reward_rate_per_hbar</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The maximum reward rate, in tinybars per whole hbar, that any account can receive in a day. </p></td>
                </tr>
              
                <tr>
                  <td>node_reward_fee_fraction</td>
                  <td><a href="#proto.Fraction">Fraction</a></td>
                  <td></td>
                  <td><p>The fraction of the network and service fees paid to the node reward account 0.0.801. </p></td>
                </tr>
              
                <tr>
                  <td>staking_periods_stored</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The maximum number of trailing periods for which a user can collect rewards. For example, if this
is 365 with a UTC calendar day period, then users must collect rewards at least once per calendar
year to avoid missing any value. </p></td>
                </tr>
              
                <tr>
                  <td>staking_period</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The number of minutes in a staking period. Note for the special case of 1440 minutes, periods are 
treated as UTC calendar days, rather than repeating 1440 minute periods left-aligned at the epoch. </p></td>
                </tr>
              
                <tr>
                  <td>staking_reward_fee_fraction</td>
                  <td><a href="#proto.Fraction">Fraction</a></td>
                  <td></td>
                  <td><p>The fraction of the network and service fees paid to the staking reward account 0.0.800. </p></td>
                </tr>
              
                <tr>
                  <td>staking_start_threshold</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The minimum balance of staking reward account 0.0.800 required to active rewards. </p></td>
                </tr>
              
                <tr>
                  <td>staking_reward_rate</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The total number of tinybars to be distributed as staking rewards each period. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="prng.proto">prng.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.PrngTransactionBody">PrngTransactionBody</h3>
        <p>Generates a pseudorandom number</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>range</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p>If provided and is positive, returns a 32-bit pseudorandom number from the given range in the transaction record.
If not set or set to zero, will return a 384-bit pseudorandom number in the record. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="query.proto">query.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.Query">Query</h3>
        <p>A single query, which is sent from the client to a node. This includes all possible queries. Each</p><p>Query should not have more than 50 levels.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>getByKey</td>
                  <td><a href="#proto.GetByKeyQuery">GetByKeyQuery</a></td>
                  <td></td>
                  <td><p>Get all entities associated with a given key </p></td>
                </tr>
              
                <tr>
                  <td>getBySolidityID</td>
                  <td><a href="#proto.GetBySolidityIDQuery">GetBySolidityIDQuery</a></td>
                  <td></td>
                  <td><p>Get the IDs in the format used in transactions, given the format used in Solidity </p></td>
                </tr>
              
                <tr>
                  <td>contractCallLocal</td>
                  <td><a href="#proto.ContractCallLocalQuery">ContractCallLocalQuery</a></td>
                  <td></td>
                  <td><p>Call a function of a smart contract instance </p></td>
                </tr>
              
                <tr>
                  <td>contractGetInfo</td>
                  <td><a href="#proto.ContractGetInfoQuery">ContractGetInfoQuery</a></td>
                  <td></td>
                  <td><p>Get information about a smart contract instance </p></td>
                </tr>
              
                <tr>
                  <td>contractGetBytecode</td>
                  <td><a href="#proto.ContractGetBytecodeQuery">ContractGetBytecodeQuery</a></td>
                  <td></td>
                  <td><p>Get runtime code used by a smart contract instance </p></td>
                </tr>
              
                <tr>
                  <td>ContractGetRecords</td>
                  <td><a href="#proto.ContractGetRecordsQuery">ContractGetRecordsQuery</a></td>
                  <td></td>
                  <td><p>Get Records of the contract instance </p></td>
                </tr>
              
                <tr>
                  <td>cryptogetAccountBalance</td>
                  <td><a href="#proto.CryptoGetAccountBalanceQuery">CryptoGetAccountBalanceQuery</a></td>
                  <td></td>
                  <td><p>Get the current balance in a cryptocurrency account </p></td>
                </tr>
              
                <tr>
                  <td>cryptoGetAccountRecords</td>
                  <td><a href="#proto.CryptoGetAccountRecordsQuery">CryptoGetAccountRecordsQuery</a></td>
                  <td></td>
                  <td><p>Get all the records that currently exist for transactions involving an account </p></td>
                </tr>
              
                <tr>
                  <td>cryptoGetInfo</td>
                  <td><a href="#proto.CryptoGetInfoQuery">CryptoGetInfoQuery</a></td>
                  <td></td>
                  <td><p>Get all information about an account </p></td>
                </tr>
              
                <tr>
                  <td>cryptoGetLiveHash</td>
                  <td><a href="#proto.CryptoGetLiveHashQuery">CryptoGetLiveHashQuery</a></td>
                  <td></td>
                  <td><p>Get a single livehash from a single account, if present </p></td>
                </tr>
              
                <tr>
                  <td>cryptoGetProxyStakers</td>
                  <td><a href="#proto.CryptoGetStakersQuery">CryptoGetStakersQuery</a></td>
                  <td></td>
                  <td><p>Get all the accounts that proxy stake to a given account, and how much they proxy stake
(not yet implemented in the current API) </p></td>
                </tr>
              
                <tr>
                  <td>fileGetContents</td>
                  <td><a href="#proto.FileGetContentsQuery">FileGetContentsQuery</a></td>
                  <td></td>
                  <td><p>Get the contents of a file (the bytes stored in it) </p></td>
                </tr>
              
                <tr>
                  <td>fileGetInfo</td>
                  <td><a href="#proto.FileGetInfoQuery">FileGetInfoQuery</a></td>
                  <td></td>
                  <td><p>Get information about a file, such as its expiration date </p></td>
                </tr>
              
                <tr>
                  <td>transactionGetReceipt</td>
                  <td><a href="#proto.TransactionGetReceiptQuery">TransactionGetReceiptQuery</a></td>
                  <td></td>
                  <td><p>Get a receipt for a transaction (lasts 180 seconds) </p></td>
                </tr>
              
                <tr>
                  <td>transactionGetRecord</td>
                  <td><a href="#proto.TransactionGetRecordQuery">TransactionGetRecordQuery</a></td>
                  <td></td>
                  <td><p>Get a record for a transaction </p></td>
                </tr>
              
                <tr>
                  <td>transactionGetFastRecord</td>
                  <td><a href="#proto.TransactionGetFastRecordQuery">TransactionGetFastRecordQuery</a></td>
                  <td></td>
                  <td><p>Get a record for a transaction (lasts 180 seconds) </p></td>
                </tr>
              
                <tr>
                  <td>consensusGetTopicInfo</td>
                  <td><a href="#proto.ConsensusGetTopicInfoQuery">ConsensusGetTopicInfoQuery</a></td>
                  <td></td>
                  <td><p>Get the parameters of and state of a consensus topic. </p></td>
                </tr>
              
                <tr>
                  <td>networkGetVersionInfo</td>
                  <td><a href="#proto.NetworkGetVersionInfoQuery">NetworkGetVersionInfoQuery</a></td>
                  <td></td>
                  <td><p>Get the versions of the HAPI protobuf and Hedera Services software deployed on the
responding node. </p></td>
                </tr>
              
                <tr>
                  <td>tokenGetInfo</td>
                  <td><a href="#proto.TokenGetInfoQuery">TokenGetInfoQuery</a></td>
                  <td></td>
                  <td><p>Get all information about a token </p></td>
                </tr>
              
                <tr>
                  <td>scheduleGetInfo</td>
                  <td><a href="#proto.ScheduleGetInfoQuery">ScheduleGetInfoQuery</a></td>
                  <td></td>
                  <td><p>Get all information about a scheduled entity </p></td>
                </tr>
              
                <tr>
                  <td>tokenGetAccountNftInfos</td>
                  <td><a href="#proto.TokenGetAccountNftInfosQuery">TokenGetAccountNftInfosQuery</a></td>
                  <td></td>
                  <td><p>Get a list of NFTs associated with the account </p></td>
                </tr>
              
                <tr>
                  <td>tokenGetNftInfo</td>
                  <td><a href="#proto.TokenGetNftInfoQuery">TokenGetNftInfoQuery</a></td>
                  <td></td>
                  <td><p>Get all information about a NFT </p></td>
                </tr>
              
                <tr>
                  <td>tokenGetNftInfos</td>
                  <td><a href="#proto.TokenGetNftInfosQuery">TokenGetNftInfosQuery</a></td>
                  <td></td>
                  <td><p>Get a list of NFTs for the token </p></td>
                </tr>
              
                <tr>
                  <td>networkGetExecutionTime</td>
                  <td><a href="#proto.NetworkGetExecutionTimeQuery">NetworkGetExecutionTimeQuery</a></td>
                  <td></td>
                  <td><p>Gets &lt;tt&gt;handleTransaction&lt;/tt&gt; times for one or more &#34;sufficiently recent&#34; TransactionIDs </p></td>
                </tr>
              
                <tr>
                  <td>accountDetails</td>
                  <td><a href="#proto.GetAccountDetailsQuery">GetAccountDetailsQuery</a></td>
                  <td></td>
                  <td><p>Gets all information about an account including allowances granted by the account </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="query_header.proto">query_header.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.QueryHeader">QueryHeader</h3>
        <p>Each query from the client to the node will contain the QueryHeader, which gives the requested</p><p>response type, and includes a payment transaction that will compensate the node for responding to</p><p>the query. The payment can be blank if the query is free.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>payment</td>
                  <td><a href="#proto.Transaction">Transaction</a></td>
                  <td></td>
                  <td><p>A signed CryptoTransferTransaction to pay the node a fee for handling this query </p></td>
                </tr>
              
                <tr>
                  <td>responseType</td>
                  <td><a href="#proto.ResponseType">ResponseType</a></td>
                  <td></td>
                  <td><p>The requested response, asking for cost, state proof, both, or neither </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      
        <h3 id="proto.ResponseType">ResponseType</h3>
        <p>The client uses the ResponseType to indicate that it desires the node send just the answer, or</p><p>both the answer and a state proof. It can also ask for just the cost and not the answer itself</p><p>(allowing it to tailor the payment transaction accordingly). If the payment in the query fails</p><p>the precheck, then the response may have some fields blank. The state proof is only available for</p><p>some types of information. It is available for a Record, but not a receipt. It is available for</p><p>the information in each kind of *GetInfo request.</p>
        <table class="enum-table">
          <thead>
            <tr><td>Name</td><td>Number</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>ANSWER_ONLY</td>
                <td>0</td>
                <td><p>Response returns answer</p></td>
              </tr>
            
              <tr>
                <td>ANSWER_STATE_PROOF</td>
                <td>1</td>
                <td><p>(NOT YET SUPPORTED) Response returns both answer and state proof</p></td>
              </tr>
            
              <tr>
                <td>COST_ANSWER</td>
                <td>2</td>
                <td><p>Response returns the cost of answer</p></td>
              </tr>
            
              <tr>
                <td>COST_ANSWER_STATE_PROOF</td>
                <td>3</td>
                <td><p>(NOT YET SUPPORTED) Response returns the total cost of answer and state proof</p></td>
              </tr>
            
          </tbody>
        </table>
      

      

      
    
      
      <div class="file-heading">
        <h2 id="response.proto">response.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.Response">Response</h3>
        <p>A single response, which is returned from the node to the client, after the client sent the node</p><p>a query. This includes all responses.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>getByKey</td>
                  <td><a href="#proto.GetByKeyResponse">GetByKeyResponse</a></td>
                  <td></td>
                  <td><p>Get all entities associated with a given key </p></td>
                </tr>
              
                <tr>
                  <td>getBySolidityID</td>
                  <td><a href="#proto.GetBySolidityIDResponse">GetBySolidityIDResponse</a></td>
                  <td></td>
                  <td><p>Get the IDs in the format used in transactions, given the format used in Solidity </p></td>
                </tr>
              
                <tr>
                  <td>contractCallLocal</td>
                  <td><a href="#proto.ContractCallLocalResponse">ContractCallLocalResponse</a></td>
                  <td></td>
                  <td><p>Response to call a function of a smart contract instance </p></td>
                </tr>
              
                <tr>
                  <td>contractGetBytecodeResponse</td>
                  <td><a href="#proto.ContractGetBytecodeResponse">ContractGetBytecodeResponse</a></td>
                  <td></td>
                  <td><p>Get the runtime code for a smart contract instance </p></td>
                </tr>
              
                <tr>
                  <td>contractGetInfo</td>
                  <td><a href="#proto.ContractGetInfoResponse">ContractGetInfoResponse</a></td>
                  <td></td>
                  <td><p>Get information about a smart contract instance </p></td>
                </tr>
              
                <tr>
                  <td>contractGetRecordsResponse</td>
                  <td><a href="#proto.ContractGetRecordsResponse">ContractGetRecordsResponse</a></td>
                  <td></td>
                  <td><p>Get all existing records for a smart contract instance </p></td>
                </tr>
              
                <tr>
                  <td>cryptogetAccountBalance</td>
                  <td><a href="#proto.CryptoGetAccountBalanceResponse">CryptoGetAccountBalanceResponse</a></td>
                  <td></td>
                  <td><p>Get the current balance in a cryptocurrency account </p></td>
                </tr>
              
                <tr>
                  <td>cryptoGetAccountRecords</td>
                  <td><a href="#proto.CryptoGetAccountRecordsResponse">CryptoGetAccountRecordsResponse</a></td>
                  <td></td>
                  <td><p>Get all the records that currently exist for transactions involving an account </p></td>
                </tr>
              
                <tr>
                  <td>cryptoGetInfo</td>
                  <td><a href="#proto.CryptoGetInfoResponse">CryptoGetInfoResponse</a></td>
                  <td></td>
                  <td><p>Get all information about an account </p></td>
                </tr>
              
                <tr>
                  <td>cryptoGetLiveHash</td>
                  <td><a href="#proto.CryptoGetLiveHashResponse">CryptoGetLiveHashResponse</a></td>
                  <td></td>
                  <td><p>Contains a livehash associated to an account </p></td>
                </tr>
              
                <tr>
                  <td>cryptoGetProxyStakers</td>
                  <td><a href="#proto.CryptoGetStakersResponse">CryptoGetStakersResponse</a></td>
                  <td></td>
                  <td><p>Get all the accounts that proxy stake to a given account, and how much they proxy stake </p></td>
                </tr>
              
                <tr>
                  <td>fileGetContents</td>
                  <td><a href="#proto.FileGetContentsResponse">FileGetContentsResponse</a></td>
                  <td></td>
                  <td><p>Get the contents of a file (the bytes stored in it) </p></td>
                </tr>
              
                <tr>
                  <td>fileGetInfo</td>
                  <td><a href="#proto.FileGetInfoResponse">FileGetInfoResponse</a></td>
                  <td></td>
                  <td><p>Get information about a file, such as its expiration date </p></td>
                </tr>
              
                <tr>
                  <td>transactionGetReceipt</td>
                  <td><a href="#proto.TransactionGetReceiptResponse">TransactionGetReceiptResponse</a></td>
                  <td></td>
                  <td><p>Get a receipt for a transaction </p></td>
                </tr>
              
                <tr>
                  <td>transactionGetRecord</td>
                  <td><a href="#proto.TransactionGetRecordResponse">TransactionGetRecordResponse</a></td>
                  <td></td>
                  <td><p>Get a record for a transaction </p></td>
                </tr>
              
                <tr>
                  <td>transactionGetFastRecord</td>
                  <td><a href="#proto.TransactionGetFastRecordResponse">TransactionGetFastRecordResponse</a></td>
                  <td></td>
                  <td><p>Get a record for a transaction (lasts 180 seconds) </p></td>
                </tr>
              
                <tr>
                  <td>consensusGetTopicInfo</td>
                  <td><a href="#proto.ConsensusGetTopicInfoResponse">ConsensusGetTopicInfoResponse</a></td>
                  <td></td>
                  <td><p>Parameters of and state of a consensus topic.. </p></td>
                </tr>
              
                <tr>
                  <td>networkGetVersionInfo</td>
                  <td><a href="#proto.NetworkGetVersionInfoResponse">NetworkGetVersionInfoResponse</a></td>
                  <td></td>
                  <td><p>Semantic versions of Hedera Services and HAPI proto </p></td>
                </tr>
              
                <tr>
                  <td>tokenGetInfo</td>
                  <td><a href="#proto.TokenGetInfoResponse">TokenGetInfoResponse</a></td>
                  <td></td>
                  <td><p>Get all information about a token </p></td>
                </tr>
              
                <tr>
                  <td>scheduleGetInfo</td>
                  <td><a href="#proto.ScheduleGetInfoResponse">ScheduleGetInfoResponse</a></td>
                  <td></td>
                  <td><p>Get all information about a schedule entity </p></td>
                </tr>
              
                <tr>
                  <td>tokenGetAccountNftInfos</td>
                  <td><a href="#proto.TokenGetAccountNftInfosResponse">TokenGetAccountNftInfosResponse</a></td>
                  <td></td>
                  <td><p>A list of the NFTs associated with the account </p></td>
                </tr>
              
                <tr>
                  <td>tokenGetNftInfo</td>
                  <td><a href="#proto.TokenGetNftInfoResponse">TokenGetNftInfoResponse</a></td>
                  <td></td>
                  <td><p>All information about an NFT </p></td>
                </tr>
              
                <tr>
                  <td>tokenGetNftInfos</td>
                  <td><a href="#proto.TokenGetNftInfosResponse">TokenGetNftInfosResponse</a></td>
                  <td></td>
                  <td><p>A list of the NFTs for the token </p></td>
                </tr>
              
                <tr>
                  <td>networkGetExecutionTime</td>
                  <td><a href="#proto.NetworkGetExecutionTimeResponse">NetworkGetExecutionTimeResponse</a></td>
                  <td></td>
                  <td><p>Execution times of &#34;sufficiently recent&#34; transactions </p></td>
                </tr>
              
                <tr>
                  <td>accountDetails</td>
                  <td><a href="#proto.GetAccountDetailsResponse">GetAccountDetailsResponse</a></td>
                  <td></td>
                  <td><p>Gets all information about an account including allowances granted by the account </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="response_code.proto">response_code.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      

      
        <h3 id="proto.ResponseCodeEnum">ResponseCodeEnum</h3>
        <p>UNDOCUMENTED</p>
        <table class="enum-table">
          <thead>
            <tr><td>Name</td><td>Number</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>OK</td>
                <td>0</td>
                <td><p>The transaction passed the precheck validations.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_TRANSACTION</td>
                <td>1</td>
                <td><p>For any error not handled by specific error codes listed below.</p></td>
              </tr>
            
              <tr>
                <td>PAYER_ACCOUNT_NOT_FOUND</td>
                <td>2</td>
                <td><p>Payer account does not exist.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_NODE_ACCOUNT</td>
                <td>3</td>
                <td><p>Node Account provided does not match the node account of the node the transaction was submitted
to.</p></td>
              </tr>
            
              <tr>
                <td>TRANSACTION_EXPIRED</td>
                <td>4</td>
                <td><p>Pre-Check error when TransactionValidStart &#43; transactionValidDuration is less than current
consensus time.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_TRANSACTION_START</td>
                <td>5</td>
                <td><p>Transaction start time is greater than current consensus time</p></td>
              </tr>
            
              <tr>
                <td>INVALID_TRANSACTION_DURATION</td>
                <td>6</td>
                <td><p>The given transactionValidDuration was either non-positive, or greater than the maximum 
valid duration of 180 secs.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_SIGNATURE</td>
                <td>7</td>
                <td><p>The transaction signature is not valid</p></td>
              </tr>
            
              <tr>
                <td>MEMO_TOO_LONG</td>
                <td>8</td>
                <td><p>Transaction memo size exceeded 100 bytes</p></td>
              </tr>
            
              <tr>
                <td>INSUFFICIENT_TX_FEE</td>
                <td>9</td>
                <td><p>The fee provided in the transaction is insufficient for this type of transaction</p></td>
              </tr>
            
              <tr>
                <td>INSUFFICIENT_PAYER_BALANCE</td>
                <td>10</td>
                <td><p>The payer account has insufficient cryptocurrency to pay the transaction fee</p></td>
              </tr>
            
              <tr>
                <td>DUPLICATE_TRANSACTION</td>
                <td>11</td>
                <td><p>This transaction ID is a duplicate of one that was submitted to this node or reached consensus
in the last 180 seconds (receipt period)</p></td>
              </tr>
            
              <tr>
                <td>BUSY</td>
                <td>12</td>
                <td><p>If API is throttled out</p></td>
              </tr>
            
              <tr>
                <td>NOT_SUPPORTED</td>
                <td>13</td>
                <td><p>The API is not currently supported</p></td>
              </tr>
            
              <tr>
                <td>INVALID_FILE_ID</td>
                <td>14</td>
                <td><p>The file id is invalid or does not exist</p></td>
              </tr>
            
              <tr>
                <td>INVALID_ACCOUNT_ID</td>
                <td>15</td>
                <td><p>The account id is invalid or does not exist</p></td>
              </tr>
            
              <tr>
                <td>INVALID_CONTRACT_ID</td>
                <td>16</td>
                <td><p>The contract id is invalid or does not exist</p></td>
              </tr>
            
              <tr>
                <td>INVALID_TRANSACTION_ID</td>
                <td>17</td>
                <td><p>Transaction id is not valid</p></td>
              </tr>
            
              <tr>
                <td>RECEIPT_NOT_FOUND</td>
                <td>18</td>
                <td><p>Receipt for given transaction id does not exist</p></td>
              </tr>
            
              <tr>
                <td>RECORD_NOT_FOUND</td>
                <td>19</td>
                <td><p>Record for given transaction id does not exist</p></td>
              </tr>
            
              <tr>
                <td>INVALID_SOLIDITY_ID</td>
                <td>20</td>
                <td><p>The solidity id is invalid or entity with this solidity id does not exist</p></td>
              </tr>
            
              <tr>
                <td>UNKNOWN</td>
                <td>21</td>
                <td><p>The responding node has submitted the transaction to the network. Its final status is still
unknown.</p></td>
              </tr>
            
              <tr>
                <td>SUCCESS</td>
                <td>22</td>
                <td><p>The transaction succeeded</p></td>
              </tr>
            
              <tr>
                <td>FAIL_INVALID</td>
                <td>23</td>
                <td><p>There was a system error and the transaction failed because of invalid request parameters.</p></td>
              </tr>
            
              <tr>
                <td>FAIL_FEE</td>
                <td>24</td>
                <td><p>There was a system error while performing fee calculation, reserved for future.</p></td>
              </tr>
            
              <tr>
                <td>FAIL_BALANCE</td>
                <td>25</td>
                <td><p>There was a system error while performing balance checks, reserved for future.</p></td>
              </tr>
            
              <tr>
                <td>KEY_REQUIRED</td>
                <td>26</td>
                <td><p>Key not provided in the transaction body</p></td>
              </tr>
            
              <tr>
                <td>BAD_ENCODING</td>
                <td>27</td>
                <td><p>Unsupported algorithm/encoding used for keys in the transaction</p></td>
              </tr>
            
              <tr>
                <td>INSUFFICIENT_ACCOUNT_BALANCE</td>
                <td>28</td>
                <td><p>When the account balance is not sufficient for the transfer</p></td>
              </tr>
            
              <tr>
                <td>INVALID_SOLIDITY_ADDRESS</td>
                <td>29</td>
                <td><p>During an update transaction when the system is not able to find the Users Solidity address</p></td>
              </tr>
            
              <tr>
                <td>INSUFFICIENT_GAS</td>
                <td>30</td>
                <td><p>Not enough gas was supplied to execute transaction</p></td>
              </tr>
            
              <tr>
                <td>CONTRACT_SIZE_LIMIT_EXCEEDED</td>
                <td>31</td>
                <td><p>contract byte code size is over the limit</p></td>
              </tr>
            
              <tr>
                <td>LOCAL_CALL_MODIFICATION_EXCEPTION</td>
                <td>32</td>
                <td><p>local execution (query) is requested for a function which changes state</p></td>
              </tr>
            
              <tr>
                <td>CONTRACT_REVERT_EXECUTED</td>
                <td>33</td>
                <td><p>Contract REVERT OPCODE executed</p></td>
              </tr>
            
              <tr>
                <td>CONTRACT_EXECUTION_EXCEPTION</td>
                <td>34</td>
                <td><p>For any contract execution related error not handled by specific error codes listed above.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_RECEIVING_NODE_ACCOUNT</td>
                <td>35</td>
                <td><p>In Query validation, account with &#43;ve(amount) value should be Receiving node account, the
receiver account should be only one account in the list</p></td>
              </tr>
            
              <tr>
                <td>MISSING_QUERY_HEADER</td>
                <td>36</td>
                <td><p>Header is missing in Query request</p></td>
              </tr>
            
              <tr>
                <td>ACCOUNT_UPDATE_FAILED</td>
                <td>37</td>
                <td><p>The update of the account failed</p></td>
              </tr>
            
              <tr>
                <td>INVALID_KEY_ENCODING</td>
                <td>38</td>
                <td><p>Provided key encoding was not supported by the system</p></td>
              </tr>
            
              <tr>
                <td>NULL_SOLIDITY_ADDRESS</td>
                <td>39</td>
                <td><p>null solidity address</p></td>
              </tr>
            
              <tr>
                <td>CONTRACT_UPDATE_FAILED</td>
                <td>40</td>
                <td><p>update of the contract failed</p></td>
              </tr>
            
              <tr>
                <td>INVALID_QUERY_HEADER</td>
                <td>41</td>
                <td><p>the query header is invalid</p></td>
              </tr>
            
              <tr>
                <td>INVALID_FEE_SUBMITTED</td>
                <td>42</td>
                <td><p>Invalid fee submitted</p></td>
              </tr>
            
              <tr>
                <td>INVALID_PAYER_SIGNATURE</td>
                <td>43</td>
                <td><p>Payer signature is invalid</p></td>
              </tr>
            
              <tr>
                <td>KEY_NOT_PROVIDED</td>
                <td>44</td>
                <td><p>The keys were not provided in the request.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_EXPIRATION_TIME</td>
                <td>45</td>
                <td><p>Expiration time provided in the transaction was invalid.</p></td>
              </tr>
            
              <tr>
                <td>NO_WACL_KEY</td>
                <td>46</td>
                <td><p>WriteAccess Control Keys are not provided for the file</p></td>
              </tr>
            
              <tr>
                <td>FILE_CONTENT_EMPTY</td>
                <td>47</td>
                <td><p>The contents of file are provided as empty.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_ACCOUNT_AMOUNTS</td>
                <td>48</td>
                <td><p>The crypto transfer credit and debit do not sum equal to 0</p></td>
              </tr>
            
              <tr>
                <td>EMPTY_TRANSACTION_BODY</td>
                <td>49</td>
                <td><p>Transaction body provided is empty</p></td>
              </tr>
            
              <tr>
                <td>INVALID_TRANSACTION_BODY</td>
                <td>50</td>
                <td><p>Invalid transaction body provided</p></td>
              </tr>
            
              <tr>
                <td>INVALID_SIGNATURE_TYPE_MISMATCHING_KEY</td>
                <td>51</td>
                <td><p>the type of key (base ed25519 key, KeyList, or ThresholdKey) does not match the type of
signature (base ed25519 signature, SignatureList, or ThresholdKeySignature)</p></td>
              </tr>
            
              <tr>
                <td>INVALID_SIGNATURE_COUNT_MISMATCHING_KEY</td>
                <td>52</td>
                <td><p>the number of key (KeyList, or ThresholdKey) does not match that of signature (SignatureList,
or ThresholdKeySignature). e.g. if a keyList has 3 base keys, then the corresponding
signatureList should also have 3 base signatures.</p></td>
              </tr>
            
              <tr>
                <td>EMPTY_LIVE_HASH_BODY</td>
                <td>53</td>
                <td><p>the livehash body is empty</p></td>
              </tr>
            
              <tr>
                <td>EMPTY_LIVE_HASH</td>
                <td>54</td>
                <td><p>the livehash data is missing</p></td>
              </tr>
            
              <tr>
                <td>EMPTY_LIVE_HASH_KEYS</td>
                <td>55</td>
                <td><p>the keys for a livehash are missing</p></td>
              </tr>
            
              <tr>
                <td>INVALID_LIVE_HASH_SIZE</td>
                <td>56</td>
                <td><p>the livehash data is not the output of a SHA-384 digest</p></td>
              </tr>
            
              <tr>
                <td>EMPTY_QUERY_BODY</td>
                <td>57</td>
                <td><p>the query body is empty</p></td>
              </tr>
            
              <tr>
                <td>EMPTY_LIVE_HASH_QUERY</td>
                <td>58</td>
                <td><p>the crypto livehash query is empty</p></td>
              </tr>
            
              <tr>
                <td>LIVE_HASH_NOT_FOUND</td>
                <td>59</td>
                <td><p>the livehash is not present</p></td>
              </tr>
            
              <tr>
                <td>ACCOUNT_ID_DOES_NOT_EXIST</td>
                <td>60</td>
                <td><p>the account id passed has not yet been created.</p></td>
              </tr>
            
              <tr>
                <td>LIVE_HASH_ALREADY_EXISTS</td>
                <td>61</td>
                <td><p>the livehash already exists for a given account</p></td>
              </tr>
            
              <tr>
                <td>INVALID_FILE_WACL</td>
                <td>62</td>
                <td><p>File WACL keys are invalid</p></td>
              </tr>
            
              <tr>
                <td>SERIALIZATION_FAILED</td>
                <td>63</td>
                <td><p>Serialization failure</p></td>
              </tr>
            
              <tr>
                <td>TRANSACTION_OVERSIZE</td>
                <td>64</td>
                <td><p>The size of the Transaction is greater than transactionMaxBytes</p></td>
              </tr>
            
              <tr>
                <td>TRANSACTION_TOO_MANY_LAYERS</td>
                <td>65</td>
                <td><p>The Transaction has more than 50 levels</p></td>
              </tr>
            
              <tr>
                <td>CONTRACT_DELETED</td>
                <td>66</td>
                <td><p>Contract is marked as deleted</p></td>
              </tr>
            
              <tr>
                <td>PLATFORM_NOT_ACTIVE</td>
                <td>67</td>
                <td><p>the platform node is either disconnected or lagging behind.</p></td>
              </tr>
            
              <tr>
                <td>KEY_PREFIX_MISMATCH</td>
                <td>68</td>
                <td><p>one public key matches more than one prefixes on the signature map</p></td>
              </tr>
            
              <tr>
                <td>PLATFORM_TRANSACTION_NOT_CREATED</td>
                <td>69</td>
                <td><p>transaction not created by platform due to large backlog</p></td>
              </tr>
            
              <tr>
                <td>INVALID_RENEWAL_PERIOD</td>
                <td>70</td>
                <td><p>auto renewal period is not a positive number of seconds</p></td>
              </tr>
            
              <tr>
                <td>INVALID_PAYER_ACCOUNT_ID</td>
                <td>71</td>
                <td><p>the response code when a smart contract id is passed for a crypto API request</p></td>
              </tr>
            
              <tr>
                <td>ACCOUNT_DELETED</td>
                <td>72</td>
                <td><p>the account has been marked as deleted</p></td>
              </tr>
            
              <tr>
                <td>FILE_DELETED</td>
                <td>73</td>
                <td><p>the file has been marked as deleted</p></td>
              </tr>
            
              <tr>
                <td>ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS</td>
                <td>74</td>
                <td><p>same accounts repeated in the transfer account list</p></td>
              </tr>
            
              <tr>
                <td>SETTING_NEGATIVE_ACCOUNT_BALANCE</td>
                <td>75</td>
                <td><p>attempting to set negative balance value for crypto account</p></td>
              </tr>
            
              <tr>
                <td>OBTAINER_REQUIRED</td>
                <td>76</td>
                <td><p>when deleting smart contract that has crypto balance either transfer account or transfer smart
contract is required</p></td>
              </tr>
            
              <tr>
                <td>OBTAINER_SAME_CONTRACT_ID</td>
                <td>77</td>
                <td><p>when deleting smart contract that has crypto balance you can not use the same contract id as
transferContractId as the one being deleted</p></td>
              </tr>
            
              <tr>
                <td>OBTAINER_DOES_NOT_EXIST</td>
                <td>78</td>
                <td><p>transferAccountId or transferContractId specified for contract delete does not exist</p></td>
              </tr>
            
              <tr>
                <td>MODIFYING_IMMUTABLE_CONTRACT</td>
                <td>79</td>
                <td><p>attempting to modify (update or delete a immutable smart contract, i.e. one created without a
admin key)</p></td>
              </tr>
            
              <tr>
                <td>FILE_SYSTEM_EXCEPTION</td>
                <td>80</td>
                <td><p>Unexpected exception thrown by file system functions</p></td>
              </tr>
            
              <tr>
                <td>AUTORENEW_DURATION_NOT_IN_RANGE</td>
                <td>81</td>
                <td><p>the duration is not a subset of [MINIMUM_AUTORENEW_DURATION,MAXIMUM_AUTORENEW_DURATION]</p></td>
              </tr>
            
              <tr>
                <td>ERROR_DECODING_BYTESTRING</td>
                <td>82</td>
                <td><p>Decoding the smart contract binary to a byte array failed. Check that the input is a valid hex
string.</p></td>
              </tr>
            
              <tr>
                <td>CONTRACT_FILE_EMPTY</td>
                <td>83</td>
                <td><p>File to create a smart contract was of length zero</p></td>
              </tr>
            
              <tr>
                <td>CONTRACT_BYTECODE_EMPTY</td>
                <td>84</td>
                <td><p>Bytecode for smart contract is of length zero</p></td>
              </tr>
            
              <tr>
                <td>INVALID_INITIAL_BALANCE</td>
                <td>85</td>
                <td><p>Attempt to set negative initial balance</p></td>
              </tr>
            
              <tr>
                <td>INVALID_RECEIVE_RECORD_THRESHOLD</td>
                <td>86</td>
                <td><p>[Deprecated]. attempt to set negative receive record threshold</p></td>
              </tr>
            
              <tr>
                <td>INVALID_SEND_RECORD_THRESHOLD</td>
                <td>87</td>
                <td><p>[Deprecated]. attempt to set negative send record threshold</p></td>
              </tr>
            
              <tr>
                <td>ACCOUNT_IS_NOT_GENESIS_ACCOUNT</td>
                <td>88</td>
                <td><p>Special Account Operations should be performed by only Genesis account, return this code if it
is not Genesis Account</p></td>
              </tr>
            
              <tr>
                <td>PAYER_ACCOUNT_UNAUTHORIZED</td>
                <td>89</td>
                <td><p>The fee payer account doesn&#39;t have permission to submit such Transaction</p></td>
              </tr>
            
              <tr>
                <td>INVALID_FREEZE_TRANSACTION_BODY</td>
                <td>90</td>
                <td><p>FreezeTransactionBody is invalid</p></td>
              </tr>
            
              <tr>
                <td>FREEZE_TRANSACTION_BODY_NOT_FOUND</td>
                <td>91</td>
                <td><p>FreezeTransactionBody does not exist</p></td>
              </tr>
            
              <tr>
                <td>TRANSFER_LIST_SIZE_LIMIT_EXCEEDED</td>
                <td>92</td>
                <td><p>Exceeded the number of accounts (both from and to) allowed for crypto transfer list</p></td>
              </tr>
            
              <tr>
                <td>RESULT_SIZE_LIMIT_EXCEEDED</td>
                <td>93</td>
                <td><p>Smart contract result size greater than specified maxResultSize</p></td>
              </tr>
            
              <tr>
                <td>NOT_SPECIAL_ACCOUNT</td>
                <td>94</td>
                <td><p>The payer account is not a special account(account 0.0.55)</p></td>
              </tr>
            
              <tr>
                <td>CONTRACT_NEGATIVE_GAS</td>
                <td>95</td>
                <td><p>Negative gas was offered in smart contract call</p></td>
              </tr>
            
              <tr>
                <td>CONTRACT_NEGATIVE_VALUE</td>
                <td>96</td>
                <td><p>Negative value / initial balance was specified in a smart contract call / create</p></td>
              </tr>
            
              <tr>
                <td>INVALID_FEE_FILE</td>
                <td>97</td>
                <td><p>Failed to update fee file</p></td>
              </tr>
            
              <tr>
                <td>INVALID_EXCHANGE_RATE_FILE</td>
                <td>98</td>
                <td><p>Failed to update exchange rate file</p></td>
              </tr>
            
              <tr>
                <td>INSUFFICIENT_LOCAL_CALL_GAS</td>
                <td>99</td>
                <td><p>Payment tendered for contract local call cannot cover both the fee and the gas</p></td>
              </tr>
            
              <tr>
                <td>ENTITY_NOT_ALLOWED_TO_DELETE</td>
                <td>100</td>
                <td><p>Entities with Entity ID below 1000 are not allowed to be deleted</p></td>
              </tr>
            
              <tr>
                <td>AUTHORIZATION_FAILED</td>
                <td>101</td>
                <td><p>Violating one of these rules: 1) treasury account can update all entities below 0.0.1000, 2)
account 0.0.50 can update all entities from 0.0.51 - 0.0.80, 3) Network Function Master Account
A/c 0.0.50 - Update all Network Function accounts &amp; perform all the Network Functions listed
below, 4) Network Function Accounts: i) A/c 0.0.55 - Update Address Book files (0.0.101/102),
ii) A/c 0.0.56 - Update Fee schedule (0.0.111), iii) A/c 0.0.57 - Update Exchange Rate
(0.0.112).</p></td>
              </tr>
            
              <tr>
                <td>FILE_UPLOADED_PROTO_INVALID</td>
                <td>102</td>
                <td><p>Fee Schedule Proto uploaded but not valid (append or update is required)</p></td>
              </tr>
            
              <tr>
                <td>FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK</td>
                <td>103</td>
                <td><p>Fee Schedule Proto uploaded but not valid (append or update is required)</p></td>
              </tr>
            
              <tr>
                <td>FEE_SCHEDULE_FILE_PART_UPLOADED</td>
                <td>104</td>
                <td><p>Fee Schedule Proto File Part uploaded</p></td>
              </tr>
            
              <tr>
                <td>EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED</td>
                <td>105</td>
                <td><p>The change on Exchange Rate exceeds Exchange_Rate_Allowed_Percentage</p></td>
              </tr>
            
              <tr>
                <td>MAX_CONTRACT_STORAGE_EXCEEDED</td>
                <td>106</td>
                <td><p>Contract permanent storage exceeded the currently allowable limit</p></td>
              </tr>
            
              <tr>
                <td>TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT</td>
                <td>107</td>
                <td><p>Transfer Account should not be same as Account to be deleted</p></td>
              </tr>
            
              <tr>
                <td>TOTAL_LEDGER_BALANCE_INVALID</td>
                <td>108</td>
                <td><p></p></td>
              </tr>
            
              <tr>
                <td>EXPIRATION_REDUCTION_NOT_ALLOWED</td>
                <td>110</td>
                <td><p>The expiration date/time on a smart contract may not be reduced</p></td>
              </tr>
            
              <tr>
                <td>MAX_GAS_LIMIT_EXCEEDED</td>
                <td>111</td>
                <td><p>Gas exceeded currently allowable gas limit per transaction</p></td>
              </tr>
            
              <tr>
                <td>MAX_FILE_SIZE_EXCEEDED</td>
                <td>112</td>
                <td><p>File size exceeded the currently allowable limit</p></td>
              </tr>
            
              <tr>
                <td>RECEIVER_SIG_REQUIRED</td>
                <td>113</td>
                <td><p>When a valid signature is not provided for operations on account with receiverSigRequired=true</p></td>
              </tr>
            
              <tr>
                <td>INVALID_TOPIC_ID</td>
                <td>150</td>
                <td><p>The Topic ID specified is not in the system.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_ADMIN_KEY</td>
                <td>155</td>
                <td><p>A provided admin key was invalid.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_SUBMIT_KEY</td>
                <td>156</td>
                <td><p>A provided submit key was invalid.</p></td>
              </tr>
            
              <tr>
                <td>UNAUTHORIZED</td>
                <td>157</td>
                <td><p>An attempted operation was not authorized (ie - a deleteTopic for a topic with no adminKey).</p></td>
              </tr>
            
              <tr>
                <td>INVALID_TOPIC_MESSAGE</td>
                <td>158</td>
                <td><p>A ConsensusService message is empty.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_AUTORENEW_ACCOUNT</td>
                <td>159</td>
                <td><p>The autoRenewAccount specified is not a valid, active account.</p></td>
              </tr>
            
              <tr>
                <td>AUTORENEW_ACCOUNT_NOT_ALLOWED</td>
                <td>160</td>
                <td><p>An adminKey was not specified on the topic, so there must not be an autoRenewAccount.</p></td>
              </tr>
            
              <tr>
                <td>TOPIC_EXPIRED</td>
                <td>162</td>
                <td><p>The topic has expired, was not automatically renewed, and is in a 7 day grace period before the
topic will be deleted unrecoverably. This error response code will not be returned until
autoRenew functionality is supported by HAPI.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_CHUNK_NUMBER</td>
                <td>163</td>
                <td><p>chunk number must be from 1 to total (chunks) inclusive.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_CHUNK_TRANSACTION_ID</td>
                <td>164</td>
                <td><p>For every chunk, the payer account that is part of initialTransactionID must match the Payer Account of this transaction. The entire initialTransactionID should match the transactionID of the first chunk, but this is not checked or enforced by Hedera except when the chunk number is 1.</p></td>
              </tr>
            
              <tr>
                <td>ACCOUNT_FROZEN_FOR_TOKEN</td>
                <td>165</td>
                <td><p>Account is frozen and cannot transact with the token</p></td>
              </tr>
            
              <tr>
                <td>TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED</td>
                <td>166</td>
                <td><p>An involved account already has more than &lt;tt&gt;tokens.maxPerAccount&lt;/tt&gt; associations with non-deleted tokens.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_TOKEN_ID</td>
                <td>167</td>
                <td><p>The token is invalid or does not exist</p></td>
              </tr>
            
              <tr>
                <td>INVALID_TOKEN_DECIMALS</td>
                <td>168</td>
                <td><p>Invalid token decimals</p></td>
              </tr>
            
              <tr>
                <td>INVALID_TOKEN_INITIAL_SUPPLY</td>
                <td>169</td>
                <td><p>Invalid token initial supply</p></td>
              </tr>
            
              <tr>
                <td>INVALID_TREASURY_ACCOUNT_FOR_TOKEN</td>
                <td>170</td>
                <td><p>Treasury Account does not exist or is deleted</p></td>
              </tr>
            
              <tr>
                <td>INVALID_TOKEN_SYMBOL</td>
                <td>171</td>
                <td><p>Token Symbol is not UTF-8 capitalized alphabetical string</p></td>
              </tr>
            
              <tr>
                <td>TOKEN_HAS_NO_FREEZE_KEY</td>
                <td>172</td>
                <td><p>Freeze key is not set on token</p></td>
              </tr>
            
              <tr>
                <td>TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN</td>
                <td>173</td>
                <td><p>Amounts in transfer list are not net zero</p></td>
              </tr>
            
              <tr>
                <td>MISSING_TOKEN_SYMBOL</td>
                <td>174</td>
                <td><p>A token symbol was not provided</p></td>
              </tr>
            
              <tr>
                <td>TOKEN_SYMBOL_TOO_LONG</td>
                <td>175</td>
                <td><p>The provided token symbol was too long</p></td>
              </tr>
            
              <tr>
                <td>ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN</td>
                <td>176</td>
                <td><p>KYC must be granted and account does not have KYC granted</p></td>
              </tr>
            
              <tr>
                <td>TOKEN_HAS_NO_KYC_KEY</td>
                <td>177</td>
                <td><p>KYC key is not set on token</p></td>
              </tr>
            
              <tr>
                <td>INSUFFICIENT_TOKEN_BALANCE</td>
                <td>178</td>
                <td><p>Token balance is not sufficient for the transaction</p></td>
              </tr>
            
              <tr>
                <td>TOKEN_WAS_DELETED</td>
                <td>179</td>
                <td><p>Token transactions cannot be executed on deleted token</p></td>
              </tr>
            
              <tr>
                <td>TOKEN_HAS_NO_SUPPLY_KEY</td>
                <td>180</td>
                <td><p>Supply key is not set on token</p></td>
              </tr>
            
              <tr>
                <td>TOKEN_HAS_NO_WIPE_KEY</td>
                <td>181</td>
                <td><p>Wipe key is not set on token</p></td>
              </tr>
            
              <tr>
                <td>INVALID_TOKEN_MINT_AMOUNT</td>
                <td>182</td>
                <td><p>The requested token mint amount would cause an invalid total supply</p></td>
              </tr>
            
              <tr>
                <td>INVALID_TOKEN_BURN_AMOUNT</td>
                <td>183</td>
                <td><p>The requested token burn amount would cause an invalid total supply</p></td>
              </tr>
            
              <tr>
                <td>TOKEN_NOT_ASSOCIATED_TO_ACCOUNT</td>
                <td>184</td>
                <td><p>A required token-account relationship is missing</p></td>
              </tr>
            
              <tr>
                <td>CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT</td>
                <td>185</td>
                <td><p>The target of a wipe operation was the token treasury account</p></td>
              </tr>
            
              <tr>
                <td>INVALID_KYC_KEY</td>
                <td>186</td>
                <td><p>The provided KYC key was invalid.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_WIPE_KEY</td>
                <td>187</td>
                <td><p>The provided wipe key was invalid.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_FREEZE_KEY</td>
                <td>188</td>
                <td><p>The provided freeze key was invalid.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_SUPPLY_KEY</td>
                <td>189</td>
                <td><p>The provided supply key was invalid.</p></td>
              </tr>
            
              <tr>
                <td>MISSING_TOKEN_NAME</td>
                <td>190</td>
                <td><p>Token Name is not provided</p></td>
              </tr>
            
              <tr>
                <td>TOKEN_NAME_TOO_LONG</td>
                <td>191</td>
                <td><p>Token Name is too long</p></td>
              </tr>
            
              <tr>
                <td>INVALID_WIPING_AMOUNT</td>
                <td>192</td>
                <td><p>The provided wipe amount must not be negative, zero or bigger than the token holder balance</p></td>
              </tr>
            
              <tr>
                <td>TOKEN_IS_IMMUTABLE</td>
                <td>193</td>
                <td><p>Token does not have Admin key set, thus update/delete transactions cannot be performed</p></td>
              </tr>
            
              <tr>
                <td>TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT</td>
                <td>194</td>
                <td><p>An &lt;tt&gt;associateToken&lt;/tt&gt; operation specified a token already associated to the account</p></td>
              </tr>
            
              <tr>
                <td>TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES</td>
                <td>195</td>
                <td><p>An attempted operation is invalid until all token balances for the target account are zero</p></td>
              </tr>
            
              <tr>
                <td>ACCOUNT_IS_TREASURY</td>
                <td>196</td>
                <td><p>An attempted operation is invalid because the account is a treasury</p></td>
              </tr>
            
              <tr>
                <td>TOKEN_ID_REPEATED_IN_TOKEN_LIST</td>
                <td>197</td>
                <td><p>Same TokenIDs present in the token list</p></td>
              </tr>
            
              <tr>
                <td>TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED</td>
                <td>198</td>
                <td><p>Exceeded the number of token transfers (both from and to) allowed for token transfer list</p></td>
              </tr>
            
              <tr>
                <td>EMPTY_TOKEN_TRANSFER_BODY</td>
                <td>199</td>
                <td><p>TokenTransfersTransactionBody has no TokenTransferList</p></td>
              </tr>
            
              <tr>
                <td>EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS</td>
                <td>200</td>
                <td><p>TokenTransfersTransactionBody has a TokenTransferList with no AccountAmounts</p></td>
              </tr>
            
              <tr>
                <td>INVALID_SCHEDULE_ID</td>
                <td>201</td>
                <td><p>The Scheduled entity does not exist; or has now expired, been deleted, or been executed</p></td>
              </tr>
            
              <tr>
                <td>SCHEDULE_IS_IMMUTABLE</td>
                <td>202</td>
                <td><p>The Scheduled entity cannot be modified. Admin key not set</p></td>
              </tr>
            
              <tr>
                <td>INVALID_SCHEDULE_PAYER_ID</td>
                <td>203</td>
                <td><p>The provided Scheduled Payer does not exist</p></td>
              </tr>
            
              <tr>
                <td>INVALID_SCHEDULE_ACCOUNT_ID</td>
                <td>204</td>
                <td><p>The Schedule Create Transaction TransactionID account does not exist</p></td>
              </tr>
            
              <tr>
                <td>NO_NEW_VALID_SIGNATURES</td>
                <td>205</td>
                <td><p>The provided sig map did not contain any new valid signatures from required signers of the scheduled transaction</p></td>
              </tr>
            
              <tr>
                <td>UNRESOLVABLE_REQUIRED_SIGNERS</td>
                <td>206</td>
                <td><p>The required signers for a scheduled transaction cannot be resolved, for example because they do not exist or have been deleted</p></td>
              </tr>
            
              <tr>
                <td>SCHEDULED_TRANSACTION_NOT_IN_WHITELIST</td>
                <td>207</td>
                <td><p>Only whitelisted transaction types may be scheduled</p></td>
              </tr>
            
              <tr>
                <td>SOME_SIGNATURES_WERE_INVALID</td>
                <td>208</td>
                <td><p>At least one of the signatures in the provided sig map did not represent a valid signature for any required signer</p></td>
              </tr>
            
              <tr>
                <td>TRANSACTION_ID_FIELD_NOT_ALLOWED</td>
                <td>209</td>
                <td><p>The scheduled field in the TransactionID may not be set to true</p></td>
              </tr>
            
              <tr>
                <td>IDENTICAL_SCHEDULE_ALREADY_CREATED</td>
                <td>210</td>
                <td><p>A schedule already exists with the same identifying fields of an attempted ScheduleCreate (that is, all fields other than scheduledPayerAccountID)</p></td>
              </tr>
            
              <tr>
                <td>INVALID_ZERO_BYTE_IN_STRING</td>
                <td>211</td>
                <td><p>A string field in the transaction has a UTF-8 encoding with the prohibited zero byte</p></td>
              </tr>
            
              <tr>
                <td>SCHEDULE_ALREADY_DELETED</td>
                <td>212</td>
                <td><p>A schedule being signed or deleted has already been deleted</p></td>
              </tr>
            
              <tr>
                <td>SCHEDULE_ALREADY_EXECUTED</td>
                <td>213</td>
                <td><p>A schedule being signed or deleted has already been executed</p></td>
              </tr>
            
              <tr>
                <td>MESSAGE_SIZE_TOO_LARGE</td>
                <td>214</td>
                <td><p>ConsensusSubmitMessage request&#39;s message size is larger than allowed.</p></td>
              </tr>
            
              <tr>
                <td>OPERATION_REPEATED_IN_BUCKET_GROUPS</td>
                <td>215</td>
                <td><p>An operation was assigned to more than one throttle group in a given bucket</p></td>
              </tr>
            
              <tr>
                <td>BUCKET_CAPACITY_OVERFLOW</td>
                <td>216</td>
                <td><p>The capacity needed to satisfy all opsPerSec groups in a bucket overflowed a signed 8-byte integral type</p></td>
              </tr>
            
              <tr>
                <td>NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION</td>
                <td>217</td>
                <td><p>Given the network size in the address book, the node-level capacity for an operation would never be enough to accept a single request; usually means a bucket burstPeriod should be increased</p></td>
              </tr>
            
              <tr>
                <td>BUCKET_HAS_NO_THROTTLE_GROUPS</td>
                <td>218</td>
                <td><p>A bucket was defined without any throttle groups</p></td>
              </tr>
            
              <tr>
                <td>THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC</td>
                <td>219</td>
                <td><p>A throttle group was granted zero opsPerSec</p></td>
              </tr>
            
              <tr>
                <td>SUCCESS_BUT_MISSING_EXPECTED_OPERATION</td>
                <td>220</td>
                <td><p>The throttle definitions file was updated, but some supported operations were not assigned a bucket</p></td>
              </tr>
            
              <tr>
                <td>UNPARSEABLE_THROTTLE_DEFINITIONS</td>
                <td>221</td>
                <td><p>The new contents for the throttle definitions system file were not valid protobuf</p></td>
              </tr>
            
              <tr>
                <td>INVALID_THROTTLE_DEFINITIONS</td>
                <td>222</td>
                <td><p>The new throttle definitions system file were invalid, and no more specific error could be divined</p></td>
              </tr>
            
              <tr>
                <td>ACCOUNT_EXPIRED_AND_PENDING_REMOVAL</td>
                <td>223</td>
                <td><p>The transaction references an account which has passed its expiration without renewal funds available, and currently remains in the ledger only because of the grace period given to expired entities</p></td>
              </tr>
            
              <tr>
                <td>INVALID_TOKEN_MAX_SUPPLY</td>
                <td>224</td>
                <td><p>Invalid token max supply</p></td>
              </tr>
            
              <tr>
                <td>INVALID_TOKEN_NFT_SERIAL_NUMBER</td>
                <td>225</td>
                <td><p>Invalid token nft serial number</p></td>
              </tr>
            
              <tr>
                <td>INVALID_NFT_ID</td>
                <td>226</td>
                <td><p>Invalid nft id</p></td>
              </tr>
            
              <tr>
                <td>METADATA_TOO_LONG</td>
                <td>227</td>
                <td><p>Nft metadata is too long</p></td>
              </tr>
            
              <tr>
                <td>BATCH_SIZE_LIMIT_EXCEEDED</td>
                <td>228</td>
                <td><p>Repeated operations count exceeds the limit</p></td>
              </tr>
            
              <tr>
                <td>INVALID_QUERY_RANGE</td>
                <td>229</td>
                <td><p>The range of data to be gathered is out of the set boundaries</p></td>
              </tr>
            
              <tr>
                <td>FRACTION_DIVIDES_BY_ZERO</td>
                <td>230</td>
                <td><p>A custom fractional fee set a denominator of zero</p></td>
              </tr>
            
              <tr>
                <td>INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE</td>
                <td>231</td>
                <td><p>The transaction payer could not afford a custom fee</p></td>
              </tr>
            
              <tr>
                <td>CUSTOM_FEES_LIST_TOO_LONG</td>
                <td>232</td>
                <td><p>More than 10 custom fees were specified</p></td>
              </tr>
            
              <tr>
                <td>INVALID_CUSTOM_FEE_COLLECTOR</td>
                <td>233</td>
                <td><p>Any of the feeCollector accounts for customFees is invalid</p></td>
              </tr>
            
              <tr>
                <td>INVALID_TOKEN_ID_IN_CUSTOM_FEES</td>
                <td>234</td>
                <td><p>Any of the token Ids in customFees is invalid</p></td>
              </tr>
            
              <tr>
                <td>TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR</td>
                <td>235</td>
                <td><p>Any of the token Ids in customFees are not associated to feeCollector</p></td>
              </tr>
            
              <tr>
                <td>TOKEN_MAX_SUPPLY_REACHED</td>
                <td>236</td>
                <td><p>A token cannot have more units minted due to its configured supply ceiling</p></td>
              </tr>
            
              <tr>
                <td>SENDER_DOES_NOT_OWN_NFT_SERIAL_NO</td>
                <td>237</td>
                <td><p>The transaction attempted to move an NFT serial number from an account other than its owner</p></td>
              </tr>
            
              <tr>
                <td>CUSTOM_FEE_NOT_FULLY_SPECIFIED</td>
                <td>238</td>
                <td><p>A custom fee schedule entry did not specify either a fixed or fractional fee</p></td>
              </tr>
            
              <tr>
                <td>CUSTOM_FEE_MUST_BE_POSITIVE</td>
                <td>239</td>
                <td><p>Only positive fees may be assessed at this time</p></td>
              </tr>
            
              <tr>
                <td>TOKEN_HAS_NO_FEE_SCHEDULE_KEY</td>
                <td>240</td>
                <td><p>Fee schedule key is not set on token</p></td>
              </tr>
            
              <tr>
                <td>CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE</td>
                <td>241</td>
                <td><p>A fractional custom fee exceeded the range of a 64-bit signed integer</p></td>
              </tr>
            
              <tr>
                <td>ROYALTY_FRACTION_CANNOT_EXCEED_ONE</td>
                <td>242</td>
                <td><p>A royalty cannot exceed the total fungible value exchanged for an NFT</p></td>
              </tr>
            
              <tr>
                <td>FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT</td>
                <td>243</td>
                <td><p>Each fractional custom fee must have its maximum_amount, if specified, at least its minimum_amount</p></td>
              </tr>
            
              <tr>
                <td>CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES</td>
                <td>244</td>
                <td><p>A fee schedule update tried to clear the custom fees from a token whose fee schedule was already empty</p></td>
              </tr>
            
              <tr>
                <td>CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON</td>
                <td>245</td>
                <td><p>Only tokens of type FUNGIBLE_COMMON can be used to as fee schedule denominations</p></td>
              </tr>
            
              <tr>
                <td>CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON</td>
                <td>246</td>
                <td><p>Only tokens of type FUNGIBLE_COMMON can have fractional fees</p></td>
              </tr>
            
              <tr>
                <td>INVALID_CUSTOM_FEE_SCHEDULE_KEY</td>
                <td>247</td>
                <td><p>The provided custom fee schedule key was invalid</p></td>
              </tr>
            
              <tr>
                <td>INVALID_TOKEN_MINT_METADATA</td>
                <td>248</td>
                <td><p>The requested token mint metadata was invalid</p></td>
              </tr>
            
              <tr>
                <td>INVALID_TOKEN_BURN_METADATA</td>
                <td>249</td>
                <td><p>The requested token burn metadata was invalid</p></td>
              </tr>
            
              <tr>
                <td>CURRENT_TREASURY_STILL_OWNS_NFTS</td>
                <td>250</td>
                <td><p>The treasury for a unique token cannot be changed until it owns no NFTs</p></td>
              </tr>
            
              <tr>
                <td>ACCOUNT_STILL_OWNS_NFTS</td>
                <td>251</td>
                <td><p>An account cannot be dissociated from a unique token if it owns NFTs for the token</p></td>
              </tr>
            
              <tr>
                <td>TREASURY_MUST_OWN_BURNED_NFT</td>
                <td>252</td>
                <td><p>A NFT can only be burned when owned by the unique token&#39;s treasury</p></td>
              </tr>
            
              <tr>
                <td>ACCOUNT_DOES_NOT_OWN_WIPED_NFT</td>
                <td>253</td>
                <td><p>An account did not own the NFT to be wiped</p></td>
              </tr>
            
              <tr>
                <td>ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON</td>
                <td>254</td>
                <td><p>An AccountAmount token transfers list referenced a token type other than FUNGIBLE_COMMON</p></td>
              </tr>
            
              <tr>
                <td>MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED</td>
                <td>255</td>
                <td><p>All the NFTs allowed in the current price regime have already been minted</p></td>
              </tr>
            
              <tr>
                <td>PAYER_ACCOUNT_DELETED</td>
                <td>256</td>
                <td><p>The payer account has been marked as deleted</p></td>
              </tr>
            
              <tr>
                <td>CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH</td>
                <td>257</td>
                <td><p>The reference chain of custom fees for a transferred token exceeded the maximum length of 2</p></td>
              </tr>
            
              <tr>
                <td>CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS</td>
                <td>258</td>
                <td><p>More than 20 balance adjustments were to satisfy a CryptoTransfer and its implied custom fee payments</p></td>
              </tr>
            
              <tr>
                <td>INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE</td>
                <td>259</td>
                <td><p>The sender account in the token transfer transaction could not afford a custom fee</p></td>
              </tr>
            
              <tr>
                <td>SERIAL_NUMBER_LIMIT_REACHED</td>
                <td>260</td>
                <td><p>Currently no more than 4,294,967,295 NFTs may be minted for a given unique token type</p></td>
              </tr>
            
              <tr>
                <td>CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE</td>
                <td>261</td>
                <td><p>Only tokens of type NON_FUNGIBLE_UNIQUE can have royalty fees</p></td>
              </tr>
            
              <tr>
                <td>NO_REMAINING_AUTOMATIC_ASSOCIATIONS</td>
                <td>262</td>
                <td><p>The account has reached the limit on the automatic associations count.</p></td>
              </tr>
            
              <tr>
                <td>EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT</td>
                <td>263</td>
                <td><p>Already existing automatic associations are more than the new maximum automatic associations.</p></td>
              </tr>
            
              <tr>
                <td>REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT</td>
                <td>264</td>
                <td><p>Cannot set the number of automatic associations for an account more than the maximum allowed 
token associations &lt;tt&gt;tokens.maxPerAccount&lt;/tt&gt;.</p></td>
              </tr>
            
              <tr>
                <td>TOKEN_IS_PAUSED</td>
                <td>265</td>
                <td><p>Token is paused. This Token cannot be a part of any kind of Transaction until unpaused.</p></td>
              </tr>
            
              <tr>
                <td>TOKEN_HAS_NO_PAUSE_KEY</td>
                <td>266</td>
                <td><p>Pause key is not set on token</p></td>
              </tr>
            
              <tr>
                <td>INVALID_PAUSE_KEY</td>
                <td>267</td>
                <td><p>The provided pause key was invalid</p></td>
              </tr>
            
              <tr>
                <td>FREEZE_UPDATE_FILE_DOES_NOT_EXIST</td>
                <td>268</td>
                <td><p>The update file in a freeze transaction body must exist.</p></td>
              </tr>
            
              <tr>
                <td>FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH</td>
                <td>269</td>
                <td><p>The hash of the update file in a freeze transaction body must match the in-memory hash.</p></td>
              </tr>
            
              <tr>
                <td>NO_UPGRADE_HAS_BEEN_PREPARED</td>
                <td>270</td>
                <td><p>A FREEZE_UPGRADE transaction was handled with no previous update prepared.</p></td>
              </tr>
            
              <tr>
                <td>NO_FREEZE_IS_SCHEDULED</td>
                <td>271</td>
                <td><p>A FREEZE_ABORT transaction was handled with no scheduled freeze.</p></td>
              </tr>
            
              <tr>
                <td>UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE</td>
                <td>272</td>
                <td><p>The update file hash when handling a FREEZE_UPGRADE transaction differs from the file
hash at the time of handling the PREPARE_UPGRADE transaction.</p></td>
              </tr>
            
              <tr>
                <td>FREEZE_START_TIME_MUST_BE_FUTURE</td>
                <td>273</td>
                <td><p>The given freeze start time was in the (consensus) past.</p></td>
              </tr>
            
              <tr>
                <td>PREPARED_UPDATE_FILE_IS_IMMUTABLE</td>
                <td>274</td>
                <td><p>The prepared update file cannot be updated or appended until either the upgrade has
been completed, or a FREEZE_ABORT has been handled.</p></td>
              </tr>
            
              <tr>
                <td>FREEZE_ALREADY_SCHEDULED</td>
                <td>275</td>
                <td><p>Once a freeze is scheduled, it must be aborted before any other type of freeze can
can be performed.</p></td>
              </tr>
            
              <tr>
                <td>FREEZE_UPGRADE_IN_PROGRESS</td>
                <td>276</td>
                <td><p>If an NMT upgrade has been prepared, the following operation must be a FREEZE_UPGRADE.
(To issue a FREEZE_ONLY, submit a FREEZE_ABORT first.)</p></td>
              </tr>
            
              <tr>
                <td>UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED</td>
                <td>277</td>
                <td><p>If an NMT upgrade has been prepared, the subsequent FREEZE_UPGRADE transaction must 
confirm the id of the file to be used in the upgrade.</p></td>
              </tr>
            
              <tr>
                <td>UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED</td>
                <td>278</td>
                <td><p>If an NMT upgrade has been prepared, the subsequent FREEZE_UPGRADE transaction must 
confirm the hash of the file to be used in the upgrade.</p></td>
              </tr>
            
              <tr>
                <td>CONSENSUS_GAS_EXHAUSTED</td>
                <td>279</td>
                <td><p>Consensus throttle did not allow execution of this transaction. System is throttled at
consensus level.</p></td>
              </tr>
            
              <tr>
                <td>REVERTED_SUCCESS</td>
                <td>280</td>
                <td><p>A precompiled contract succeeded, but was later reverted.</p></td>
              </tr>
            
              <tr>
                <td>MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED</td>
                <td>281</td>
                <td><p>All contract storage allocated to the current price regime has been consumed.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_ALIAS_KEY</td>
                <td>282</td>
                <td><p>An alias used in a CryptoTransfer transaction is not the serialization of a primitive Key
message--that is, a Key with a single Ed25519 or ECDSA(secp256k1) public key and no 
unknown protobuf fields.</p></td>
              </tr>
            
              <tr>
                <td>UNEXPECTED_TOKEN_DECIMALS</td>
                <td>283</td>
                <td><p>A fungible token transfer expected a different number of decimals than the involved 
type actually has.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_PROXY_ACCOUNT_ID</td>
                <td>284</td>
                <td><p>[Deprecated] The proxy account id is invalid or does not exist.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_TRANSFER_ACCOUNT_ID</td>
                <td>285</td>
                <td><p>The transfer account id in CryptoDelete transaction is invalid or does not exist.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_FEE_COLLECTOR_ACCOUNT_ID</td>
                <td>286</td>
                <td><p>The fee collector account id in TokenFeeScheduleUpdate is invalid or does not exist.</p></td>
              </tr>
            
              <tr>
                <td>ALIAS_IS_IMMUTABLE</td>
                <td>287</td>
                <td><p>The alias already set on an account cannot be updated using CryptoUpdate transaction.</p></td>
              </tr>
            
              <tr>
                <td>SPENDER_ACCOUNT_SAME_AS_OWNER</td>
                <td>288</td>
                <td><p>An approved allowance specifies a spender account that is the same as the hbar/token
owner account.</p></td>
              </tr>
            
              <tr>
                <td>AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY</td>
                <td>289</td>
                <td><p>The establishment or adjustment of an approved allowance cause the token allowance
to exceed the token maximum supply.</p></td>
              </tr>
            
              <tr>
                <td>NEGATIVE_ALLOWANCE_AMOUNT</td>
                <td>290</td>
                <td><p>The specified amount for an approved allowance cannot be negative.</p></td>
              </tr>
            
              <tr>
                <td>CANNOT_APPROVE_FOR_ALL_FUNGIBLE_COMMON</td>
                <td>291</td>
                <td><p>[Deprecated] The approveForAll flag cannot be set for a fungible token.</p></td>
              </tr>
            
              <tr>
                <td>SPENDER_DOES_NOT_HAVE_ALLOWANCE</td>
                <td>292</td>
                <td><p>The spender does not have an existing approved allowance with the hbar/token owner.</p></td>
              </tr>
            
              <tr>
                <td>AMOUNT_EXCEEDS_ALLOWANCE</td>
                <td>293</td>
                <td><p>The transfer amount exceeds the current approved allowance for the spender account.</p></td>
              </tr>
            
              <tr>
                <td>MAX_ALLOWANCES_EXCEEDED</td>
                <td>294</td>
                <td><p>The payer account of an approveAllowances or adjustAllowance transaction is attempting
to go beyond the maximum allowed number of allowances.</p></td>
              </tr>
            
              <tr>
                <td>EMPTY_ALLOWANCES</td>
                <td>295</td>
                <td><p>No allowances have been specified in the approval transaction.</p></td>
              </tr>
            
              <tr>
                <td>SPENDER_ACCOUNT_REPEATED_IN_ALLOWANCES</td>
                <td>296</td>
                <td><p>[Deprecated] Spender is repeated more than once in Crypto or Token or NFT allowance lists in a single
CryptoApproveAllowance transaction.</p></td>
              </tr>
            
              <tr>
                <td>REPEATED_SERIAL_NUMS_IN_NFT_ALLOWANCES</td>
                <td>297</td>
                <td><p>[Deprecated] Serial numbers are repeated in nft allowance for a single spender account</p></td>
              </tr>
            
              <tr>
                <td>FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES</td>
                <td>298</td>
                <td><p>Fungible common token used in NFT allowances</p></td>
              </tr>
            
              <tr>
                <td>NFT_IN_FUNGIBLE_TOKEN_ALLOWANCES</td>
                <td>299</td>
                <td><p>Non fungible token used in fungible token allowances</p></td>
              </tr>
            
              <tr>
                <td>INVALID_ALLOWANCE_OWNER_ID</td>
                <td>300</td>
                <td><p>The account id specified as the owner is invalid or does not exist.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_ALLOWANCE_SPENDER_ID</td>
                <td>301</td>
                <td><p>The account id specified as the spender is invalid or does not exist.</p></td>
              </tr>
            
              <tr>
                <td>REPEATED_ALLOWANCES_TO_DELETE</td>
                <td>302</td>
                <td><p>[Deprecated] If the CryptoDeleteAllowance transaction has repeated crypto or token or Nft allowances to delete.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_DELEGATING_SPENDER</td>
                <td>303</td>
                <td><p>If the account Id specified as the delegating spender is invalid or does not exist.</p></td>
              </tr>
            
              <tr>
                <td>DELEGATING_SPENDER_CANNOT_GRANT_APPROVE_FOR_ALL</td>
                <td>304</td>
                <td><p>The delegating Spender cannot grant approveForAll allowance on a NFT token type for another spender.</p></td>
              </tr>
            
              <tr>
                <td>DELEGATING_SPENDER_DOES_NOT_HAVE_APPROVE_FOR_ALL</td>
                <td>305</td>
                <td><p>The delegating Spender cannot grant allowance on a NFT serial for another spender as it doesnt not have approveForAll
granted on token-owner.</p></td>
              </tr>
            
              <tr>
                <td>SCHEDULE_EXPIRATION_TIME_TOO_FAR_IN_FUTURE</td>
                <td>306</td>
                <td><p>The scheduled transaction could not be created because it&#39;s expiration_time was too far in the future.</p></td>
              </tr>
            
              <tr>
                <td>SCHEDULE_EXPIRATION_TIME_MUST_BE_HIGHER_THAN_CONSENSUS_TIME</td>
                <td>307</td>
                <td><p>The scheduled transaction could not be created because it&#39;s expiration_time was less than or equal to the consensus time.</p></td>
              </tr>
            
              <tr>
                <td>SCHEDULE_FUTURE_THROTTLE_EXCEEDED</td>
                <td>308</td>
                <td><p>The scheduled transaction could not be created because it would cause throttles to be violated on the specified expiration_time.</p></td>
              </tr>
            
              <tr>
                <td>SCHEDULE_FUTURE_GAS_LIMIT_EXCEEDED</td>
                <td>309</td>
                <td><p>The scheduled transaction could not be created because it would cause the gas limit to be violated on the specified expiration_time.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_ETHEREUM_TRANSACTION</td>
                <td>310</td>
                <td><p>The ethereum transaction either failed parsing or failed signature validation, or some other EthereumTransaction error not covered by another response code.</p></td>
              </tr>
            
              <tr>
                <td>WRONG_CHAIN_ID</td>
                <td>311</td>
                <td><p>EthereumTransaction was signed against a chainId that this network does not support.</p></td>
              </tr>
            
              <tr>
                <td>WRONG_NONCE</td>
                <td>312</td>
                <td><p>This transaction specified an ethereumNonce that is not the current ethereumNonce of the account.</p></td>
              </tr>
            
              <tr>
                <td>ACCESS_LIST_UNSUPPORTED</td>
                <td>313</td>
                <td><p>The ethereum transaction specified an access list, which the network does not support.</p></td>
              </tr>
            
              <tr>
                <td>SCHEDULE_PENDING_EXPIRATION</td>
                <td>314</td>
                <td><p>A schedule being signed or deleted has passed it&#39;s expiration date and is pending execution if needed and then expiration.</p></td>
              </tr>
            
              <tr>
                <td>CONTRACT_IS_TOKEN_TREASURY</td>
                <td>315</td>
                <td><p>A selfdestruct or ContractDelete targeted a contract that is a token treasury.</p></td>
              </tr>
            
              <tr>
                <td>CONTRACT_HAS_NON_ZERO_TOKEN_BALANCES</td>
                <td>316</td>
                <td><p>A selfdestruct or ContractDelete targeted a contract with non-zero token balances.</p></td>
              </tr>
            
              <tr>
                <td>CONTRACT_EXPIRED_AND_PENDING_REMOVAL</td>
                <td>317</td>
                <td><p>A contract referenced by a transaction is &#34;detached&#34;; that is, expired and lacking any
hbar funds for auto-renewal payment---but still within its post-expiry grace period.</p></td>
              </tr>
            
              <tr>
                <td>CONTRACT_HAS_NO_AUTO_RENEW_ACCOUNT</td>
                <td>318</td>
                <td><p>A ContractUpdate requested removal of a contract&#39;s auto-renew account, but that contract has  
no auto-renew account.</p></td>
              </tr>
            
              <tr>
                <td>PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION</td>
                <td>319</td>
                <td><p>A delete transaction submitted via HAPI set permanent_removal=true</p></td>
              </tr>
            
              <tr>
                <td>PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED</td>
                <td>320</td>
                <td><p>A CryptoCreate or ContractCreate used the deprecated proxyAccountID field.</p></td>
              </tr>
            
              <tr>
                <td>SELF_STAKING_IS_NOT_ALLOWED</td>
                <td>321</td>
                <td><p>An account set the staked_account_id to itself in CryptoUpdate or ContractUpdate transactions.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_STAKING_ID</td>
                <td>322</td>
                <td><p>The staking account id or staking node id given is invalid or does not exist.</p></td>
              </tr>
            
              <tr>
                <td>STAKING_NOT_ENABLED</td>
                <td>323</td>
                <td><p>Native staking, while implemented, has not yet enabled by the council.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_PRNG_RANGE</td>
                <td>324</td>
                <td><p>The range provided in UtilPrng transaction is negative.</p></td>
              </tr>
            
              <tr>
                <td>MAX_ENTITIES_IN_PRICE_REGIME_HAVE_BEEN_CREATED</td>
                <td>325</td>
                <td><p>The maximum number of entities allowed in the current price regime have been created.</p></td>
              </tr>
            
              <tr>
                <td>INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE</td>
                <td>326</td>
                <td><p>The full prefix signature for precompile is not valid</p></td>
              </tr>
            
          </tbody>
        </table>
      

      

      
    
      
      <div class="file-heading">
        <h2 id="response_header.proto">response_header.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.ResponseHeader">ResponseHeader</h3>
        <p>Every query receives a response containing the QueryResponseHeader. Either or both of the cost</p><p>and stateProof fields may be blank, if the responseType didn't ask for the cost or stateProof.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>nodeTransactionPrecheckCode</td>
                  <td><a href="#proto.ResponseCodeEnum">ResponseCodeEnum</a></td>
                  <td></td>
                  <td><p>Result of fee transaction precheck, saying it passed, or why it failed </p></td>
                </tr>
              
                <tr>
                  <td>responseType</td>
                  <td><a href="#proto.ResponseType">ResponseType</a></td>
                  <td></td>
                  <td><p>The requested response is repeated back here, for convenience </p></td>
                </tr>
              
                <tr>
                  <td>cost</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>The fee that would be charged to get the requested information (if a cost was requested).
Note: This cost only includes the query fee and does not include the transfer fee(which is
required to execute the transfer transaction to debit the payer account and credit the node
account with query fee) </p></td>
                </tr>
              
                <tr>
                  <td>stateProof</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The state proof for this information (if a state proof was requested, and is available) </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="schedulable_transaction_body.proto">schedulable_transaction_body.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.SchedulableTransactionBody">SchedulableTransactionBody</h3>
        <p>A schedulable transaction. Note that the global/dynamic system property</p><p><tt>scheduling.whitelist</tt> controls which transaction types may be scheduled. As of Hedera</p><p>Services 0.24.0 this list includes <tt>ConsensusSubmitMessage</tt>, <tt>CryptoTransfer</tt>, <tt>TokenMint</tt>, and <tt>TokenBurn</tt></p><p>functions.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>transactionFee</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>The maximum transaction fee the client is willing to pay </p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>A memo to include the execution record; the UTF-8 encoding may be up to 100 bytes and must not
include the zero byte </p></td>
                </tr>
              
                <tr>
                  <td>contractCall</td>
                  <td><a href="#proto.ContractCallTransactionBody">ContractCallTransactionBody</a></td>
                  <td></td>
                  <td><p>Calls a function of a contract instance </p></td>
                </tr>
              
                <tr>
                  <td>contractCreateInstance</td>
                  <td><a href="#proto.ContractCreateTransactionBody">ContractCreateTransactionBody</a></td>
                  <td></td>
                  <td><p>Creates a contract instance </p></td>
                </tr>
              
                <tr>
                  <td>contractUpdateInstance</td>
                  <td><a href="#proto.ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></td>
                  <td></td>
                  <td><p>Updates a contract </p></td>
                </tr>
              
                <tr>
                  <td>contractDeleteInstance</td>
                  <td><a href="#proto.ContractDeleteTransactionBody">ContractDeleteTransactionBody</a></td>
                  <td></td>
                  <td><p>Delete contract and transfer remaining balance into specified account </p></td>
                </tr>
              
                <tr>
                  <td>cryptoApproveAllowance</td>
                  <td><a href="#proto.CryptoApproveAllowanceTransactionBody">CryptoApproveAllowanceTransactionBody</a></td>
                  <td></td>
                  <td><p>Adds one or more approved allowances for spenders to transfer the paying account&#39;s hbar or tokens. </p></td>
                </tr>
              
                <tr>
                  <td>cryptoDeleteAllowance</td>
                  <td><a href="#proto.CryptoDeleteAllowanceTransactionBody">CryptoDeleteAllowanceTransactionBody</a></td>
                  <td></td>
                  <td><p>Deletes one or more of the specific approved NFT serial numbers on an owner account. </p></td>
                </tr>
              
                <tr>
                  <td>cryptoCreateAccount</td>
                  <td><a href="#proto.CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></td>
                  <td></td>
                  <td><p>Create a new cryptocurrency account </p></td>
                </tr>
              
                <tr>
                  <td>cryptoDelete</td>
                  <td><a href="#proto.CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></td>
                  <td></td>
                  <td><p>Delete a cryptocurrency account (mark as deleted, and transfer hbars out) </p></td>
                </tr>
              
                <tr>
                  <td>cryptoTransfer</td>
                  <td><a href="#proto.CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></td>
                  <td></td>
                  <td><p>Transfer amount between accounts </p></td>
                </tr>
              
                <tr>
                  <td>cryptoUpdateAccount</td>
                  <td><a href="#proto.CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></td>
                  <td></td>
                  <td><p>Modify information such as the expiration date for an account </p></td>
                </tr>
              
                <tr>
                  <td>fileAppend</td>
                  <td><a href="#proto.FileAppendTransactionBody">FileAppendTransactionBody</a></td>
                  <td></td>
                  <td><p>Add bytes to the end of the contents of a file </p></td>
                </tr>
              
                <tr>
                  <td>fileCreate</td>
                  <td><a href="#proto.FileCreateTransactionBody">FileCreateTransactionBody</a></td>
                  <td></td>
                  <td><p>Create a new file </p></td>
                </tr>
              
                <tr>
                  <td>fileDelete</td>
                  <td><a href="#proto.FileDeleteTransactionBody">FileDeleteTransactionBody</a></td>
                  <td></td>
                  <td><p>Delete a file (remove contents and mark as deleted until it expires) </p></td>
                </tr>
              
                <tr>
                  <td>fileUpdate</td>
                  <td><a href="#proto.FileUpdateTransactionBody">FileUpdateTransactionBody</a></td>
                  <td></td>
                  <td><p>Modify information such as the expiration date for a file </p></td>
                </tr>
              
                <tr>
                  <td>systemDelete</td>
                  <td><a href="#proto.SystemDeleteTransactionBody">SystemDeleteTransactionBody</a></td>
                  <td></td>
                  <td><p>Hedera administrative deletion of a file or smart contract </p></td>
                </tr>
              
                <tr>
                  <td>systemUndelete</td>
                  <td><a href="#proto.SystemUndeleteTransactionBody">SystemUndeleteTransactionBody</a></td>
                  <td></td>
                  <td><p>To undelete an entity deleted by SystemDelete </p></td>
                </tr>
              
                <tr>
                  <td>freeze</td>
                  <td><a href="#proto.FreezeTransactionBody">FreezeTransactionBody</a></td>
                  <td></td>
                  <td><p>Freeze the nodes </p></td>
                </tr>
              
                <tr>
                  <td>consensusCreateTopic</td>
                  <td><a href="#proto.ConsensusCreateTopicTransactionBody">ConsensusCreateTopicTransactionBody</a></td>
                  <td></td>
                  <td><p>Creates a topic </p></td>
                </tr>
              
                <tr>
                  <td>consensusUpdateTopic</td>
                  <td><a href="#proto.ConsensusUpdateTopicTransactionBody">ConsensusUpdateTopicTransactionBody</a></td>
                  <td></td>
                  <td><p>Updates a topic </p></td>
                </tr>
              
                <tr>
                  <td>consensusDeleteTopic</td>
                  <td><a href="#proto.ConsensusDeleteTopicTransactionBody">ConsensusDeleteTopicTransactionBody</a></td>
                  <td></td>
                  <td><p>Deletes a topic </p></td>
                </tr>
              
                <tr>
                  <td>consensusSubmitMessage</td>
                  <td><a href="#proto.ConsensusSubmitMessageTransactionBody">ConsensusSubmitMessageTransactionBody</a></td>
                  <td></td>
                  <td><p>Submits message to a topic </p></td>
                </tr>
              
                <tr>
                  <td>tokenCreation</td>
                  <td><a href="#proto.TokenCreateTransactionBody">TokenCreateTransactionBody</a></td>
                  <td></td>
                  <td><p>Creates a token instance </p></td>
                </tr>
              
                <tr>
                  <td>tokenFreeze</td>
                  <td><a href="#proto.TokenFreezeAccountTransactionBody">TokenFreezeAccountTransactionBody</a></td>
                  <td></td>
                  <td><p>Freezes account not to be able to transact with a token </p></td>
                </tr>
              
                <tr>
                  <td>tokenUnfreeze</td>
                  <td><a href="#proto.TokenUnfreezeAccountTransactionBody">TokenUnfreezeAccountTransactionBody</a></td>
                  <td></td>
                  <td><p>Unfreezes account for a token </p></td>
                </tr>
              
                <tr>
                  <td>tokenGrantKyc</td>
                  <td><a href="#proto.TokenGrantKycTransactionBody">TokenGrantKycTransactionBody</a></td>
                  <td></td>
                  <td><p>Grants KYC to an account for a token </p></td>
                </tr>
              
                <tr>
                  <td>tokenRevokeKyc</td>
                  <td><a href="#proto.TokenRevokeKycTransactionBody">TokenRevokeKycTransactionBody</a></td>
                  <td></td>
                  <td><p>Revokes KYC of an account for a token </p></td>
                </tr>
              
                <tr>
                  <td>tokenDeletion</td>
                  <td><a href="#proto.TokenDeleteTransactionBody">TokenDeleteTransactionBody</a></td>
                  <td></td>
                  <td><p>Deletes a token instance </p></td>
                </tr>
              
                <tr>
                  <td>tokenUpdate</td>
                  <td><a href="#proto.TokenUpdateTransactionBody">TokenUpdateTransactionBody</a></td>
                  <td></td>
                  <td><p>Updates a token instance </p></td>
                </tr>
              
                <tr>
                  <td>tokenMint</td>
                  <td><a href="#proto.TokenMintTransactionBody">TokenMintTransactionBody</a></td>
                  <td></td>
                  <td><p>Mints new tokens to a token&#39;s treasury account </p></td>
                </tr>
              
                <tr>
                  <td>tokenBurn</td>
                  <td><a href="#proto.TokenBurnTransactionBody">TokenBurnTransactionBody</a></td>
                  <td></td>
                  <td><p>Burns tokens from a token&#39;s treasury account </p></td>
                </tr>
              
                <tr>
                  <td>tokenWipe</td>
                  <td><a href="#proto.TokenWipeAccountTransactionBody">TokenWipeAccountTransactionBody</a></td>
                  <td></td>
                  <td><p>Wipes amount of tokens from an account </p></td>
                </tr>
              
                <tr>
                  <td>tokenAssociate</td>
                  <td><a href="#proto.TokenAssociateTransactionBody">TokenAssociateTransactionBody</a></td>
                  <td></td>
                  <td><p>Associate tokens to an account </p></td>
                </tr>
              
                <tr>
                  <td>tokenDissociate</td>
                  <td><a href="#proto.TokenDissociateTransactionBody">TokenDissociateTransactionBody</a></td>
                  <td></td>
                  <td><p>Dissociate tokens from an account </p></td>
                </tr>
              
                <tr>
                  <td>token_fee_schedule_update</td>
                  <td><a href="#proto.TokenFeeScheduleUpdateTransactionBody">TokenFeeScheduleUpdateTransactionBody</a></td>
                  <td></td>
                  <td><p>Updates a token&#39;s custom fee schedule </p></td>
                </tr>
              
                <tr>
                  <td>token_pause</td>
                  <td><a href="#proto.TokenPauseTransactionBody">TokenPauseTransactionBody</a></td>
                  <td></td>
                  <td><p>Pauses the Token </p></td>
                </tr>
              
                <tr>
                  <td>token_unpause</td>
                  <td><a href="#proto.TokenUnpauseTransactionBody">TokenUnpauseTransactionBody</a></td>
                  <td></td>
                  <td><p>Unpauses the Token </p></td>
                </tr>
              
                <tr>
                  <td>scheduleDelete</td>
                  <td><a href="#proto.ScheduleDeleteTransactionBody">ScheduleDeleteTransactionBody</a></td>
                  <td></td>
                  <td><p>Marks a schedule in the network&#39;s action queue as deleted, preventing it from executing </p></td>
                </tr>
              
                <tr>
                  <td>util_prng</td>
                  <td><a href="#proto.UtilPrngTransactionBody">UtilPrngTransactionBody</a></td>
                  <td></td>
                  <td><p>Generates a pseudorandom number. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="schedule_create.proto">schedule_create.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.ScheduleCreateTransactionBody">ScheduleCreateTransactionBody</h3>
        <p>Create a new <i>schedule entity</i> (or simply, <i>schedule</i>) in the network's action queue.</p><p>Upon <tt>SUCCESS</tt>, the receipt contains the `ScheduleID` of the created schedule. A schedule</p><p>entity includes a <tt>scheduledTransactionBody</tt> to be executed.</p><p>When the schedule has collected enough signing Ed25519 keys to satisfy the schedule's signing</p><p>requirements, the schedule can be executed.</p><p>If Long Term Scheduled Transactions are enabled and <tt>wait_for_expiry</tt> is set to <tt>true</tt>, then the schedule</p><p>will execute at it's <tt>expiration_time</tt>.</p><p>Otherwise it will execute immediately after the transaction that provided enough Ed25519 keys, a <tt>ScheduleCreate</tt></p><p>or <tt>ScheduleSign</tt>.</p><p>Upon `SUCCESS`, the receipt also includes the <tt>scheduledTransactionID</tt> to</p><p>use to query for the record of the scheduled transaction's execution (if it occurs). </p><p>The expiration time of a schedule is controlled by it's <tt>expiration_time</tt>. It remains in state and can be queried</p><p>using <tt>GetScheduleInfo</tt> until expiration, no matter if the scheduled transaction has</p><p>executed or marked deleted. If Long Term Scheduled Transactions are disabled, the <tt>expiration_time</tt> is always</p><p>30 minutes in the future.</p><p>If the <tt>adminKey</tt> field is omitted, the resulting schedule is immutable. If the</p><p><tt>adminKey</tt> is set, the <tt>ScheduleDelete</tt> transaction can be used to mark it as</p><p>deleted. The creator may also specify an optional <tt>memo</tt> whose UTF-8 encoding is at most</p><p>100 bytes and does not include the zero byte is also supported.</p><p>When a <tt>scheduledTransactionBody</tt> is executed, the</p><p>network only charges its payer the service fee, and not the node and network fees. If the</p><p>optional <tt>payerAccountID</tt> is set, the network charges this account. Otherwise it charges</p><p>the payer of the originating <tt>ScheduleCreate</tt>.  </p><p>Two <tt>ScheduleCreate</tt> transactions are <i>identical</i> if they are equal in all their</p><p>fields other than <tt>payerAccountID</tt>.  (For the <tt>scheduledTransactionBody</tt> field,</p><p>"equal" should be understood in the sense of</p><p>gRPC object equality in the network software runtime. In particular, a gRPC object with <a</p><p>href="https://developers.google.com/protocol-buffers/docs/proto3#unknowns">unknown fields</a> is</p><p>not equal to a gRPC object without unknown fields, even if they agree on all known fields.) </p><p>A <tt>ScheduleCreate</tt> transaction that attempts to re-create an identical schedule already in</p><p>state will receive a receipt with status <tt>IDENTICAL_SCHEDULE_ALREADY_CREATED</tt>; the receipt</p><p>will include the <tt>ScheduleID</tt> of the extant schedule, which may be used in a subsequent</p><p><tt>ScheduleSign</tt> transaction. (The receipt will also include the <tt>TransactionID</tt> to</p><p>use in querying for the receipt or record of the scheduled transaction.)</p><p>Other notable response codes include, <tt>INVALID_ACCOUNT_ID</tt>,</p><p><tt>UNSCHEDULABLE_TRANSACTION</tt>, <tt>UNRESOLVABLE_REQUIRED_SIGNERS</tt>,</p><p><tt>INVALID_SIGNATURE</tt>. For more information please see the section of this documentation on</p><p>the <tt>ResponseCode</tt> enum.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>scheduledTransactionBody</td>
                  <td><a href="#proto.SchedulableTransactionBody">SchedulableTransactionBody</a></td>
                  <td></td>
                  <td><p>The scheduled transaction </p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>An optional memo with a UTF-8 encoding of no more than 100 bytes which does not contain the
zero byte </p></td>
                </tr>
              
                <tr>
                  <td>adminKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>An optional Hedera key which can be used to sign a ScheduleDelete and remove the schedule </p></td>
                </tr>
              
                <tr>
                  <td>payerAccountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>An optional id of the account to be charged the service fee for the scheduled transaction at
the consensus time that it executes (if ever); defaults to the ScheduleCreate payer if not
given </p></td>
                </tr>
              
                <tr>
                  <td>expiration_time</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>An optional timestamp for specifying when the transaction should be evaluated for execution and then expire.
Defaults to 30 minutes after the transaction&#39;s consensus timestamp.

Note: This field is unused and forced to be unset until Long Term Scheduled Transactions are enabled - Transactions will always
      expire in 30 minutes if Long Term Scheduled Transactions are not enabled. </p></td>
                </tr>
              
                <tr>
                  <td>wait_for_expiry</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>When set to true, the transaction will be evaluated for execution at expiration_time instead
of when all required signatures are received.
When set to false, the transaction will execute immediately after sufficient signatures are received
to sign the contained transaction. During the initial ScheduleCreate transaction or via ScheduleSign transactions.

Defaults to false.

Setting this to false does not necessarily mean that the transaction will never execute at expiration_time.
 For Example - If the signature requirements for a Scheduled Transaction change via external means (e.g. CryptoUpdate)
 such that the Scheduled Transaction would be allowed to execute, it will do so autonomously at expiration_time, unless a
 ScheduleSign comes in to “poke” it and force it to go through immediately.

Note: This field is unused and forced to be unset until Long Term Scheduled Transactions are enabled. Before Long Term
      Scheduled Transactions are enabled, Scheduled Transactions will _never_ execute at expiration  - they will _only_
      execute during the initial ScheduleCreate transaction or via ScheduleSign transactions and will _always_
      expire at expiration_time. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="schedule_delete.proto">schedule_delete.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.ScheduleDeleteTransactionBody">ScheduleDeleteTransactionBody</h3>
        <p>Marks a schedule in the network's action queue as deleted. Must be signed by the admin key of the</p><p>target schedule.  A deleted schedule cannot receive any additional signing keys, nor will it be</p><p>executed.</p><p>Other notable response codes include, <tt>INVALID_SCHEDULE_ID</tt>, <tt>SCHEDULE_PENDING_EXPIRATION</tt>,</p><p><tt>SCHEDULE_ALREADY_DELETED</tt>, <tt>SCHEDULE_ALREADY_EXECUTED</tt>, <tt>SCHEDULE_IS_IMMUTABLE</tt>.</p><p>For more information please see the section of this documentation on the <tt>ResponseCode</tt></p><p>enum.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>scheduleID</td>
                  <td><a href="#proto.ScheduleID">ScheduleID</a></td>
                  <td></td>
                  <td><p>The ID of the Scheduled Entity </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="schedule_get_info.proto">schedule_get_info.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.ScheduleGetInfoQuery">ScheduleGetInfoQuery</h3>
        <p>Gets information about a schedule in the network's action queue.</p><p>Responds with <tt>INVALID_SCHEDULE_ID</tt> if the requested schedule doesn't exist.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>standard info sent from client to node including the signed payment, and what kind of response
is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>scheduleID</td>
                  <td><a href="#proto.ScheduleID">ScheduleID</a></td>
                  <td></td>
                  <td><p>The id of the schedule to interrogate </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.ScheduleGetInfoResponse">ScheduleGetInfoResponse</h3>
        <p>Response wrapper for the <tt>ScheduleInfo</tt></p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof, or
both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>scheduleInfo</td>
                  <td><a href="#proto.ScheduleInfo">ScheduleInfo</a></td>
                  <td></td>
                  <td><p>The information requested about this schedule instance </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.ScheduleInfo">ScheduleInfo</h3>
        <p>Information summarizing schedule state</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>scheduleID</td>
                  <td><a href="#proto.ScheduleID">ScheduleID</a></td>
                  <td></td>
                  <td><p>The id of the schedule </p></td>
                </tr>
              
                <tr>
                  <td>deletion_time</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>If the schedule has been deleted, the consensus time when this occurred </p></td>
                </tr>
              
                <tr>
                  <td>execution_time</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>If the schedule has been executed, the consensus time when this occurred </p></td>
                </tr>
              
                <tr>
                  <td>expirationTime</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>The time at which the schedule will be evaluated for execution and then expire.

Note: Before Long Term Scheduled Transactions are enabled, Scheduled Transactions will _never_ execute at expiration - they
      will _only_ execute during the initial ScheduleCreate transaction or via ScheduleSign transactions and will _always_
      expire at expirationTime. </p></td>
                </tr>
              
                <tr>
                  <td>scheduledTransactionBody</td>
                  <td><a href="#proto.SchedulableTransactionBody">SchedulableTransactionBody</a></td>
                  <td></td>
                  <td><p>The scheduled transaction </p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The publicly visible memo of the schedule </p></td>
                </tr>
              
                <tr>
                  <td>adminKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The key used to delete the schedule from state </p></td>
                </tr>
              
                <tr>
                  <td>signers</td>
                  <td><a href="#proto.KeyList">KeyList</a></td>
                  <td></td>
                  <td><p>The Ed25519 keys the network deems to have signed the scheduled transaction </p></td>
                </tr>
              
                <tr>
                  <td>creatorAccountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The id of the account that created the schedule </p></td>
                </tr>
              
                <tr>
                  <td>payerAccountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The id of the account responsible for the service fee of the scheduled transaction </p></td>
                </tr>
              
                <tr>
                  <td>scheduledTransactionID</td>
                  <td><a href="#proto.TransactionID">TransactionID</a></td>
                  <td></td>
                  <td><p>The transaction id that will be used in the record of the scheduled transaction (if it
executes) </p></td>
                </tr>
              
                <tr>
                  <td>ledger_id</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The ledger ID the response was returned from; please see &lt;a href=&#34;https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md&#34;&gt;HIP-198&lt;/a&gt; for the network-specific IDs. </p></td>
                </tr>
              
                <tr>
                  <td>wait_for_expiry</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>When set to true, the transaction will be evaluated for execution at expiration_time instead
of when all required signatures are received.
When set to false, the transaction will execute immediately after sufficient signatures are received
to sign the contained transaction. During the initial ScheduleCreate transaction or via ScheduleSign transactions.

Note: this field is unused until Long Term Scheduled Transactions are enabled. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="schedule_service.proto">schedule_service.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      

      

      

      
        <h3 id="proto.ScheduleService">ScheduleService</h3>
        <p>Transactions and queries for the Schedule Service</p><p>The Schedule Service allows transactions to be submitted without all the required signatures and</p><p>allows anyone to provide the required signatures independently after a transaction has already</p><p>been created. The transactions can be executed immediately when all required signatures are received</p><p>or at a future date if Long Term Scheduled Transactions are enabled.</p><p>Execution:</p><p>Scheduled Transactions are executed in two different modes.</p><p>1. If Long Term Scheduled Transactions are enabled and <tt>wait_for_expiry</tt> was set to <tt>true</tt> on the</p><p><tt>ScheduleCreate</tt>, then the transaction will be executed at the <tt>expiration_time</tt> specified on the</p><p><tt>ScheduleCreate</tt>.</p><p>2. Otherwise Scheduled Transactions are executed once all required signatures are collected and witnessed.</p><p>Every time new signature is provided, a check is performed on the "readiness" of the execution.</p><p>The Scheduled Transaction will be executed immediately after the transaction that triggered it.</p><p>NOTICE:</p><p>A Scheduled Transaction being ready to execute, or even not ready to execute, at the time a <tt>ScheduleCreate</tt> or</p><p><tt>ScheduleSign</tt> comes in does not guarantee it will stay that way. Any number of things can happen over time that</p><p>impact the transaction.</p><p>For example, account keys can change, accounts can be deleted, and account balances can change.</p><p>A particularly noteworthy case is if Long Term Scheduled Transactions are enabled and signature requirements for a Scheduled</p><p>Transaction change such that existing signatures become sufficient to allow the transaction to go through. In this case the transaction</p><p>will execute at expiration_time unless a ScheduleSign comes in to push it through.</p><p>Transaction Record:</p><p>If a Scheduled Transaction is executed immediately following the transaction that provided all required signatures,</p><p>the timestamp of the Scheduled Transaction will be equal to consensusTimestamp + 1 nano, where</p><p>consensusTimestamp is the timestamp of the transaction that triggered the execution.</p><p>The Transaction ID of the Scheduled Transaction will have the scheduled property set to true and</p><p>inherit the <tt>transactionValidStart</tt> and <tt>accountID</tt> from the <tt>ScheduleCreate</tt> transaction.</p><p>The <tt>scheduleRef</tt> property of the transaction record will be populated with the <tt>ScheduleID</tt> of the</p><p>Scheduled Transaction.</p><p>Post execution:</p><p>After execution, a Scheduled Transaction will remain in state and can be queried using <tt>GetScheduleInfo</tt> until expiration.</p><p>Expiry:</p><p>The expiration time of a schedule is controlled by it's <tt>expiration_time</tt>. If Long Term Scheduled Transactions are disabled,</p><p>the <tt>expiration_time</tt> is always 30 minutes in the future.</p><p>Once a given Scheduled Transaction expires, it will be removed from the ledger and any upcoming</p><p>operation referring the ScheduleID will resolve to INVALID_SCHEDULE_ID.</p>
        <table class="enum-table">
          <thead>
            <tr><td>Method Name</td><td>Request Type</td><td>Response Type</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>createSchedule</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Creates a new Schedule by submitting the transaction</p></td>
              </tr>
            
              <tr>
                <td>signSchedule</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Signs a new Schedule by submitting the transaction</p></td>
              </tr>
            
              <tr>
                <td>deleteSchedule</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Deletes a new Schedule by submitting the transaction</p></td>
              </tr>
            
              <tr>
                <td>getScheduleInfo</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>Retrieves the metadata of a schedule entity</p></td>
              </tr>
            
          </tbody>
        </table>

        
    
      
      <div class="file-heading">
        <h2 id="schedule_sign.proto">schedule_sign.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.ScheduleSignTransactionBody">ScheduleSignTransactionBody</h3>
        <p>Adds zero or more signing keys to a schedule.</p><p>If Long Term Scheduled Transactions are enabled and <tt>wait_for_expiry</tt> was set to <tt>true</tt> on the</p><p><tt>ScheduleCreate</tt> then the transaction will always wait till it's `expiration_time` to execute.</p><p>Otherwise, if the resulting set of signing keys satisfy the</p><p>scheduled transaction's signing requirements, it will be executed immediately after the</p><p>triggering <tt>ScheduleSign</tt>.</p><p>Upon <tt>SUCCESS</tt>, the receipt includes the <tt>scheduledTransactionID</tt> to use to query</p><p>for the record of the scheduled transaction's execution (if it occurs). </p><p>Other notable response codes include <tt>INVALID_SCHEDULE_ID</tt>, <tt>SCHEDULE_ALREADY_DELETED</tt>,</p><p><tt>SCHEDULE_PENDING_EXPIRATION</tt>, <tt>SCHEDULE_ALREADY_EXPIRED</tt>,</p><p><tt>INVALID_ACCOUNT_ID</tt>, <tt>UNRESOLVABLE_REQUIRED_SIGNERS</tt>,</p><p><tt>SOME_SIGNATURES_WERE_INVALID</tt>, and <tt>NO_NEW_VALID_SIGNATURES</tt>. For more information</p><p>please see the section of this documentation on the <tt>ResponseCode</tt> enum.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>scheduleID</td>
                  <td><a href="#proto.ScheduleID">ScheduleID</a></td>
                  <td></td>
                  <td><p>The id of the schedule to add signing keys to </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="smart_contract_service.proto">smart_contract_service.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      

      

      

      
        <h3 id="proto.SmartContractService">SmartContractService</h3>
        <p>Transactions and queries for the file service.</p>
        <table class="enum-table">
          <thead>
            <tr><td>Method Name</td><td>Request Type</td><td>Response Type</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>createContract</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Creates a contract</p></td>
              </tr>
            
              <tr>
                <td>updateContract</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Updates a contract with the content</p></td>
              </tr>
            
              <tr>
                <td>contractCallMethod</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Calls a contract</p></td>
              </tr>
            
              <tr>
                <td>getContractInfo</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>Retrieves the contract information</p></td>
              </tr>
            
              <tr>
                <td>contractCallLocalMethod</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>Calls a smart contract to be run on a single node</p></td>
              </tr>
            
              <tr>
                <td>ContractGetBytecode</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>Retrieves the runtime code of a contract</p></td>
              </tr>
            
              <tr>
                <td>getBySolidityID</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>Retrieves a contract by its Solidity address</p></td>
              </tr>
            
              <tr>
                <td>getTxRecordByContractID</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>Always returns an empty record list, as contract accounts are never effective payers for
transactions</p></td>
              </tr>
            
              <tr>
                <td>deleteContract</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Deletes a contract instance and transfers any remaining hbars to a specified receiver</p></td>
              </tr>
            
              <tr>
                <td>systemDelete</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Deletes a contract if the submitting account has network admin privileges</p></td>
              </tr>
            
              <tr>
                <td>systemUndelete</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Undeletes a contract if the submitting account has network admin privileges</p></td>
              </tr>
            
              <tr>
                <td>callEthereum</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Ethereum transaction</p></td>
              </tr>
            
          </tbody>
        </table>

        
          
          
          <h4>Methods with deprecated option</h4>
          <table>
            <thead>
              <tr>
                <td>Method Name</td>
                <td>Option</td>
              </tr>
            </thead>
            <tbody>
            
              <tr>
                <td>getTxRecordByContractID</td>
                <td><p>true</p></td>
              </tr>
            
            </tbody>
          </table>
          
        
    
      
      <div class="file-heading">
        <h2 id="system_delete.proto">system_delete.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.SystemDeleteTransactionBody">SystemDeleteTransactionBody</h3>
        <p>Delete a file or smart contract - can only be done with a Hedera administrative multisignature.</p><p>When it is deleted, it immediately disappears from the system as seen by the user, but is still</p><p>stored internally until the expiration time, at which time it is truly and permanently deleted.</p><p>Until that time, it can be undeleted by the Hedera administrative multisignature. When a smart</p><p>contract is deleted, the cryptocurrency account within it continues to exist, and is not affected</p><p>by the expiration time here.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>fileID</td>
                  <td><a href="#proto.FileID">FileID</a></td>
                  <td></td>
                  <td><p>The file ID of the file to delete, in the format used in transactions </p></td>
                </tr>
              
                <tr>
                  <td>contractID</td>
                  <td><a href="#proto.ContractID">ContractID</a></td>
                  <td></td>
                  <td><p>The contract ID instance to delete, in the format used in transactions </p></td>
                </tr>
              
                <tr>
                  <td>expirationTime</td>
                  <td><a href="#proto.TimestampSeconds">TimestampSeconds</a></td>
                  <td></td>
                  <td><p>The timestamp in seconds at which the &#34;deleted&#34; file should truly be permanently deleted </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="system_undelete.proto">system_undelete.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.SystemUndeleteTransactionBody">SystemUndeleteTransactionBody</h3>
        <p>Undelete a file or smart contract that was deleted by SystemDelete; requires a Hedera</p><p>administrative multisignature.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>fileID</td>
                  <td><a href="#proto.FileID">FileID</a></td>
                  <td></td>
                  <td><p>The file ID to undelete, in the format used in transactions </p></td>
                </tr>
              
                <tr>
                  <td>contractID</td>
                  <td><a href="#proto.ContractID">ContractID</a></td>
                  <td></td>
                  <td><p>The contract ID instance to undelete, in the format used in transactions </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="throttle_definitions.proto">throttle_definitions.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.ThrottleBucket">ThrottleBucket</h3>
        <p>A list of throttle groups that should all compete for the same internal bucket.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>name</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>A name for this bucket (primarily for use in logs) </p></td>
                </tr>
              
                <tr>
                  <td>burstPeriodMs</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>The number of milliseconds required for this bucket to drain completely when full. The product
of this number and the least common multiple of the milliOpsPerSec values in this bucket must
not exceed 9223372036. </p></td>
                </tr>
              
                <tr>
                  <td>throttleGroups</td>
                  <td><a href="#proto.ThrottleGroup">ThrottleGroup</a></td>
                  <td>repeated</td>
                  <td><p>The throttle groups competing for this bucket </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.ThrottleDefinitions">ThrottleDefinitions</h3>
        <p>A list of throttle buckets which, simultaneously enforced, define the system's throttling policy.</p><p><ol></p><p><li> When an operation appears in more than one throttling bucket, all its buckets must have room</p><p>or it will be throttled.</li> </p><p><li>An operation assigned to no buckets is always throttled.</li></p><p></ol></p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>throttleBuckets</td>
                  <td><a href="#proto.ThrottleBucket">ThrottleBucket</a></td>
                  <td>repeated</td>
                  <td><p> </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.ThrottleGroup">ThrottleGroup</h3>
        <p>A set of operations which should be collectively throttled at a given milli-ops-per-second limit.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>operations</td>
                  <td><a href="#proto.HederaFunctionality">HederaFunctionality</a></td>
                  <td>repeated</td>
                  <td><p>The operations to be throttled </p></td>
                </tr>
              
                <tr>
                  <td>milliOpsPerSec</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>The number of total operations per second across the entire network, multiplied by 1000. So, to
choose 3 operations per second (which on a network of 30 nodes is a tenth of an operation per
second for each node), set milliOpsPerSec = 3000. And to choose 3.6 ops per second, use
milliOpsPerSec = 3600. Minimum allowed value is 1, and maximum allowed value is 9223372. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="timestamp.proto">timestamp.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.Timestamp">Timestamp</h3>
        <p>An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the</p><p>comments in https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto)</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>seconds</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>Number of complete seconds since the start of the epoch </p></td>
                </tr>
              
                <tr>
                  <td>nanos</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p>Number of nanoseconds since the start of the last second </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.TimestampSeconds">TimestampSeconds</h3>
        <p>An exact date and time,  with a resolution of one second (no nanoseconds).</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>seconds</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>Number of complete seconds since the start of the epoch </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="token_associate.proto">token_associate.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TokenAssociateTransactionBody">TokenAssociateTransactionBody</h3>
        <p>Associates the provided account with the provided tokens. Must be signed by the provided</p><p>Account's key.</p><p>If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.</p><p>If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.</p><p>If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.</p><p>If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.</p><p>If an association between the provided account and any of the tokens already exists, the</p><p>transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.</p><p>If the provided account's associations count exceed the constraint of maximum token associations</p><p>per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.</p><p>On success, associations between the provided account and tokens are made and the account is</p><p>ready to interact with the tokens.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>account</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account to be associated with the provided tokens </p></td>
                </tr>
              
                <tr>
                  <td>tokens</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td>repeated</td>
                  <td><p>The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE
Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that
token type </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="token_burn.proto">token_burn.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TokenBurnTransactionBody">TokenBurnTransactionBody</h3>
        <p>Burns tokens from the Token's treasury Account. If no Supply Key is defined, the transaction will</p><p>resolve to TOKEN_HAS_NO_SUPPLY_KEY.</p><p>The operation decreases the Total Supply of the Token. Total supply cannot go below zero.</p><p>The amount provided must be in the lowest denomination possible. Example:</p><p>Token A has 2 decimals. In order to burn 100 tokens, one must provide amount of 10000. In order</p><p>to burn 100.55 tokens, one must provide amount of 10055.</p><p>For non fungible tokens the transaction body accepts serialNumbers list of integers as a parameter.</p><p>If neither the amount nor the serialNumbers get filled, a INVALID_TOKEN_BURN_AMOUNT response code</p><p>will be returned.</p><p>If both amount and serialNumbers get filled, a INVALID_TRANSACTION_BODY response code will be</p><p>returned.</p><p>If the serialNumbers' list count is greater than the batch size limit global dynamic property, a</p><p>BATCH_SIZE_LIMIT_EXCEEDED response code will be returned.</p><p>If the serialNumbers list contains a non-positive integer as a serial number, a INVALID_NFT_ID</p><p>response code will be returned.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>token</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The token for which to burn tokens. If token does not exist, transaction results in
INVALID_TOKEN_ID </p></td>
                </tr>
              
                <tr>
                  <td>amount</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.
Amount must be a positive non-zero number, not bigger than the token balance of the treasury
account (0; balance], represented in the lowest denomination. </p></td>
                </tr>
              
                <tr>
                  <td>serialNumbers</td>
                  <td><a href="#int64">int64</a></td>
                  <td>repeated</td>
                  <td><p>Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="token_create.proto">token_create.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TokenCreateTransactionBody">TokenCreateTransactionBody</h3>
        <p>Create a new token. After the token is created, the Token ID for it is in the receipt.</p><p>The specified Treasury Account is receiving the initial supply of tokens as-well as the tokens</p><p>from the Token Mint operation once executed. The balance of the treasury account is decreased</p><p>when the Token Burn operation is executed.</p><p>The <tt>initialSupply</tt> is the initial supply of the smallest parts of a token (like a</p><p>tinybar, not an hbar). These are the smallest units of the token which may be transferred.</p><p>The supply can change over time. If the total supply at some moment is <i>S</i> parts of tokens,</p><p>and the token is using <i>D</i> decimals, then <i>S</i> must be less than or equal to</p><p>2<sup>63</sup>-1, which is 9,223,372,036,854,775,807. The number of whole tokens (not parts) will</p><p>be <i>S / 10<sup>D</sup></i>.</p><p>If decimals is 8 or 11, then the number of whole tokens can be at most a few billions or</p><p>millions, respectively. For example, it could match Bitcoin (21 million whole tokens with 8</p><p>decimals) or hbars (50 billion whole tokens with 8 decimals). It could even match Bitcoin with</p><p>milli-satoshis (21 million whole tokens with 11 decimals).</p><p>Note that a created token is <i>immutable</i> if the <tt>adminKey</tt> is omitted. No property of</p><p>an immutable token can ever change, with the sole exception of its expiry. Anyone can pay to</p><p>extend the expiry time of an immutable token.</p><p>A token can be either <i>FUNGIBLE_COMMON</i> or <i>NON_FUNGIBLE_UNIQUE</i>, based on its</p><p><i>TokenType</i>. If it has been omitted, <i>FUNGIBLE_COMMON</i> type is used.</p><p>A token can have either <i>INFINITE</i> or <i>FINITE</i> supply type, based on its</p><p><i>TokenType</i>. If it has been omitted, <i>INFINITE</i> type is used.</p><p>If a <i>FUNGIBLE</i> TokenType is used, <i>initialSupply</i> should explicitly be set to a</p><p>non-negative. If not, the transaction will resolve to INVALID_TOKEN_INITIAL_SUPPLY.</p><p>If a <i>NON_FUNGIBLE_UNIQUE</i> TokenType is used, <i>initialSupply</i> should explicitly be set</p><p>to 0. If not, the transaction will resolve to INVALID_TOKEN_INITIAL_SUPPLY.</p><p>If an <i>INFINITE</i> TokenSupplyType is used, <i>maxSupply</i> should explicitly be set to 0. If</p><p>it is not 0, the transaction will resolve to INVALID_TOKEN_MAX_SUPPLY.</p><p>If a <i>FINITE</i> TokenSupplyType is used, <i>maxSupply</i> should be explicitly set to a</p><p>non-negative value. If it is not, the transaction will resolve to INVALID_TOKEN_MAX_SUPPLY.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>name</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The publicly visible name of the token. The token name is specified as a Unicode string. 
Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL). </p></td>
                </tr>
              
                <tr>
                  <td>symbol</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The publicly visible token symbol. The token symbol is specified as a Unicode string. 
Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL). </p></td>
                </tr>
              
                <tr>
                  <td>decimals</td>
                  <td><a href="#uint32">uint32</a></td>
                  <td></td>
                  <td><p>For tokens of type FUNGIBLE_COMMON - the number of decimal places a
token is divisible by. For tokens of type NON_FUNGIBLE_UNIQUE - value
must be 0 </p></td>
                </tr>
              
                <tr>
                  <td>initialSupply</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>Specifies the initial supply of tokens to be put in circulation. The
initial supply is sent to the Treasury Account. The supply is in the
lowest denomination possible. In the case for NON_FUNGIBLE_UNIQUE Type
the value must be 0 </p></td>
                </tr>
              
                <tr>
                  <td>treasury</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account which will act as a treasury for the token. This account
will receive the specified initial supply or the newly minted NFTs in
the case for NON_FUNGIBLE_UNIQUE Type </p></td>
                </tr>
              
                <tr>
                  <td>adminKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The key which can perform update/delete operations on the token. If empty, the token can be
perceived as immutable (not being able to be updated/deleted) </p></td>
                </tr>
              
                <tr>
                  <td>kycKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The key which can grant or revoke KYC of an account for the token&#39;s transactions. If empty,
KYC is not required, and KYC grant or revoke operations are not possible. </p></td>
                </tr>
              
                <tr>
                  <td>freezeKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The key which can sign to freeze or unfreeze an account for token transactions. If empty,
freezing is not possible </p></td>
                </tr>
              
                <tr>
                  <td>wipeKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The key which can wipe the token balance of an account. If empty, wipe is not possible </p></td>
                </tr>
              
                <tr>
                  <td>supplyKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The key which can change the supply of a token. The key is used to sign Token Mint/Burn
operations </p></td>
                </tr>
              
                <tr>
                  <td>freezeDefault</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>The default Freeze status (frozen or unfrozen) of Hedera accounts relative to this token. If
true, an account must be unfrozen before it can receive the token </p></td>
                </tr>
              
                <tr>
                  <td>expiry</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>The epoch second at which the token should expire; if an auto-renew account and period are
specified, this is coerced to the current epoch second plus the autoRenewPeriod </p></td>
                </tr>
              
                <tr>
                  <td>autoRenewAccount</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>An account which will be automatically charged to renew the token&#39;s expiration, at
autoRenewPeriod interval </p></td>
                </tr>
              
                <tr>
                  <td>autoRenewPeriod</td>
                  <td><a href="#proto.Duration">Duration</a></td>
                  <td></td>
                  <td><p>The interval at which the auto-renew account will be charged to extend the token&#39;s expiry </p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The memo associated with the token (UTF-8 encoding max 100 bytes) </p></td>
                </tr>
              
                <tr>
                  <td>tokenType</td>
                  <td><a href="#proto.TokenType">TokenType</a></td>
                  <td></td>
                  <td><p>IWA compatibility. Specifies the token type. Defaults to FUNGIBLE_COMMON </p></td>
                </tr>
              
                <tr>
                  <td>supplyType</td>
                  <td><a href="#proto.TokenSupplyType">TokenSupplyType</a></td>
                  <td></td>
                  <td><p>IWA compatibility. Specified the token supply type. Defaults to INFINITE </p></td>
                </tr>
              
                <tr>
                  <td>maxSupply</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>IWA Compatibility. Depends on TokenSupplyType. For tokens of type FUNGIBLE_COMMON - the
maximum number of tokens that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE -
the maximum number of NFTs (serial numbers) that can be minted. This field can never be
changed! </p></td>
                </tr>
              
                <tr>
                  <td>fee_schedule_key</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The key which can change the token&#39;s custom fee schedule; must sign a TokenFeeScheduleUpdate
transaction </p></td>
                </tr>
              
                <tr>
                  <td>custom_fees</td>
                  <td><a href="#proto.CustomFee">CustomFee</a></td>
                  <td>repeated</td>
                  <td><p>The custom fees to be assessed during a CryptoTransfer that transfers units of this token </p></td>
                </tr>
              
                <tr>
                  <td>pause_key</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The Key which can pause and unpause the Token.
If Empty the token pause status defaults to PauseNotApplicable, otherwise Unpaused. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="token_delete.proto">token_delete.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TokenDeleteTransactionBody">TokenDeleteTransactionBody</h3>
        <p>Marks a token as deleted, though it will remain in the ledger.</p><p>The operation must be signed by the specified Admin Key of the Token. If</p><p>admin key is not set, Transaction will result in TOKEN_IS_IMMUTABlE.</p><p>Once deleted update, mint, burn, wipe, freeze, unfreeze, grant kyc, revoke</p><p>kyc and token transfer transactions will resolve to TOKEN_WAS_DELETED.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>token</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The token to be deleted. If invalid token is specified, transaction will
result in INVALID_TOKEN_ID </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="token_dissociate.proto">token_dissociate.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TokenDissociateTransactionBody">TokenDissociateTransactionBody</h3>
        <p>Dissociates the provided account with the provided tokens. Must be signed by the provided</p><p>Account's key.</p><p>If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.</p><p>If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.</p><p>If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.</p><p>If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.</p><p>If an association between the provided account and any of the tokens does not exist, the</p><p>transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.</p><p>If a token has not been deleted and has not expired, and the user has a nonzero balance, the</p><p>transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.</p><p>If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is</p><p>not zero.</p><p>If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token</p><p>balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.</p><p>On success, associations between the provided account and tokens are removed.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>account</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account to be dissociated with the provided tokens </p></td>
                </tr>
              
                <tr>
                  <td>tokens</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td>repeated</td>
                  <td><p>The tokens to be dissociated with the provided account </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="token_fee_schedule_update.proto">token_fee_schedule_update.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TokenFeeScheduleUpdateTransactionBody">TokenFeeScheduleUpdateTransactionBody</h3>
        <p>At consensus, updates a token type's fee schedule to the given list of custom fees. </p><p>If the target token type has no fee_schedule_key, resolves to TOKEN_HAS_NO_FEE_SCHEDULE_KEY.</p><p>Otherwise this transaction must be signed to the fee_schedule_key, or the transaction will </p><p>resolve to INVALID_SIGNATURE.</p><p>If the custom_fees list is empty, clears the fee schedule or resolves to </p><p>CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES if the fee schedule was already empty.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>token_id</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The token whose fee schedule is to be updated </p></td>
                </tr>
              
                <tr>
                  <td>custom_fees</td>
                  <td><a href="#proto.CustomFee">CustomFee</a></td>
                  <td>repeated</td>
                  <td><p>The new custom fees to be assessed during a CryptoTransfer that transfers units of this token </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="token_freeze_account.proto">token_freeze_account.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TokenFreezeAccountTransactionBody">TokenFreezeAccountTransactionBody</h3>
        <p>Freezes transfers of the specified token for the account. Must be signed by the Token's freezeKey.</p><p>If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.</p><p>If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.</p><p>If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.</p><p>If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.</p><p>If an Association between the provided token and account is not found, the transaction will</p><p>resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.</p><p>If no Freeze Key is defined, the transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.</p><p>Once executed the Account is marked as Frozen and will not be able to receive or send tokens</p><p>unless unfrozen. The operation is idempotent.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>token</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The token for which this account will be frozen. If token does not exist, transaction results
in INVALID_TOKEN_ID </p></td>
                </tr>
              
                <tr>
                  <td>account</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account to be frozen </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="token_get_account_nft_infos.proto">token_get_account_nft_infos.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TokenGetAccountNftInfosQuery">TokenGetAccountNftInfosQuery</h3>
        <p>Applicable only to tokens of type NON_FUNGIBLE_UNIQUE. Gets info on NFTs N through M owned by the</p><p>specified accountId.</p><p>Example: If Account A owns 5 NFTs (might be of different Token Entity), having start=0 and end=5</p><p>will return all of the NFTs</p><p>INVALID_QUERY_RANGE response code will be returned if:</p><p>1) Start > End</p><p>2) Start and End indices are non-positive</p><p>3) Start and End indices are out of boundaries for the retrieved nft list</p><p>4) The range between Start and End is bigger than the global dynamic property for maximum query</p><p>range</p><p>NOT_SUPPORTED response code will be returned if the queried token is of type FUNGIBLE_COMMON</p><p>INVALID_ACCOUNT_ID response code will be returned if the queried account does not exist</p><p>ACCOUNT_DELETED response code will be returned if the queried account has been deleted</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>Standard info sent from client to node, including the signed payment, and what kind of
response is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>accountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The Account for which information is requested </p></td>
                </tr>
              
                <tr>
                  <td>start</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>Specifies the start index (inclusive) of the range of NFTs to query for. Value must be in the
range [0; ownedNFTs-1] </p></td>
                </tr>
              
                <tr>
                  <td>end</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>Specifies the end index (exclusive) of the range of NFTs to query for. Value must be in the
range (start; ownedNFTs] </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.TokenGetAccountNftInfosResponse">TokenGetAccountNftInfosResponse</h3>
        <p>UNDOCUMENTED</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof,
or both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>nfts</td>
                  <td><a href="#proto.TokenNftInfo">TokenNftInfo</a></td>
                  <td>repeated</td>
                  <td><p>List of NFTs associated to the account </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="token_get_info.proto">token_get_info.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TokenGetInfoQuery">TokenGetInfoQuery</h3>
        <p>Gets information about Token instance</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>Standard info sent from client to node, including the signed payment, and what kind of
response is requested (cost, state proof, both, or neither) </p></td>
                </tr>
              
                <tr>
                  <td>token</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The token for which information is requested. If invalid token is provided, INVALID_TOKEN_ID
response is returned. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.TokenGetInfoResponse">TokenGetInfoResponse</h3>
        <p>Response when the client sends the node TokenGetInfoQuery</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof,
or both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>tokenInfo</td>
                  <td><a href="#proto.TokenInfo">TokenInfo</a></td>
                  <td></td>
                  <td><p>The information requested about this token instance </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.TokenInfo">TokenInfo</h3>
        <p>The metadata about a Token instance</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>tokenId</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>ID of the token instance </p></td>
                </tr>
              
                <tr>
                  <td>name</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The name of the token. It is a string of ASCII only characters </p></td>
                </tr>
              
                <tr>
                  <td>symbol</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The symbol of the token. It is a UTF-8 capitalized alphabetical string </p></td>
                </tr>
              
                <tr>
                  <td>decimals</td>
                  <td><a href="#uint32">uint32</a></td>
                  <td></td>
                  <td><p>The number of decimal places a token is divisible by. Always 0 for tokens of type
NON_FUNGIBLE_UNIQUE </p></td>
                </tr>
              
                <tr>
                  <td>totalSupply</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>For tokens of type FUNGIBLE_COMMON - the total supply of tokens that are currently in
circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the number of NFTs created of this
token instance </p></td>
                </tr>
              
                <tr>
                  <td>treasury</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The ID of the account which is set as Treasury </p></td>
                </tr>
              
                <tr>
                  <td>adminKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The key which can perform update/delete operations on the token. If empty, the token can be
perceived as immutable (not being able to be updated/deleted) </p></td>
                </tr>
              
                <tr>
                  <td>kycKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The key which can grant or revoke KYC of an account for the token&#39;s transactions. If empty,
KYC is not required, and KYC grant or revoke operations are not possible. </p></td>
                </tr>
              
                <tr>
                  <td>freezeKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The key which can freeze or unfreeze an account for token transactions. If empty, freezing is
not possible </p></td>
                </tr>
              
                <tr>
                  <td>wipeKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The key which can wipe token balance of an account. If empty, wipe is not possible </p></td>
                </tr>
              
                <tr>
                  <td>supplyKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The key which can change the supply of a token. The key is used to sign Token Mint/Burn
operations </p></td>
                </tr>
              
                <tr>
                  <td>defaultFreezeStatus</td>
                  <td><a href="#proto.TokenFreezeStatus">TokenFreezeStatus</a></td>
                  <td></td>
                  <td><p>The default Freeze status (not applicable, frozen or unfrozen) of Hedera accounts relative to
this token. FreezeNotApplicable is returned if Token Freeze Key is empty. Frozen is returned
if Token Freeze Key is set and defaultFreeze is set to true. Unfrozen is returned if Token
Freeze Key is set and defaultFreeze is set to false </p></td>
                </tr>
              
                <tr>
                  <td>defaultKycStatus</td>
                  <td><a href="#proto.TokenKycStatus">TokenKycStatus</a></td>
                  <td></td>
                  <td><p>The default KYC status (KycNotApplicable or Revoked) of Hedera accounts relative to this
token. KycNotApplicable is returned if KYC key is not set, otherwise Revoked </p></td>
                </tr>
              
                <tr>
                  <td>deleted</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>Specifies whether the token was deleted or not </p></td>
                </tr>
              
                <tr>
                  <td>autoRenewAccount</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>An account which will be automatically charged to renew the token&#39;s expiration, at
autoRenewPeriod interval </p></td>
                </tr>
              
                <tr>
                  <td>autoRenewPeriod</td>
                  <td><a href="#proto.Duration">Duration</a></td>
                  <td></td>
                  <td><p>The interval at which the auto-renew account will be charged to extend the token&#39;s expiry </p></td>
                </tr>
              
                <tr>
                  <td>expiry</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>The epoch second at which the token will expire </p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The memo associated with the token </p></td>
                </tr>
              
                <tr>
                  <td>tokenType</td>
                  <td><a href="#proto.TokenType">TokenType</a></td>
                  <td></td>
                  <td><p>The token type </p></td>
                </tr>
              
                <tr>
                  <td>supplyType</td>
                  <td><a href="#proto.TokenSupplyType">TokenSupplyType</a></td>
                  <td></td>
                  <td><p>The token supply type </p></td>
                </tr>
              
                <tr>
                  <td>maxSupply</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>For tokens of type FUNGIBLE_COMMON - The Maximum number of fungible tokens that can be in
circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the maximum number of NFTs (serial
numbers) that can be in circulation </p></td>
                </tr>
              
                <tr>
                  <td>fee_schedule_key</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The key which can change the custom fee schedule of the token; if not set, the fee schedule
is immutable </p></td>
                </tr>
              
                <tr>
                  <td>custom_fees</td>
                  <td><a href="#proto.CustomFee">CustomFee</a></td>
                  <td>repeated</td>
                  <td><p>The custom fees to be assessed during a CryptoTransfer that transfers units of this token </p></td>
                </tr>
              
                <tr>
                  <td>pause_key</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The Key which can pause and unpause the Token. </p></td>
                </tr>
              
                <tr>
                  <td>pause_status</td>
                  <td><a href="#proto.TokenPauseStatus">TokenPauseStatus</a></td>
                  <td></td>
                  <td><p>Specifies whether the token is paused or not. PauseNotApplicable is returned if pauseKey is not set. </p></td>
                </tr>
              
                <tr>
                  <td>ledger_id</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The ledger ID the response was returned from; please see &lt;a href=&#34;https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md&#34;&gt;HIP-198&lt;/a&gt; for the network-specific IDs. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="token_get_nft_info.proto">token_get_nft_info.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.NftID">NftID</h3>
        <p>Represents an NFT on the Ledger</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>tokenID</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The (non-fungible) token of which this NFT is an instance </p></td>
                </tr>
              
                <tr>
                  <td>serialNumber</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>The unique identifier of this instance </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.TokenGetNftInfoQuery">TokenGetNftInfoQuery</h3>
        <p>Applicable only to tokens of type NON_FUNGIBLE_UNIQUE. Gets info on a NFT for a given TokenID (of</p><p>type NON_FUNGIBLE_UNIQUE) and serial number</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>Standard info sent from client to node, including the signed payment, and what kind of
response is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>nftID</td>
                  <td><a href="#proto.NftID">NftID</a></td>
                  <td></td>
                  <td><p>The ID of the NFT </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.TokenGetNftInfoResponse">TokenGetNftInfoResponse</h3>
        <p>UNDOCUMENTED</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof,
or both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>nft</td>
                  <td><a href="#proto.TokenNftInfo">TokenNftInfo</a></td>
                  <td></td>
                  <td><p>The information about this NFT </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.TokenNftInfo">TokenNftInfo</h3>
        <p>UNDOCUMENTED</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>nftID</td>
                  <td><a href="#proto.NftID">NftID</a></td>
                  <td></td>
                  <td><p>The ID of the NFT </p></td>
                </tr>
              
                <tr>
                  <td>accountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The current owner of the NFT </p></td>
                </tr>
              
                <tr>
                  <td>creationTime</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>The effective consensus timestamp at which the NFT was minted </p></td>
                </tr>
              
                <tr>
                  <td>metadata</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>Represents the unique metadata of the NFT </p></td>
                </tr>
              
                <tr>
                  <td>ledger_id</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The ledger ID the response was returned from; please see &lt;a href=&#34;https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md&#34;&gt;HIP-198&lt;/a&gt; for the network-specific IDs. </p></td>
                </tr>
              
                <tr>
                  <td>spender_id</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>If an allowance is granted for the NFT, its corresponding spender account </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="token_get_nft_infos.proto">token_get_nft_infos.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TokenGetNftInfosQuery">TokenGetNftInfosQuery</h3>
        <p>Applicable only to tokens of type NON_FUNGIBLE_UNIQUE. Gets info on NFTs N through M on the list</p><p>of NFTs associated with a given NON_FUNGIBLE_UNIQUE Token.</p><p>Example: If there are 10 NFTs issued, having start=0 and end=5 will query for the first 5 NFTs.</p><p>Querying +all 10 NFTs will require start=0 and end=10</p><p>INVALID_QUERY_RANGE response code will be returned if:</p><p>1) Start > End</p><p>2) Start and End indices are non-positive</p><p>3) Start and End indices are out of boundaries for the retrieved nft list</p><p>4) The range between Start and End is bigger than the global dynamic property for maximum query</p><p>range</p><p>NOT_SUPPORTED response code will be returned if the queried token is of type FUNGIBLE_COMMON</p><p>INVALID_TOKEN_ID response code will be returned if the queried token does not exist</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>Standard info sent from client to node, including the signed payment, and what kind of
response is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>tokenID</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The ID of the token for which information is requested </p></td>
                </tr>
              
                <tr>
                  <td>start</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>Specifies the start index (inclusive) of the range of NFTs to query for. Value must be in the
range [0; ownedNFTs-1] </p></td>
                </tr>
              
                <tr>
                  <td>end</td>
                  <td><a href="#int64">int64</a></td>
                  <td></td>
                  <td><p>Specifies the end index (exclusive) of the range of NFTs to query for. Value must be in the
range (start; ownedNFTs] </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.TokenGetNftInfosResponse">TokenGetNftInfosResponse</h3>
        <p></p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof,
or both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>tokenID</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The Token with type NON_FUNGIBLE that this record is for </p></td>
                </tr>
              
                <tr>
                  <td>nfts</td>
                  <td><a href="#proto.TokenNftInfo">TokenNftInfo</a></td>
                  <td>repeated</td>
                  <td><p>List of NFTs associated to the specified token </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="token_grant_kyc.proto">token_grant_kyc.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TokenGrantKycTransactionBody">TokenGrantKycTransactionBody</h3>
        <p>Grants KYC to the account for the given token. Must be signed by the Token's kycKey.</p><p>If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.</p><p>If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.</p><p>If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.</p><p>If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.</p><p>If an Association between the provided token and account is not found, the transaction will</p><p>resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.</p><p>If no KYC Key is defined, the transaction will resolve to TOKEN_HAS_NO_KYC_KEY.</p><p>Once executed the Account is marked as KYC Granted.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>token</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The token for which this account will be granted KYC. If token does not exist, transaction
results in INVALID_TOKEN_ID </p></td>
                </tr>
              
                <tr>
                  <td>account</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account to be KYCed </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="token_mint.proto">token_mint.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TokenMintTransactionBody">TokenMintTransactionBody</h3>
        <p>Mints tokens to the Token's treasury Account. If no Supply Key is defined, the transaction will</p><p>resolve to TOKEN_HAS_NO_SUPPLY_KEY.</p><p>The operation increases the Total Supply of the Token. The maximum total supply a token can have</p><p>is 2^63-1.</p><p>The amount provided must be in the lowest denomination possible. Example:</p><p>Token A has 2 decimals. In order to mint 100 tokens, one must provide amount of 10000. In order</p><p>to mint 100.55 tokens, one must provide amount of 10055.</p><p>If both amount and metadata list get filled, a INVALID_TRANSACTION_BODY response code will be</p><p>returned.</p><p>If the metadata list contains metadata which is too large, a METADATA_TOO_LONG response code will</p><p>be returned.</p><p>If neither the amount nor the metadata list get filled, a INVALID_TOKEN_MINT_AMOUNT response code</p><p>will be returned.</p><p>If the metadata list count is greater than the batch size limit global dynamic property, a</p><p>BATCH_SIZE_LIMIT_EXCEEDED response code will be returned.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>token</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The token for which to mint tokens. If token does not exist, transaction results in
INVALID_TOKEN_ID </p></td>
                </tr>
              
                <tr>
                  <td>amount</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.
Amount must be a positive non-zero number represented in the lowest denomination of the
token. The new supply must be lower than 2^63. </p></td>
                </tr>
              
                <tr>
                  <td>metadata</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td>repeated</td>
                  <td><p>Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.
Maximum allowed size of each metadata is 100 bytes </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="token_pause.proto">token_pause.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TokenPauseTransactionBody">TokenPauseTransactionBody</h3>
        <p>Pauses the Token from being involved in any kind of Transaction until it is unpaused.</p><p>Must be signed with the Token's pause key.</p><p>If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.</p><p>If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.</p><p>If no Pause Key is defined, the transaction will resolve to TOKEN_HAS_NO_PAUSE_KEY.</p><p>Once executed the Token is marked as paused and will be not able to be a part of any transaction.</p><p>The operation is idempotent - becomes a no-op if the Token is already Paused.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>token</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The token to be paused. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="token_revoke_kyc.proto">token_revoke_kyc.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TokenRevokeKycTransactionBody">TokenRevokeKycTransactionBody</h3>
        <p>Revokes KYC to the account for the given token. Must be signed by the Token's kycKey.</p><p>If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.</p><p>If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.</p><p>If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.</p><p>If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.</p><p>If an Association between the provided token and account is not found, the transaction will</p><p>resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.</p><p>If no KYC Key is defined, the transaction will resolve to TOKEN_HAS_NO_KYC_KEY.</p><p>Once executed the Account is marked as KYC Revoked</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>token</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The token for which this account will get his KYC revoked. If token does not exist,
transaction results in INVALID_TOKEN_ID </p></td>
                </tr>
              
                <tr>
                  <td>account</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account to be KYC Revoked </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="token_service.proto">token_service.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      

      

      

      
        <h3 id="proto.TokenService">TokenService</h3>
        <p>Transactions and queries for the Token Service</p>
        <table class="enum-table">
          <thead>
            <tr><td>Method Name</td><td>Request Type</td><td>Response Type</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>createToken</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Creates a new Token by submitting the transaction</p></td>
              </tr>
            
              <tr>
                <td>updateToken</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Updates the account by submitting the transaction</p></td>
              </tr>
            
              <tr>
                <td>mintToken</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Mints an amount of the token to the defined treasury account</p></td>
              </tr>
            
              <tr>
                <td>burnToken</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Burns an amount of the token from the defined treasury account</p></td>
              </tr>
            
              <tr>
                <td>deleteToken</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Deletes a Token</p></td>
              </tr>
            
              <tr>
                <td>wipeTokenAccount</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Wipes the provided amount of tokens from the specified Account ID</p></td>
              </tr>
            
              <tr>
                <td>freezeTokenAccount</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Freezes the transfer of tokens to or from the specified Account ID</p></td>
              </tr>
            
              <tr>
                <td>unfreezeTokenAccount</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Unfreezes the transfer of tokens to or from the specified Account ID</p></td>
              </tr>
            
              <tr>
                <td>grantKycToTokenAccount</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Flags the provided Account ID as having gone through KYC</p></td>
              </tr>
            
              <tr>
                <td>revokeKycFromTokenAccount</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Removes the KYC flag of the provided Account ID</p></td>
              </tr>
            
              <tr>
                <td>associateTokens</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Associates tokens to an account</p></td>
              </tr>
            
              <tr>
                <td>dissociateTokens</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Dissociates tokens from an account</p></td>
              </tr>
            
              <tr>
                <td>updateTokenFeeSchedule</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Updates the custom fee schedule on a token</p></td>
              </tr>
            
              <tr>
                <td>getTokenInfo</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>Retrieves the metadata of a token</p></td>
              </tr>
            
              <tr>
                <td>getAccountNftInfos</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>(DEPRECATED) Gets info on NFTs N through M on the list of NFTs associated with a given account</p></td>
              </tr>
            
              <tr>
                <td>getTokenNftInfo</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>Retrieves the metadata of an NFT by TokenID and serial number</p></td>
              </tr>
            
              <tr>
                <td>getTokenNftInfos</td>
                <td><a href="#proto.Query">Query</a></td>
                <td><a href="#proto.Response">Response</a></td>
                <td><p>(DEPRECATED) Gets info on NFTs N through M on the list of NFTs associated with a given Token of type NON_FUNGIBLE</p></td>
              </tr>
            
              <tr>
                <td>pauseToken</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Pause the token</p></td>
              </tr>
            
              <tr>
                <td>unpauseToken</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Unpause the token</p></td>
              </tr>
            
          </tbody>
        </table>

        
          
          
          <h4>Methods with deprecated option</h4>
          <table>
            <thead>
              <tr>
                <td>Method Name</td>
                <td>Option</td>
              </tr>
            </thead>
            <tbody>
            
              <tr>
                <td>getAccountNftInfos</td>
                <td><p>true</p></td>
              </tr>
            
              <tr>
                <td>getTokenNftInfos</td>
                <td><p>true</p></td>
              </tr>
            
            </tbody>
          </table>
          
        
    
      
      <div class="file-heading">
        <h2 id="token_unfreeze_account.proto">token_unfreeze_account.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TokenUnfreezeAccountTransactionBody">TokenUnfreezeAccountTransactionBody</h3>
        <p>Unfreezes transfers of the specified token for the account. Must be signed by the Token's</p><p>freezeKey.</p><p>If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.</p><p>If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.</p><p>If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.</p><p>If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.</p><p>If an Association between the provided token and account is not found, the transaction will</p><p>resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.</p><p>If no Freeze Key is defined, the transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.</p><p>Once executed the Account is marked as Unfrozen and will be able to receive or send tokens. The</p><p>operation is idempotent.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>token</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The token for which this account will be unfrozen. If token does not exist, transaction
results in INVALID_TOKEN_ID </p></td>
                </tr>
              
                <tr>
                  <td>account</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account to be unfrozen </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="token_unpause.proto">token_unpause.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TokenUnpauseTransactionBody">TokenUnpauseTransactionBody</h3>
        <p>Unpauses the Token. Must be signed with the Token's pause key.</p><p>If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.</p><p>If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.</p><p>If no Pause Key is defined, the transaction will resolve to TOKEN_HAS_NO_PAUSE_KEY.</p><p>Once executed the Token is marked as Unpaused and can be used in Transactions.</p><p>The operation is idempotent - becomes a no-op if the Token is already unpaused.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>token</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The token to be unpaused. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="token_update.proto">token_update.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TokenUpdateTransactionBody">TokenUpdateTransactionBody</h3>
        <p>At consensus, updates an already created token to the given values.</p><p>If no value is given for a field, that field is left unchanged. For an immutable tokens (that is,</p><p>a token without an admin key), only the expiry may be updated. Setting any other field in that</p><p>case will cause the transaction status to resolve to TOKEN_IS_IMMUTABLE.</p><p>--- Signing Requirements ---</p><p>1. Whether or not a token has an admin key, its expiry can be extended with only the transaction</p><p>payer's signature.</p><p>2. Updating any other field of a mutable token requires the admin key's signature.</p><p>3. If a new admin key is set, this new key must sign <b>unless</b> it is exactly an empty</p><p><tt>KeyList</tt>. This special sentinel key removes the existing admin key and causes the</p><p>token to become immutable. (Other <tt>Key</tt> structures without a constituent</p><p><tt>Ed25519</tt> key will be rejected with <tt>INVALID_ADMIN_KEY</tt>.)</p><p>4. If a new treasury is set, the new treasury account's key must sign the transaction.</p><p>--- Nft Requirements ---</p><p>1. If a non fungible token has a positive treasury balance, the operation will abort with</p><p>CURRENT_TREASURY_STILL_OWNS_NFTS.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>token</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The Token to be updated </p></td>
                </tr>
              
                <tr>
                  <td>symbol</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The new publicly visible token symbol. The token symbol is specified as a Unicode string. 
Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL). </p></td>
                </tr>
              
                <tr>
                  <td>name</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The new publicly visible name of the token. The token name is specified as a Unicode string. 
Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL). </p></td>
                </tr>
              
                <tr>
                  <td>treasury</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The new Treasury account of the Token. If the provided treasury account is not existing or
deleted, the response will be INVALID_TREASURY_ACCOUNT_FOR_TOKEN. If successful, the Token
balance held in the previous Treasury Account is transferred to the new one. </p></td>
                </tr>
              
                <tr>
                  <td>adminKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The new admin key of the Token. If Token is immutable, transaction will resolve to
TOKEN_IS_IMMUTABlE. </p></td>
                </tr>
              
                <tr>
                  <td>kycKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The new KYC key of the Token. If Token does not have currently a KYC key, transaction will
resolve to TOKEN_HAS_NO_KYC_KEY. </p></td>
                </tr>
              
                <tr>
                  <td>freezeKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The new Freeze key of the Token. If the Token does not have currently a Freeze key,
transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY. </p></td>
                </tr>
              
                <tr>
                  <td>wipeKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The new Wipe key of the Token. If the Token does not have currently a Wipe key, transaction
will resolve to TOKEN_HAS_NO_WIPE_KEY. </p></td>
                </tr>
              
                <tr>
                  <td>supplyKey</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The new Supply key of the Token. If the Token does not have currently a Supply key,
transaction will resolve to TOKEN_HAS_NO_SUPPLY_KEY. </p></td>
                </tr>
              
                <tr>
                  <td>autoRenewAccount</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The new account which will be automatically charged to renew the token&#39;s expiration, at
autoRenewPeriod interval. </p></td>
                </tr>
              
                <tr>
                  <td>autoRenewPeriod</td>
                  <td><a href="#proto.Duration">Duration</a></td>
                  <td></td>
                  <td><p>The new interval at which the auto-renew account will be charged to extend the token&#39;s
expiry. </p></td>
                </tr>
              
                <tr>
                  <td>expiry</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>The new expiry time of the token. Expiry can be updated even if admin key is not set. If the
provided expiry is earlier than the current token expiry, transaction wil resolve to
INVALID_EXPIRATION_TIME </p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#google.protobuf.StringValue">google.protobuf.StringValue</a></td>
                  <td></td>
                  <td><p>If set, the new memo to be associated with the token (UTF-8 encoding max 100 bytes) </p></td>
                </tr>
              
                <tr>
                  <td>fee_schedule_key</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>If set, the new key to use to update the token&#39;s custom fee schedule; if the token does not
currently have this key, transaction will resolve to TOKEN_HAS_NO_FEE_SCHEDULE_KEY </p></td>
                </tr>
              
                <tr>
                  <td>pause_key</td>
                  <td><a href="#proto.Key">Key</a></td>
                  <td></td>
                  <td><p>The Key which can pause and unpause the Token. If the Token does not currently have a pause key,
transaction will resolve to TOKEN_HAS_NO_PAUSE_KEY </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="token_wipe_account.proto">token_wipe_account.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TokenWipeAccountTransactionBody">TokenWipeAccountTransactionBody</h3>
        <p>Wipes the provided amount of tokens from the specified Account. Must be signed by the Token's</p><p>Wipe key.</p><p>If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.</p><p>If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.</p><p>If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.</p><p>If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.</p><p>If an Association between the provided token and account is not found, the transaction will</p><p>resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.</p><p>If Wipe Key is not present in the Token, transaction results in TOKEN_HAS_NO_WIPE_KEY.</p><p>If the provided account is the Token's Treasury Account, transaction results in</p><p>CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT</p><p>On success, tokens are removed from the account and the total supply of the token is decreased by</p><p>the wiped amount.</p><p>If both amount and serialNumbers get filled, a INVALID_TRANSACTION_BODY response code will be</p><p>returned.</p><p>If neither the amount nor the serialNumbers get filled, a INVALID_WIPING_AMOUNT response code</p><p>will be returned.</p><p>If the serialNumbers list contains a non-positive integer as a serial number, a INVALID_NFT_ID</p><p>response code will be returned.</p><p>If the serialNumbers' list count is greater than the batch size limit global dynamic property, a</p><p>BATCH_SIZE_LIMIT_EXCEEDED response code will be returned.</p><p>The amount provided is in the lowest denomination possible. Example:</p><p>Token A has 2 decimals. In order to wipe 100 tokens from account, one must provide amount of</p><p>10000. In order to wipe 100.55 tokens, one must provide amount of 10055.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>token</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>The token for which the account will be wiped. If token does not exist, transaction results
in INVALID_TOKEN_ID </p></td>
                </tr>
              
                <tr>
                  <td>account</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account to be wiped </p></td>
                </tr>
              
                <tr>
                  <td>amount</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>Applicable to tokens of type FUNGIBLE_COMMON. The amount of tokens to wipe from the specified
account. Amount must be a positive non-zero number in the lowest denomination possible, not
bigger than the token balance of the account (0; balance] </p></td>
                </tr>
              
                <tr>
                  <td>serialNumbers</td>
                  <td><a href="#int64">int64</a></td>
                  <td>repeated</td>
                  <td><p>Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be wiped. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="transaction.proto">transaction.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.Transaction">Transaction</h3>
        <p>A single signed transaction, including all its signatures. The SignatureList will have a</p><p>Signature for each Key in the transaction, either explicit or implicit, in the order that they</p><p>appear in the transaction. For example, a CryptoTransfer will first have a Signature</p><p>corresponding to the Key for the paying account, followed by a Signature corresponding to the Key</p><p>for each account that is sending or receiving cryptocurrency in the transfer. Each Transaction</p><p>should not have more than 50 levels. </p><p>The SignatureList field is deprecated and succeeded by SignatureMap.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>body</td>
                  <td><a href="#proto.TransactionBody">TransactionBody</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> the body of the transaction, which needs to be signed </p></td>
                </tr>
              
                <tr>
                  <td>sigs</td>
                  <td><a href="#proto.SignatureList">SignatureList</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> The signatures on the body, to authorize the transaction; deprecated and to be succeeded by
SignatureMap field </p></td>
                </tr>
              
                <tr>
                  <td>sigMap</td>
                  <td><a href="#proto.SignatureMap">SignatureMap</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> The signatures on the body with the new format, to authorize the transaction </p></td>
                </tr>
              
                <tr>
                  <td>bodyBytes</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> TransactionBody serialized into bytes, which needs to be signed </p></td>
                </tr>
              
                <tr>
                  <td>signedTransactionBytes</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>SignedTransaction serialized into bytes </p></td>
                </tr>
              
            </tbody>
          </table>

          
            
            
            <h4>Fields with deprecated option</h4>
            <table>
              <thead>
                <tr>
                  <td>Name</td>
                  <td>Option</td>
                </tr>
              </thead>
              <tbody>
              
                <tr>
                  <td>body</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>sigs</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>sigMap</td>
                  <td><p>true</p></td>
                </tr>
              
                <tr>
                  <td>bodyBytes</td>
                  <td><p>true</p></td>
                </tr>
              
              </tbody>
            </table>
            
          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="transaction_body.proto">transaction_body.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TransactionBody">TransactionBody</h3>
        <p>A single transaction. All transaction types are possible here.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>transactionID</td>
                  <td><a href="#proto.TransactionID">TransactionID</a></td>
                  <td></td>
                  <td><p>The ID for this transaction, which includes the payer&#39;s account (the account paying the
transaction fee). If two transactions have the same transactionID, they won&#39;t both have an
effect </p></td>
                </tr>
              
                <tr>
                  <td>nodeAccountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>The account of the node that submits the client&#39;s transaction to the network </p></td>
                </tr>
              
                <tr>
                  <td>transactionFee</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>The maximum transaction fee the client is willing to pay </p></td>
                </tr>
              
                <tr>
                  <td>transactionValidDuration</td>
                  <td><a href="#proto.Duration">Duration</a></td>
                  <td></td>
                  <td><p>The transaction is invalid if consensusTimestamp &gt; transactionID.transactionValidStart &#43;
transactionValidDuration </p></td>
                </tr>
              
                <tr>
                  <td>generateRecord</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p><strong>Deprecated.</strong> Should a record of this transaction be generated? (A receipt is always generated, but the
record is optional) </p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>Any notes or descriptions that should be put into the record (max length 100) </p></td>
                </tr>
              
                <tr>
                  <td>contractCall</td>
                  <td><a href="#proto.ContractCallTransactionBody">ContractCallTransactionBody</a></td>
                  <td></td>
                  <td><p>Calls a function of a contract instance </p></td>
                </tr>
              
                <tr>
                  <td>contractCreateInstance</td>
                  <td><a href="#proto.ContractCreateTransactionBody">ContractCreateTransactionBody</a></td>
                  <td></td>
                  <td><p>Creates a contract instance </p></td>
                </tr>
              
                <tr>
                  <td>contractUpdateInstance</td>
                  <td><a href="#proto.ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></td>
                  <td></td>
                  <td><p>Updates a contract </p></td>
                </tr>
              
                <tr>
                  <td>contractDeleteInstance</td>
                  <td><a href="#proto.ContractDeleteTransactionBody">ContractDeleteTransactionBody</a></td>
                  <td></td>
                  <td><p>Delete contract and transfer remaining balance into specified account </p></td>
                </tr>
              
                <tr>
                  <td>ethereumTransaction</td>
                  <td><a href="#proto.EthereumTransactionBody">EthereumTransactionBody</a></td>
                  <td></td>
                  <td><p>An Ethereum encoded transaction. </p></td>
                </tr>
              
                <tr>
                  <td>cryptoAddLiveHash</td>
                  <td><a href="#proto.CryptoAddLiveHashTransactionBody">CryptoAddLiveHashTransactionBody</a></td>
                  <td></td>
                  <td><p>Attach a new livehash to an account </p></td>
                </tr>
              
                <tr>
                  <td>cryptoApproveAllowance</td>
                  <td><a href="#proto.CryptoApproveAllowanceTransactionBody">CryptoApproveAllowanceTransactionBody</a></td>
                  <td></td>
                  <td><p>Adds one or more approved allowances for spenders to transfer the paying account&#39;s hbar or tokens. </p></td>
                </tr>
              
                <tr>
                  <td>cryptoDeleteAllowance</td>
                  <td><a href="#proto.CryptoDeleteAllowanceTransactionBody">CryptoDeleteAllowanceTransactionBody</a></td>
                  <td></td>
                  <td><p>Deletes one or more of the specific approved NFT serial numbers on an owner account. </p></td>
                </tr>
              
                <tr>
                  <td>cryptoCreateAccount</td>
                  <td><a href="#proto.CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></td>
                  <td></td>
                  <td><p>Create a new cryptocurrency account </p></td>
                </tr>
              
                <tr>
                  <td>cryptoDelete</td>
                  <td><a href="#proto.CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></td>
                  <td></td>
                  <td><p>Delete a cryptocurrency account (mark as deleted, and transfer hbars out) </p></td>
                </tr>
              
                <tr>
                  <td>cryptoDeleteLiveHash</td>
                  <td><a href="#proto.CryptoDeleteLiveHashTransactionBody">CryptoDeleteLiveHashTransactionBody</a></td>
                  <td></td>
                  <td><p>Remove a livehash from an account </p></td>
                </tr>
              
                <tr>
                  <td>cryptoTransfer</td>
                  <td><a href="#proto.CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></td>
                  <td></td>
                  <td><p>Transfer amount between accounts </p></td>
                </tr>
              
                <tr>
                  <td>cryptoUpdateAccount</td>
                  <td><a href="#proto.CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></td>
                  <td></td>
                  <td><p>Modify information such as the expiration date for an account </p></td>
                </tr>
              
                <tr>
                  <td>fileAppend</td>
                  <td><a href="#proto.FileAppendTransactionBody">FileAppendTransactionBody</a></td>
                  <td></td>
                  <td><p>Add bytes to the end of the contents of a file </p></td>
                </tr>
              
                <tr>
                  <td>fileCreate</td>
                  <td><a href="#proto.FileCreateTransactionBody">FileCreateTransactionBody</a></td>
                  <td></td>
                  <td><p>Create a new file </p></td>
                </tr>
              
                <tr>
                  <td>fileDelete</td>
                  <td><a href="#proto.FileDeleteTransactionBody">FileDeleteTransactionBody</a></td>
                  <td></td>
                  <td><p>Delete a file (remove contents and mark as deleted until it expires) </p></td>
                </tr>
              
                <tr>
                  <td>fileUpdate</td>
                  <td><a href="#proto.FileUpdateTransactionBody">FileUpdateTransactionBody</a></td>
                  <td></td>
                  <td><p>Modify information such as the expiration date for a file </p></td>
                </tr>
              
                <tr>
                  <td>systemDelete</td>
                  <td><a href="#proto.SystemDeleteTransactionBody">SystemDeleteTransactionBody</a></td>
                  <td></td>
                  <td><p>Hedera administrative deletion of a file or smart contract </p></td>
                </tr>
              
                <tr>
                  <td>systemUndelete</td>
                  <td><a href="#proto.SystemUndeleteTransactionBody">SystemUndeleteTransactionBody</a></td>
                  <td></td>
                  <td><p>To undelete an entity deleted by SystemDelete </p></td>
                </tr>
              
                <tr>
                  <td>freeze</td>
                  <td><a href="#proto.FreezeTransactionBody">FreezeTransactionBody</a></td>
                  <td></td>
                  <td><p>Freeze the nodes </p></td>
                </tr>
              
                <tr>
                  <td>consensusCreateTopic</td>
                  <td><a href="#proto.ConsensusCreateTopicTransactionBody">ConsensusCreateTopicTransactionBody</a></td>
                  <td></td>
                  <td><p>Creates a topic </p></td>
                </tr>
              
                <tr>
                  <td>consensusUpdateTopic</td>
                  <td><a href="#proto.ConsensusUpdateTopicTransactionBody">ConsensusUpdateTopicTransactionBody</a></td>
                  <td></td>
                  <td><p>Updates a topic </p></td>
                </tr>
              
                <tr>
                  <td>consensusDeleteTopic</td>
                  <td><a href="#proto.ConsensusDeleteTopicTransactionBody">ConsensusDeleteTopicTransactionBody</a></td>
                  <td></td>
                  <td><p>Deletes a topic </p></td>
                </tr>
              
                <tr>
                  <td>consensusSubmitMessage</td>
                  <td><a href="#proto.ConsensusSubmitMessageTransactionBody">ConsensusSubmitMessageTransactionBody</a></td>
                  <td></td>
                  <td><p>Submits message to a topic </p></td>
                </tr>
              
                <tr>
                  <td>uncheckedSubmit</td>
                  <td><a href="#proto.UncheckedSubmitBody">UncheckedSubmitBody</a></td>
                  <td></td>
                  <td><p>UNDOCUMENTED </p></td>
                </tr>
              
                <tr>
                  <td>tokenCreation</td>
                  <td><a href="#proto.TokenCreateTransactionBody">TokenCreateTransactionBody</a></td>
                  <td></td>
                  <td><p>Creates a token instance </p></td>
                </tr>
              
                <tr>
                  <td>tokenFreeze</td>
                  <td><a href="#proto.TokenFreezeAccountTransactionBody">TokenFreezeAccountTransactionBody</a></td>
                  <td></td>
                  <td><p>Freezes account not to be able to transact with a token </p></td>
                </tr>
              
                <tr>
                  <td>tokenUnfreeze</td>
                  <td><a href="#proto.TokenUnfreezeAccountTransactionBody">TokenUnfreezeAccountTransactionBody</a></td>
                  <td></td>
                  <td><p>Unfreezes account for a token </p></td>
                </tr>
              
                <tr>
                  <td>tokenGrantKyc</td>
                  <td><a href="#proto.TokenGrantKycTransactionBody">TokenGrantKycTransactionBody</a></td>
                  <td></td>
                  <td><p>Grants KYC to an account for a token </p></td>
                </tr>
              
                <tr>
                  <td>tokenRevokeKyc</td>
                  <td><a href="#proto.TokenRevokeKycTransactionBody">TokenRevokeKycTransactionBody</a></td>
                  <td></td>
                  <td><p>Revokes KYC of an account for a token </p></td>
                </tr>
              
                <tr>
                  <td>tokenDeletion</td>
                  <td><a href="#proto.TokenDeleteTransactionBody">TokenDeleteTransactionBody</a></td>
                  <td></td>
                  <td><p>Deletes a token instance </p></td>
                </tr>
              
                <tr>
                  <td>tokenUpdate</td>
                  <td><a href="#proto.TokenUpdateTransactionBody">TokenUpdateTransactionBody</a></td>
                  <td></td>
                  <td><p>Updates a token instance </p></td>
                </tr>
              
                <tr>
                  <td>tokenMint</td>
                  <td><a href="#proto.TokenMintTransactionBody">TokenMintTransactionBody</a></td>
                  <td></td>
                  <td><p>Mints new tokens to a token&#39;s treasury account </p></td>
                </tr>
              
                <tr>
                  <td>tokenBurn</td>
                  <td><a href="#proto.TokenBurnTransactionBody">TokenBurnTransactionBody</a></td>
                  <td></td>
                  <td><p>Burns tokens from a token&#39;s treasury account </p></td>
                </tr>
              
                <tr>
                  <td>tokenWipe</td>
                  <td><a href="#proto.TokenWipeAccountTransactionBody">TokenWipeAccountTransactionBody</a></td>
                  <td></td>
                  <td><p>Wipes amount of tokens from an account </p></td>
                </tr>
              
                <tr>
                  <td>tokenAssociate</td>
                  <td><a href="#proto.TokenAssociateTransactionBody">TokenAssociateTransactionBody</a></td>
                  <td></td>
                  <td><p>Associate tokens to an account </p></td>
                </tr>
              
                <tr>
                  <td>tokenDissociate</td>
                  <td><a href="#proto.TokenDissociateTransactionBody">TokenDissociateTransactionBody</a></td>
                  <td></td>
                  <td><p>Dissociate tokens from an account </p></td>
                </tr>
              
                <tr>
                  <td>token_fee_schedule_update</td>
                  <td><a href="#proto.TokenFeeScheduleUpdateTransactionBody">TokenFeeScheduleUpdateTransactionBody</a></td>
                  <td></td>
                  <td><p>Updates a token&#39;s custom fee schedule </p></td>
                </tr>
              
                <tr>
                  <td>token_pause</td>
                  <td><a href="#proto.TokenPauseTransactionBody">TokenPauseTransactionBody</a></td>
                  <td></td>
                  <td><p>Pauses the Token </p></td>
                </tr>
              
                <tr>
                  <td>token_unpause</td>
                  <td><a href="#proto.TokenUnpauseTransactionBody">TokenUnpauseTransactionBody</a></td>
                  <td></td>
                  <td><p>Unpauses the Token </p></td>
                </tr>
              
                <tr>
                  <td>scheduleCreate</td>
                  <td><a href="#proto.ScheduleCreateTransactionBody">ScheduleCreateTransactionBody</a></td>
                  <td></td>
                  <td><p>Creates a schedule in the network&#39;s action queue </p></td>
                </tr>
              
                <tr>
                  <td>scheduleDelete</td>
                  <td><a href="#proto.ScheduleDeleteTransactionBody">ScheduleDeleteTransactionBody</a></td>
                  <td></td>
                  <td><p>Deletes a schedule from the network&#39;s action queue </p></td>
                </tr>
              
                <tr>
                  <td>scheduleSign</td>
                  <td><a href="#proto.ScheduleSignTransactionBody">ScheduleSignTransactionBody</a></td>
                  <td></td>
                  <td><p>Adds one or more Ed25519 keys to the affirmed signers of a scheduled transaction </p></td>
                </tr>
              
                <tr>
                  <td>node_stake_update</td>
                  <td><a href="#proto.NodeStakeUpdateTransactionBody">NodeStakeUpdateTransactionBody</a></td>
                  <td></td>
                  <td><p>Updates the staking info at the end of staking period to indicate new staking period has started. </p></td>
                </tr>
              
                <tr>
                  <td>util_prng</td>
                  <td><a href="#proto.UtilPrngTransactionBody">UtilPrngTransactionBody</a></td>
                  <td></td>
                  <td><p>Generates a pseudorandom number. </p></td>
                </tr>
              
            </tbody>
          </table>

          
            
            
            <h4>Fields with deprecated option</h4>
            <table>
              <thead>
                <tr>
                  <td>Name</td>
                  <td>Option</td>
                </tr>
              </thead>
              <tbody>
              
                <tr>
                  <td>generateRecord</td>
                  <td><p>true</p></td>
                </tr>
              
              </tbody>
            </table>
            
          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="transaction_contents.proto">transaction_contents.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.SignedTransaction">SignedTransaction</h3>
        <p></p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>bodyBytes</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>TransactionBody serialized into bytes, which needs to be signed </p></td>
                </tr>
              
                <tr>
                  <td>sigMap</td>
                  <td><a href="#proto.SignatureMap">SignatureMap</a></td>
                  <td></td>
                  <td><p>The signatures on the body with the new format, to authorize the transaction </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="transaction_get_fast_record.proto">transaction_get_fast_record.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TransactionGetFastRecordQuery">TransactionGetFastRecordQuery</h3>
        <p>Get the tx record of a transaction, given its transaction ID. Once a transaction reaches</p><p>consensus, then information about whether it succeeded or failed will be available until the end</p><p>of the receipt period.  Before and after the receipt period, and for a transaction that was never</p><p>submitted, the receipt is unknown.  This query is free (the payment field is left empty).</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>Standard info sent from client to node, including the signed payment, and what kind of
response is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>transactionID</td>
                  <td><a href="#proto.TransactionID">TransactionID</a></td>
                  <td></td>
                  <td><p>The ID of the transaction for which the record is requested. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.TransactionGetFastRecordResponse">TransactionGetFastRecordResponse</h3>
        <p>Response when the client sends the node TransactionGetFastRecordQuery. If it created a new entity</p><p>(account, file, or smart contract instance) then one of the three ID fields will be filled in</p><p>with the ID of the new entity. Sometimes a single transaction will create more than one new</p><p>entity, such as when a new contract instance is created, and this also creates the new account</p><p>that it owned by that instance.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof,
or both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>transactionRecord</td>
                  <td><a href="#proto.TransactionRecord">TransactionRecord</a></td>
                  <td></td>
                  <td><p>The requested transaction records </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="transaction_get_receipt.proto">transaction_get_receipt.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TransactionGetReceiptQuery">TransactionGetReceiptQuery</h3>
        <p>Get the receipt of a transaction, given its transaction ID. Once a transaction reaches consensus,</p><p>then information about whether it succeeded or failed will be available until the end of the</p><p>receipt period.  Before and after the receipt period, and for a transaction that was never</p><p>submitted, the receipt is unknown.  This query is free (the payment field is left empty). No</p><p>State proof is available for this response</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>Standard info sent from client to node, including the signed payment, and what kind of
response is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>transactionID</td>
                  <td><a href="#proto.TransactionID">TransactionID</a></td>
                  <td></td>
                  <td><p>The ID of the transaction for which the receipt is requested. </p></td>
                </tr>
              
                <tr>
                  <td>includeDuplicates</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>Whether receipts of processing duplicate transactions should be returned along with the
receipt of processing the first consensus transaction with the given id whose status was
neither &lt;tt&gt;INVALID_NODE_ACCOUNT&lt;/tt&gt; nor &lt;tt&gt;INVALID_PAYER_SIGNATURE&lt;/tt&gt;; &lt;b&gt;or&lt;/b&gt;, if no
such receipt exists, the receipt of processing the first transaction to reach consensus with
the given transaction id. </p></td>
                </tr>
              
                <tr>
                  <td>include_child_receipts</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>Whether the response should include the receipts of any child transactions spawned by the 
top-level transaction with the given transactionID. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.TransactionGetReceiptResponse">TransactionGetReceiptResponse</h3>
        <p>Response when the client sends the node TransactionGetReceiptQuery. If it created a new entity</p><p>(account, file, or smart contract instance) then one of the three ID fields will be filled in</p><p>with the ID of the new entity. Sometimes a single transaction will create more than one new</p><p>entity, such as when a new contract instance is created, and this also creates the new account</p><p>that it owned by that instance. No State proof is available for this response</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof,
or both, or neither </p></td>
                </tr>
              
                <tr>
                  <td>receipt</td>
                  <td><a href="#proto.TransactionReceipt">TransactionReceipt</a></td>
                  <td></td>
                  <td><p>Either the receipt of processing the first consensus transaction with the given id whose
status was neither &lt;tt&gt;INVALID_NODE_ACCOUNT&lt;/tt&gt; nor &lt;tt&gt;INVALID_PAYER_SIGNATURE&lt;/tt&gt;;
&lt;b&gt;or&lt;/b&gt;, if no such receipt exists, the receipt of processing the first transaction to
reach consensus with the given transaction id. </p></td>
                </tr>
              
                <tr>
                  <td>duplicateTransactionReceipts</td>
                  <td><a href="#proto.TransactionReceipt">TransactionReceipt</a></td>
                  <td>repeated</td>
                  <td><p>The receipts of processing all transactions with the given id, in consensus time order. </p></td>
                </tr>
              
                <tr>
                  <td>child_transaction_receipts</td>
                  <td><a href="#proto.TransactionReceipt">TransactionReceipt</a></td>
                  <td>repeated</td>
                  <td><p>The receipts (if any) of all child transactions spawned by the transaction with the 
given top-level id, in consensus order. Always empty if the top-level status is UNKNOWN. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="transaction_get_record.proto">transaction_get_record.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TransactionGetRecordQuery">TransactionGetRecordQuery</h3>
        <p>Get the record for a transaction. If the transaction requested a record, then the record lasts</p><p>for one hour, and a state proof is available for it. If the transaction created an account, file,</p><p>or smart contract instance, then the record will contain the ID for what it created. If the</p><p>transaction called a smart contract function, then the record contains the result of that call.</p><p>If the transaction was a cryptocurrency transfer, then the record includes the TransferList which</p><p>gives the details of that transfer. If the transaction didn't return anything that should be in</p><p>the record, then the results field will be set to nothing.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.QueryHeader">QueryHeader</a></td>
                  <td></td>
                  <td><p>Standard info sent from client to node, including the signed payment, and what kind of
response is requested (cost, state proof, both, or neither). </p></td>
                </tr>
              
                <tr>
                  <td>transactionID</td>
                  <td><a href="#proto.TransactionID">TransactionID</a></td>
                  <td></td>
                  <td><p>The ID of the transaction for which the record is requested. </p></td>
                </tr>
              
                <tr>
                  <td>includeDuplicates</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>Whether records of processing duplicate transactions should be returned along with the record
of processing the first consensus transaction with the given id whose status was neither
&lt;tt&gt;INVALID_NODE_ACCOUNT&lt;/tt&gt; nor &lt;tt&gt;INVALID_PAYER_SIGNATURE&lt;/tt&gt;; &lt;b&gt;or&lt;/b&gt;, if no such
record exists, the record of processing the first transaction to reach consensus with the
given transaction id.. </p></td>
                </tr>
              
                <tr>
                  <td>include_child_records</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>Whether the response should include the records of any child transactions spawned by the 
top-level transaction with the given transactionID. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="proto.TransactionGetRecordResponse">TransactionGetRecordResponse</h3>
        <p>Response when the client sends the node TransactionGetRecordQuery</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#proto.ResponseHeader">ResponseHeader</a></td>
                  <td></td>
                  <td><p>Standard response from node to client, including the requested fields: cost, or state proof,
or both, or neither. </p></td>
                </tr>
              
                <tr>
                  <td>transactionRecord</td>
                  <td><a href="#proto.TransactionRecord">TransactionRecord</a></td>
                  <td></td>
                  <td><p>Either the record of processing the first consensus transaction with the given id whose
status was neither &lt;tt&gt;INVALID_NODE_ACCOUNT&lt;/tt&gt; nor &lt;tt&gt;INVALID_PAYER_SIGNATURE&lt;/tt&gt;;
&lt;b&gt;or&lt;/b&gt;, if no such record exists, the record of processing the first transaction to reach
consensus with the given transaction id. </p></td>
                </tr>
              
                <tr>
                  <td>duplicateTransactionRecords</td>
                  <td><a href="#proto.TransactionRecord">TransactionRecord</a></td>
                  <td>repeated</td>
                  <td><p>The records of processing all consensus transaction with the same id as the distinguished
record above, in chronological order. </p></td>
                </tr>
              
                <tr>
                  <td>child_transaction_records</td>
                  <td><a href="#proto.TransactionRecord">TransactionRecord</a></td>
                  <td>repeated</td>
                  <td><p>The records of processing all child transaction spawned by the transaction with the given 
top-level id, in consensus order. Always empty if the top-level status is UNKNOWN. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="transaction_receipt.proto">transaction_receipt.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TransactionReceipt">TransactionReceipt</h3>
        <p>The summary of a transaction's result so far. If the transaction has not reached consensus, this</p><p>result will be necessarily incomplete.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>status</td>
                  <td><a href="#proto.ResponseCodeEnum">ResponseCodeEnum</a></td>
                  <td></td>
                  <td><p>The consensus status of the transaction; is UNKNOWN if consensus has not been reached, or if
the associated transaction did not have a valid payer signature </p></td>
                </tr>
              
                <tr>
                  <td>accountID</td>
                  <td><a href="#proto.AccountID">AccountID</a></td>
                  <td></td>
                  <td><p>In the receipt of a CryptoCreate, the id of the newly created account </p></td>
                </tr>
              
                <tr>
                  <td>fileID</td>
                  <td><a href="#proto.FileID">FileID</a></td>
                  <td></td>
                  <td><p>In the receipt of a FileCreate, the id of the newly created file </p></td>
                </tr>
              
                <tr>
                  <td>contractID</td>
                  <td><a href="#proto.ContractID">ContractID</a></td>
                  <td></td>
                  <td><p>In the receipt of a ContractCreate, the id of the newly created contract </p></td>
                </tr>
              
                <tr>
                  <td>exchangeRate</td>
                  <td><a href="#proto.ExchangeRateSet">ExchangeRateSet</a></td>
                  <td></td>
                  <td><p>The exchange rates in effect when the transaction reached consensus </p></td>
                </tr>
              
                <tr>
                  <td>topicID</td>
                  <td><a href="#proto.TopicID">TopicID</a></td>
                  <td></td>
                  <td><p>In the receipt of a ConsensusCreateTopic, the id of the newly created topic. </p></td>
                </tr>
              
                <tr>
                  <td>topicSequenceNumber</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>In the receipt of a ConsensusSubmitMessage, the new sequence number of the topic that
received the message </p></td>
                </tr>
              
                <tr>
                  <td>topicRunningHash</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>In the receipt of a ConsensusSubmitMessage, the new running hash of the topic that received
the message.  This 48-byte field is the output of a particular SHA-384 digest whose input
data are determined by the value of the topicRunningHashVersion below. The bytes of each
uint64 or uint32 are to be in Big-Endian format.

IF the topicRunningHashVersion is &#39;0&#39; or &#39;1&#39;, then the input data to the SHA-384 digest are,
in order:
---
1. The previous running hash of the topic (48 bytes)
2. The topic&#39;s shard (8 bytes)
3. The topic&#39;s realm (8 bytes)
4. The topic&#39;s number (8 bytes)
5. The number of seconds since the epoch before the ConsensusSubmitMessage reached 
   consensus (8 bytes)
6. The number of nanoseconds since 5. before the ConsensusSubmitMessage reached 
   consensus (4 bytes)
7. The topicSequenceNumber from above (8 bytes)
8. The message bytes from the ConsensusSubmitMessage (variable).

IF the topicRunningHashVersion is &#39;2&#39;, then the input data to the SHA-384 digest are, in
order:
---
1. The previous running hash of the topic (48 bytes)
2. The topicRunningHashVersion below (8 bytes)
3. The topic&#39;s shard (8 bytes)
4. The topic&#39;s realm (8 bytes)
5. The topic&#39;s number (8 bytes)
6. The number of seconds since the epoch before the ConsensusSubmitMessage reached 
   consensus (8 bytes)
7. The number of nanoseconds since 6. before the ConsensusSubmitMessage reached 
   consensus (4 bytes)
8. The topicSequenceNumber from above (8 bytes)
9. The output of the SHA-384 digest of the message bytes from the 
   consensusSubmitMessage (48 bytes)

Otherwise, IF the topicRunningHashVersion is &#39;3&#39;, then the input data to the SHA-384 digest
are, in order:
---
1. The previous running hash of the topic (48 bytes)
2. The topicRunningHashVersion below (8 bytes)
3. The payer account&#39;s shard (8 bytes)
4. The payer account&#39;s realm (8 bytes)
5. The payer account&#39;s number (8 bytes)
6. The topic&#39;s shard (8 bytes)
7. The topic&#39;s realm (8 bytes)
8. The topic&#39;s number (8 bytes)
9. The number of seconds since the epoch before the ConsensusSubmitMessage reached 
   consensus (8 bytes)
10. The number of nanoseconds since 9. before the ConsensusSubmitMessage reached 
    consensus (4 bytes)
11. The topicSequenceNumber from above (8 bytes)
12. The output of the SHA-384 digest of the message bytes from the 
    consensusSubmitMessage (48 bytes) </p></td>
                </tr>
              
                <tr>
                  <td>topicRunningHashVersion</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>In the receipt of a ConsensusSubmitMessage, the version of the SHA-384 digest used to update
the running hash. </p></td>
                </tr>
              
                <tr>
                  <td>tokenID</td>
                  <td><a href="#proto.TokenID">TokenID</a></td>
                  <td></td>
                  <td><p>In the receipt of a CreateToken, the id of the newly created token </p></td>
                </tr>
              
                <tr>
                  <td>newTotalSupply</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>In the receipt of TokenMint, TokenWipe, TokenBurn, For fungible tokens - the current total
supply of this token. For non fungible tokens - the total number of NFTs issued for a given
tokenID </p></td>
                </tr>
              
                <tr>
                  <td>scheduleID</td>
                  <td><a href="#proto.ScheduleID">ScheduleID</a></td>
                  <td></td>
                  <td><p>In the receipt of a ScheduleCreate, the id of the newly created Scheduled Entity </p></td>
                </tr>
              
                <tr>
                  <td>scheduledTransactionID</td>
                  <td><a href="#proto.TransactionID">TransactionID</a></td>
                  <td></td>
                  <td><p>In the receipt of a ScheduleCreate or ScheduleSign that resolves to SUCCESS, the
TransactionID that should be used to query for the receipt or record of the relevant
scheduled transaction </p></td>
                </tr>
              
                <tr>
                  <td>serialNumbers</td>
                  <td><a href="#int64">int64</a></td>
                  <td>repeated</td>
                  <td><p>In the receipt of a TokenMint for tokens of type NON_FUNGIBLE_UNIQUE, the serial numbers of
the newly created NFTs </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="transaction_record.proto">transaction_record.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TransactionRecord">TransactionRecord</h3>
        <p>Response when the client sends the node TransactionGetRecordResponse</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>receipt</td>
                  <td><a href="#proto.TransactionReceipt">TransactionReceipt</a></td>
                  <td></td>
                  <td><p>The status (reach consensus, or failed, or is unknown) and the ID of any new
account/file/instance created. </p></td>
                </tr>
              
                <tr>
                  <td>transactionHash</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The hash of the Transaction that executed (not the hash of any Transaction that failed for
having a duplicate TransactionID) </p></td>
                </tr>
              
                <tr>
                  <td>consensusTimestamp</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>The consensus timestamp (or null if didn&#39;t reach consensus yet) </p></td>
                </tr>
              
                <tr>
                  <td>transactionID</td>
                  <td><a href="#proto.TransactionID">TransactionID</a></td>
                  <td></td>
                  <td><p>The ID of the transaction this record represents </p></td>
                </tr>
              
                <tr>
                  <td>memo</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The memo that was submitted as part of the transaction (max 100 bytes) </p></td>
                </tr>
              
                <tr>
                  <td>transactionFee</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>The actual transaction fee charged, not the original transactionFee value from
TransactionBody </p></td>
                </tr>
              
                <tr>
                  <td>contractCallResult</td>
                  <td><a href="#proto.ContractFunctionResult">ContractFunctionResult</a></td>
                  <td></td>
                  <td><p>Record of the value returned by the smart contract function (if it completed and didn&#39;t
fail) from ContractCallTransaction </p></td>
                </tr>
              
                <tr>
                  <td>contractCreateResult</td>
                  <td><a href="#proto.ContractFunctionResult">ContractFunctionResult</a></td>
                  <td></td>
                  <td><p>Record of the value returned by the smart contract constructor (if it completed and
didn&#39;t fail) from ContractCreateTransaction </p></td>
                </tr>
              
                <tr>
                  <td>transferList</td>
                  <td><a href="#proto.TransferList">TransferList</a></td>
                  <td></td>
                  <td><p>All hbar transfers as a result of this transaction, such as fees, or transfers performed by
the transaction, or by a smart contract it calls, or by the creation of threshold records
that it triggers. </p></td>
                </tr>
              
                <tr>
                  <td>tokenTransferLists</td>
                  <td><a href="#proto.TokenTransferList">TokenTransferList</a></td>
                  <td>repeated</td>
                  <td><p>All Token transfers as a result of this transaction </p></td>
                </tr>
              
                <tr>
                  <td>scheduleRef</td>
                  <td><a href="#proto.ScheduleID">ScheduleID</a></td>
                  <td></td>
                  <td><p>Reference to the scheduled transaction ID that this transaction record represent </p></td>
                </tr>
              
                <tr>
                  <td>assessed_custom_fees</td>
                  <td><a href="#proto.AssessedCustomFee">AssessedCustomFee</a></td>
                  <td>repeated</td>
                  <td><p>All custom fees that were assessed during a CryptoTransfer, and must be paid if the
transaction status resolved to SUCCESS </p></td>
                </tr>
              
                <tr>
                  <td>automatic_token_associations</td>
                  <td><a href="#proto.TokenAssociation">TokenAssociation</a></td>
                  <td>repeated</td>
                  <td><p>All token associations implicitly created while handling this transaction </p></td>
                </tr>
              
                <tr>
                  <td>parent_consensus_timestamp</td>
                  <td><a href="#proto.Timestamp">Timestamp</a></td>
                  <td></td>
                  <td><p>In the record of an internal transaction, the consensus timestamp of the user
transaction that spawned it. </p></td>
                </tr>
              
                <tr>
                  <td>alias</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>In the record of an internal CryptoCreate transaction triggered by a user 
transaction with a (previously unused) alias, the new account&#39;s alias. </p></td>
                </tr>
              
                <tr>
                  <td>ethereum_hash</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The keccak256 hash of the ethereumData. This field will only be populated for 
EthereumTransaction. </p></td>
                </tr>
              
                <tr>
                  <td>paid_staking_rewards</td>
                  <td><a href="#proto.AccountAmount">AccountAmount</a></td>
                  <td>repeated</td>
                  <td><p>List of accounts with the corresponding staking rewards paid as a result of a transaction. </p></td>
                </tr>
              
                <tr>
                  <td>prng_bytes</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>In the record of a UtilPrng transaction with no output range, a pseudorandom 384-bit string. </p></td>
                </tr>
              
                <tr>
                  <td>prng_number</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p>In the record of a PRNG transaction with an output range, the output of a PRNG whose input was a 384-bit string. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="transaction_response.proto">transaction_response.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.TransactionResponse">TransactionResponse</h3>
        <p>When the client sends the node a transaction of any kind, the node replies with this, which</p><p>simply says that the transaction passed the precheck (so the node will submit it to the network)</p><p>or it failed (so it won't). If the fee offered was insufficient, this will also contain the</p><p>amount of the required fee. To learn the consensus result, the client should later obtain a</p><p>receipt (free), or can buy a more detailed record (not free).</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>nodeTransactionPrecheckCode</td>
                  <td><a href="#proto.ResponseCodeEnum">ResponseCodeEnum</a></td>
                  <td></td>
                  <td><p>The response code that indicates the current status of the transaction. </p></td>
                </tr>
              
                <tr>
                  <td>cost</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>If the response code was INSUFFICIENT_TX_FEE, the actual transaction fee that would be
required to execute the transaction. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="unchecked_submit.proto">unchecked_submit.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.UncheckedSubmitBody">UncheckedSubmitBody</h3>
        <p>Submit an arbitrary (serialized) Transaction to the network without prechecks. Requires superuser</p><p>privileges.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>transactionBytes</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The serialized bytes of the Transaction to be submitted without prechecks </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="util_prng.proto">util_prng.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="proto.UtilPrngTransactionBody">UtilPrngTransactionBody</h3>
        <p>Generates a pseudorandom number</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>range</td>
                  <td><a href="#int32">int32</a></td>
                  <td></td>
                  <td><p>If provided and is positive, returns a 32-bit pseudorandom number from the given range in the transaction record.
If not set or set to zero, will return a 384-bit pseudorandom number in the record. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
    
      
      <div class="file-heading">
        <h2 id="util_service.proto">util_service.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      

      

      

      
        <h3 id="proto.UtilService">UtilService</h3>
        <p>The requests and responses for different utility services.</p>
        <table class="enum-table">
          <thead>
            <tr><td>Method Name</td><td>Request Type</td><td>Response Type</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>prng</td>
                <td><a href="#proto.Transaction">Transaction</a></td>
                <td><a href="#proto.TransactionResponse">TransactionResponse</a></td>
                <td><p>Generates a pseudorandom number.</p></td>
              </tr>
            
          </tbody>
        </table>

        
    

    <h2 id="scalar-value-types">Scalar Value Types</h2>
    <table class="scalar-value-types-table">
      <thead>
        <tr><td>.proto Type</td><td>Notes</td><td>C++</td><td>Java</td><td>Python</td><td>Go</td><td>C#</td><td>PHP</td><td>Ruby</td></tr>
      </thead>
      <tbody>
        
          <tr id="double">
            <td>double</td>
            <td></td>
            <td>double</td>
            <td>double</td>
            <td>float</td>
            <td>float64</td>
            <td>double</td>
            <td>float</td>
            <td>Float</td>
          </tr>
        
          <tr id="float">
            <td>float</td>
            <td></td>
            <td>float</td>
            <td>float</td>
            <td>float</td>
            <td>float32</td>
            <td>float</td>
            <td>float</td>
            <td>Float</td>
          </tr>
        
          <tr id="int32">
            <td>int32</td>
            <td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.</td>
            <td>int32</td>
            <td>int</td>
            <td>int</td>
            <td>int32</td>
            <td>int</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="int64">
            <td>int64</td>
            <td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.</td>
            <td>int64</td>
            <td>long</td>
            <td>int/long</td>
            <td>int64</td>
            <td>long</td>
            <td>integer/string</td>
            <td>Bignum</td>
          </tr>
        
          <tr id="uint32">
            <td>uint32</td>
            <td>Uses variable-length encoding.</td>
            <td>uint32</td>
            <td>int</td>
            <td>int/long</td>
            <td>uint32</td>
            <td>uint</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="uint64">
            <td>uint64</td>
            <td>Uses variable-length encoding.</td>
            <td>uint64</td>
            <td>long</td>
            <td>int/long</td>
            <td>uint64</td>
            <td>ulong</td>
            <td>integer/string</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="sint32">
            <td>sint32</td>
            <td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.</td>
            <td>int32</td>
            <td>int</td>
            <td>int</td>
            <td>int32</td>
            <td>int</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="sint64">
            <td>sint64</td>
            <td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.</td>
            <td>int64</td>
            <td>long</td>
            <td>int/long</td>
            <td>int64</td>
            <td>long</td>
            <td>integer/string</td>
            <td>Bignum</td>
          </tr>
        
          <tr id="fixed32">
            <td>fixed32</td>
            <td>Always four bytes. More efficient than uint32 if values are often greater than 2^28.</td>
            <td>uint32</td>
            <td>int</td>
            <td>int</td>
            <td>uint32</td>
            <td>uint</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="fixed64">
            <td>fixed64</td>
            <td>Always eight bytes. More efficient than uint64 if values are often greater than 2^56.</td>
            <td>uint64</td>
            <td>long</td>
            <td>int/long</td>
            <td>uint64</td>
            <td>ulong</td>
            <td>integer/string</td>
            <td>Bignum</td>
          </tr>
        
          <tr id="sfixed32">
            <td>sfixed32</td>
            <td>Always four bytes.</td>
            <td>int32</td>
            <td>int</td>
            <td>int</td>
            <td>int32</td>
            <td>int</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="sfixed64">
            <td>sfixed64</td>
            <td>Always eight bytes.</td>
            <td>int64</td>
            <td>long</td>
            <td>int/long</td>
            <td>int64</td>
            <td>long</td>
            <td>integer/string</td>
            <td>Bignum</td>
          </tr>
        
          <tr id="bool">
            <td>bool</td>
            <td></td>
            <td>bool</td>
            <td>boolean</td>
            <td>boolean</td>
            <td>bool</td>
            <td>bool</td>
            <td>boolean</td>
            <td>TrueClass/FalseClass</td>
          </tr>
        
          <tr id="string">
            <td>string</td>
            <td>A string must always contain UTF-8 encoded or 7-bit ASCII text.</td>
            <td>string</td>
            <td>String</td>
            <td>str/unicode</td>
            <td>string</td>
            <td>string</td>
            <td>string</td>
            <td>String (UTF-8)</td>
          </tr>
        
          <tr id="bytes">
            <td>bytes</td>
            <td>May contain any arbitrary sequence of bytes.</td>
            <td>string</td>
            <td>ByteString</td>
            <td>str</td>
            <td>[]byte</td>
            <td>ByteString</td>
            <td>string</td>
            <td>String (ASCII-8BIT)</td>
          </tr>
        
      </tbody>
    </table>
  </body>
</html>

